module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 12);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/*!************************!*\
  !*** external "react" ***!
  \************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports) {

eval("module.exports = require(\"react\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9leHRlcm5hbCBcInJlYWN0XCI/M2M2MiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJyZWFjdFwiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcInJlYWN0XCJcbi8vIG1vZHVsZSBpZCA9IDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///0\n");

/***/ }),
/* 1 */
/*!***********************************************!*\
  !*** ./node_modules/underscore/underscore.js ***!
  \***********************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

eval("//     Underscore.js 1.4.4\n//     http://underscorejs.org\n//     (c) 2009-2013 Jeremy Ashkenas, DocumentCloud Inc.\n//     Underscore may be freely distributed under the MIT license.\n\n(function() {\n\n  // Baseline setup\n  // --------------\n\n  // Establish the root object, `window` in the browser, or `global` on the server.\n  var root = this;\n\n  // Save the previous value of the `_` variable.\n  var previousUnderscore = root._;\n\n  // Establish the object that gets returned to break out of a loop iteration.\n  var breaker = {};\n\n  // Save bytes in the minified (but not gzipped) version:\n  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;\n\n  // Create quick reference variables for speed access to core prototypes.\n  var push             = ArrayProto.push,\n      slice            = ArrayProto.slice,\n      concat           = ArrayProto.concat,\n      toString         = ObjProto.toString,\n      hasOwnProperty   = ObjProto.hasOwnProperty;\n\n  // All **ECMAScript 5** native function implementations that we hope to use\n  // are declared here.\n  var\n    nativeForEach      = ArrayProto.forEach,\n    nativeMap          = ArrayProto.map,\n    nativeReduce       = ArrayProto.reduce,\n    nativeReduceRight  = ArrayProto.reduceRight,\n    nativeFilter       = ArrayProto.filter,\n    nativeEvery        = ArrayProto.every,\n    nativeSome         = ArrayProto.some,\n    nativeIndexOf      = ArrayProto.indexOf,\n    nativeLastIndexOf  = ArrayProto.lastIndexOf,\n    nativeIsArray      = Array.isArray,\n    nativeKeys         = Object.keys,\n    nativeBind         = FuncProto.bind;\n\n  // Create a safe reference to the Underscore object for use below.\n  var _ = function(obj) {\n    if (obj instanceof _) return obj;\n    if (!(this instanceof _)) return new _(obj);\n    this._wrapped = obj;\n  };\n\n  // Export the Underscore object for **Node.js**, with\n  // backwards-compatibility for the old `require()` API. If we're in\n  // the browser, add `_` as a global object via a string identifier,\n  // for Closure Compiler \"advanced\" mode.\n  if (true) {\n    if (typeof module !== 'undefined' && module.exports) {\n      exports = module.exports = _;\n    }\n    exports._ = _;\n  } else {\n    root._ = _;\n  }\n\n  // Current version.\n  _.VERSION = '1.4.4';\n\n  // Collection Functions\n  // --------------------\n\n  // The cornerstone, an `each` implementation, aka `forEach`.\n  // Handles objects with the built-in `forEach`, arrays, and raw objects.\n  // Delegates to **ECMAScript 5**'s native `forEach` if available.\n  var each = _.each = _.forEach = function(obj, iterator, context) {\n    if (obj == null) return;\n    if (nativeForEach && obj.forEach === nativeForEach) {\n      obj.forEach(iterator, context);\n    } else if (obj.length === +obj.length) {\n      for (var i = 0, l = obj.length; i < l; i++) {\n        if (iterator.call(context, obj[i], i, obj) === breaker) return;\n      }\n    } else {\n      for (var key in obj) {\n        if (_.has(obj, key)) {\n          if (iterator.call(context, obj[key], key, obj) === breaker) return;\n        }\n      }\n    }\n  };\n\n  // Return the results of applying the iterator to each element.\n  // Delegates to **ECMAScript 5**'s native `map` if available.\n  _.map = _.collect = function(obj, iterator, context) {\n    var results = [];\n    if (obj == null) return results;\n    if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);\n    each(obj, function(value, index, list) {\n      results[results.length] = iterator.call(context, value, index, list);\n    });\n    return results;\n  };\n\n  var reduceError = 'Reduce of empty array with no initial value';\n\n  // **Reduce** builds up a single result from a list of values, aka `inject`,\n  // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.\n  _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {\n    var initial = arguments.length > 2;\n    if (obj == null) obj = [];\n    if (nativeReduce && obj.reduce === nativeReduce) {\n      if (context) iterator = _.bind(iterator, context);\n      return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);\n    }\n    each(obj, function(value, index, list) {\n      if (!initial) {\n        memo = value;\n        initial = true;\n      } else {\n        memo = iterator.call(context, memo, value, index, list);\n      }\n    });\n    if (!initial) throw new TypeError(reduceError);\n    return memo;\n  };\n\n  // The right-associative version of reduce, also known as `foldr`.\n  // Delegates to **ECMAScript 5**'s native `reduceRight` if available.\n  _.reduceRight = _.foldr = function(obj, iterator, memo, context) {\n    var initial = arguments.length > 2;\n    if (obj == null) obj = [];\n    if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {\n      if (context) iterator = _.bind(iterator, context);\n      return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);\n    }\n    var length = obj.length;\n    if (length !== +length) {\n      var keys = _.keys(obj);\n      length = keys.length;\n    }\n    each(obj, function(value, index, list) {\n      index = keys ? keys[--length] : --length;\n      if (!initial) {\n        memo = obj[index];\n        initial = true;\n      } else {\n        memo = iterator.call(context, memo, obj[index], index, list);\n      }\n    });\n    if (!initial) throw new TypeError(reduceError);\n    return memo;\n  };\n\n  // Return the first value which passes a truth test. Aliased as `detect`.\n  _.find = _.detect = function(obj, iterator, context) {\n    var result;\n    any(obj, function(value, index, list) {\n      if (iterator.call(context, value, index, list)) {\n        result = value;\n        return true;\n      }\n    });\n    return result;\n  };\n\n  // Return all the elements that pass a truth test.\n  // Delegates to **ECMAScript 5**'s native `filter` if available.\n  // Aliased as `select`.\n  _.filter = _.select = function(obj, iterator, context) {\n    var results = [];\n    if (obj == null) return results;\n    if (nativeFilter && obj.filter === nativeFilter) return obj.filter(iterator, context);\n    each(obj, function(value, index, list) {\n      if (iterator.call(context, value, index, list)) results[results.length] = value;\n    });\n    return results;\n  };\n\n  // Return all the elements for which a truth test fails.\n  _.reject = function(obj, iterator, context) {\n    return _.filter(obj, function(value, index, list) {\n      return !iterator.call(context, value, index, list);\n    }, context);\n  };\n\n  // Determine whether all of the elements match a truth test.\n  // Delegates to **ECMAScript 5**'s native `every` if available.\n  // Aliased as `all`.\n  _.every = _.all = function(obj, iterator, context) {\n    iterator || (iterator = _.identity);\n    var result = true;\n    if (obj == null) return result;\n    if (nativeEvery && obj.every === nativeEvery) return obj.every(iterator, context);\n    each(obj, function(value, index, list) {\n      if (!(result = result && iterator.call(context, value, index, list))) return breaker;\n    });\n    return !!result;\n  };\n\n  // Determine if at least one element in the object matches a truth test.\n  // Delegates to **ECMAScript 5**'s native `some` if available.\n  // Aliased as `any`.\n  var any = _.some = _.any = function(obj, iterator, context) {\n    iterator || (iterator = _.identity);\n    var result = false;\n    if (obj == null) return result;\n    if (nativeSome && obj.some === nativeSome) return obj.some(iterator, context);\n    each(obj, function(value, index, list) {\n      if (result || (result = iterator.call(context, value, index, list))) return breaker;\n    });\n    return !!result;\n  };\n\n  // Determine if the array or object contains a given value (using `===`).\n  // Aliased as `include`.\n  _.contains = _.include = function(obj, target) {\n    if (obj == null) return false;\n    if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;\n    return any(obj, function(value) {\n      return value === target;\n    });\n  };\n\n  // Invoke a method (with arguments) on every item in a collection.\n  _.invoke = function(obj, method) {\n    var args = slice.call(arguments, 2);\n    var isFunc = _.isFunction(method);\n    return _.map(obj, function(value) {\n      return (isFunc ? method : value[method]).apply(value, args);\n    });\n  };\n\n  // Convenience version of a common use case of `map`: fetching a property.\n  _.pluck = function(obj, key) {\n    return _.map(obj, function(value){ return value[key]; });\n  };\n\n  // Convenience version of a common use case of `filter`: selecting only objects\n  // containing specific `key:value` pairs.\n  _.where = function(obj, attrs, first) {\n    if (_.isEmpty(attrs)) return first ? null : [];\n    return _[first ? 'find' : 'filter'](obj, function(value) {\n      for (var key in attrs) {\n        if (attrs[key] !== value[key]) return false;\n      }\n      return true;\n    });\n  };\n\n  // Convenience version of a common use case of `find`: getting the first object\n  // containing specific `key:value` pairs.\n  _.findWhere = function(obj, attrs) {\n    return _.where(obj, attrs, true);\n  };\n\n  // Return the maximum element or (element-based computation).\n  // Can't optimize arrays of integers longer than 65,535 elements.\n  // See: https://bugs.webkit.org/show_bug.cgi?id=80797\n  _.max = function(obj, iterator, context) {\n    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {\n      return Math.max.apply(Math, obj);\n    }\n    if (!iterator && _.isEmpty(obj)) return -Infinity;\n    var result = {computed : -Infinity, value: -Infinity};\n    each(obj, function(value, index, list) {\n      var computed = iterator ? iterator.call(context, value, index, list) : value;\n      computed >= result.computed && (result = {value : value, computed : computed});\n    });\n    return result.value;\n  };\n\n  // Return the minimum element (or element-based computation).\n  _.min = function(obj, iterator, context) {\n    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {\n      return Math.min.apply(Math, obj);\n    }\n    if (!iterator && _.isEmpty(obj)) return Infinity;\n    var result = {computed : Infinity, value: Infinity};\n    each(obj, function(value, index, list) {\n      var computed = iterator ? iterator.call(context, value, index, list) : value;\n      computed < result.computed && (result = {value : value, computed : computed});\n    });\n    return result.value;\n  };\n\n  // Shuffle an array.\n  _.shuffle = function(obj) {\n    var rand;\n    var index = 0;\n    var shuffled = [];\n    each(obj, function(value) {\n      rand = _.random(index++);\n      shuffled[index - 1] = shuffled[rand];\n      shuffled[rand] = value;\n    });\n    return shuffled;\n  };\n\n  // An internal function to generate lookup iterators.\n  var lookupIterator = function(value) {\n    return _.isFunction(value) ? value : function(obj){ return obj[value]; };\n  };\n\n  // Sort the object's values by a criterion produced by an iterator.\n  _.sortBy = function(obj, value, context) {\n    var iterator = lookupIterator(value);\n    return _.pluck(_.map(obj, function(value, index, list) {\n      return {\n        value : value,\n        index : index,\n        criteria : iterator.call(context, value, index, list)\n      };\n    }).sort(function(left, right) {\n      var a = left.criteria;\n      var b = right.criteria;\n      if (a !== b) {\n        if (a > b || a === void 0) return 1;\n        if (a < b || b === void 0) return -1;\n      }\n      return left.index < right.index ? -1 : 1;\n    }), 'value');\n  };\n\n  // An internal function used for aggregate \"group by\" operations.\n  var group = function(obj, value, context, behavior) {\n    var result = {};\n    var iterator = lookupIterator(value || _.identity);\n    each(obj, function(value, index) {\n      var key = iterator.call(context, value, index, obj);\n      behavior(result, key, value);\n    });\n    return result;\n  };\n\n  // Groups the object's values by a criterion. Pass either a string attribute\n  // to group by, or a function that returns the criterion.\n  _.groupBy = function(obj, value, context) {\n    return group(obj, value, context, function(result, key, value) {\n      (_.has(result, key) ? result[key] : (result[key] = [])).push(value);\n    });\n  };\n\n  // Counts instances of an object that group by a certain criterion. Pass\n  // either a string attribute to count by, or a function that returns the\n  // criterion.\n  _.countBy = function(obj, value, context) {\n    return group(obj, value, context, function(result, key) {\n      if (!_.has(result, key)) result[key] = 0;\n      result[key]++;\n    });\n  };\n\n  // Use a comparator function to figure out the smallest index at which\n  // an object should be inserted so as to maintain order. Uses binary search.\n  _.sortedIndex = function(array, obj, iterator, context) {\n    iterator = iterator == null ? _.identity : lookupIterator(iterator);\n    var value = iterator.call(context, obj);\n    var low = 0, high = array.length;\n    while (low < high) {\n      var mid = (low + high) >>> 1;\n      iterator.call(context, array[mid]) < value ? low = mid + 1 : high = mid;\n    }\n    return low;\n  };\n\n  // Safely convert anything iterable into a real, live array.\n  _.toArray = function(obj) {\n    if (!obj) return [];\n    if (_.isArray(obj)) return slice.call(obj);\n    if (obj.length === +obj.length) return _.map(obj, _.identity);\n    return _.values(obj);\n  };\n\n  // Return the number of elements in an object.\n  _.size = function(obj) {\n    if (obj == null) return 0;\n    return (obj.length === +obj.length) ? obj.length : _.keys(obj).length;\n  };\n\n  // Array Functions\n  // ---------------\n\n  // Get the first element of an array. Passing **n** will return the first N\n  // values in the array. Aliased as `head` and `take`. The **guard** check\n  // allows it to work with `_.map`.\n  _.first = _.head = _.take = function(array, n, guard) {\n    if (array == null) return void 0;\n    return (n != null) && !guard ? slice.call(array, 0, n) : array[0];\n  };\n\n  // Returns everything but the last entry of the array. Especially useful on\n  // the arguments object. Passing **n** will return all the values in\n  // the array, excluding the last N. The **guard** check allows it to work with\n  // `_.map`.\n  _.initial = function(array, n, guard) {\n    return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));\n  };\n\n  // Get the last element of an array. Passing **n** will return the last N\n  // values in the array. The **guard** check allows it to work with `_.map`.\n  _.last = function(array, n, guard) {\n    if (array == null) return void 0;\n    if ((n != null) && !guard) {\n      return slice.call(array, Math.max(array.length - n, 0));\n    } else {\n      return array[array.length - 1];\n    }\n  };\n\n  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.\n  // Especially useful on the arguments object. Passing an **n** will return\n  // the rest N values in the array. The **guard**\n  // check allows it to work with `_.map`.\n  _.rest = _.tail = _.drop = function(array, n, guard) {\n    return slice.call(array, (n == null) || guard ? 1 : n);\n  };\n\n  // Trim out all falsy values from an array.\n  _.compact = function(array) {\n    return _.filter(array, _.identity);\n  };\n\n  // Internal implementation of a recursive `flatten` function.\n  var flatten = function(input, shallow, output) {\n    each(input, function(value) {\n      if (_.isArray(value)) {\n        shallow ? push.apply(output, value) : flatten(value, shallow, output);\n      } else {\n        output.push(value);\n      }\n    });\n    return output;\n  };\n\n  // Return a completely flattened version of an array.\n  _.flatten = function(array, shallow) {\n    return flatten(array, shallow, []);\n  };\n\n  // Return a version of the array that does not contain the specified value(s).\n  _.without = function(array) {\n    return _.difference(array, slice.call(arguments, 1));\n  };\n\n  // Produce a duplicate-free version of the array. If the array has already\n  // been sorted, you have the option of using a faster algorithm.\n  // Aliased as `unique`.\n  _.uniq = _.unique = function(array, isSorted, iterator, context) {\n    if (_.isFunction(isSorted)) {\n      context = iterator;\n      iterator = isSorted;\n      isSorted = false;\n    }\n    var initial = iterator ? _.map(array, iterator, context) : array;\n    var results = [];\n    var seen = [];\n    each(initial, function(value, index) {\n      if (isSorted ? (!index || seen[seen.length - 1] !== value) : !_.contains(seen, value)) {\n        seen.push(value);\n        results.push(array[index]);\n      }\n    });\n    return results;\n  };\n\n  // Produce an array that contains the union: each distinct element from all of\n  // the passed-in arrays.\n  _.union = function() {\n    return _.uniq(concat.apply(ArrayProto, arguments));\n  };\n\n  // Produce an array that contains every item shared between all the\n  // passed-in arrays.\n  _.intersection = function(array) {\n    var rest = slice.call(arguments, 1);\n    return _.filter(_.uniq(array), function(item) {\n      return _.every(rest, function(other) {\n        return _.indexOf(other, item) >= 0;\n      });\n    });\n  };\n\n  // Take the difference between one array and a number of other arrays.\n  // Only the elements present in just the first array will remain.\n  _.difference = function(array) {\n    var rest = concat.apply(ArrayProto, slice.call(arguments, 1));\n    return _.filter(array, function(value){ return !_.contains(rest, value); });\n  };\n\n  // Zip together multiple lists into a single array -- elements that share\n  // an index go together.\n  _.zip = function() {\n    var args = slice.call(arguments);\n    var length = _.max(_.pluck(args, 'length'));\n    var results = new Array(length);\n    for (var i = 0; i < length; i++) {\n      results[i] = _.pluck(args, \"\" + i);\n    }\n    return results;\n  };\n\n  // Converts lists into objects. Pass either a single array of `[key, value]`\n  // pairs, or two parallel arrays of the same length -- one of keys, and one of\n  // the corresponding values.\n  _.object = function(list, values) {\n    if (list == null) return {};\n    var result = {};\n    for (var i = 0, l = list.length; i < l; i++) {\n      if (values) {\n        result[list[i]] = values[i];\n      } else {\n        result[list[i][0]] = list[i][1];\n      }\n    }\n    return result;\n  };\n\n  // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),\n  // we need this function. Return the position of the first occurrence of an\n  // item in an array, or -1 if the item is not included in the array.\n  // Delegates to **ECMAScript 5**'s native `indexOf` if available.\n  // If the array is large and already in sort order, pass `true`\n  // for **isSorted** to use binary search.\n  _.indexOf = function(array, item, isSorted) {\n    if (array == null) return -1;\n    var i = 0, l = array.length;\n    if (isSorted) {\n      if (typeof isSorted == 'number') {\n        i = (isSorted < 0 ? Math.max(0, l + isSorted) : isSorted);\n      } else {\n        i = _.sortedIndex(array, item);\n        return array[i] === item ? i : -1;\n      }\n    }\n    if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item, isSorted);\n    for (; i < l; i++) if (array[i] === item) return i;\n    return -1;\n  };\n\n  // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.\n  _.lastIndexOf = function(array, item, from) {\n    if (array == null) return -1;\n    var hasIndex = from != null;\n    if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) {\n      return hasIndex ? array.lastIndexOf(item, from) : array.lastIndexOf(item);\n    }\n    var i = (hasIndex ? from : array.length);\n    while (i--) if (array[i] === item) return i;\n    return -1;\n  };\n\n  // Generate an integer Array containing an arithmetic progression. A port of\n  // the native Python `range()` function. See\n  // [the Python documentation](http://docs.python.org/library/functions.html#range).\n  _.range = function(start, stop, step) {\n    if (arguments.length <= 1) {\n      stop = start || 0;\n      start = 0;\n    }\n    step = arguments[2] || 1;\n\n    var len = Math.max(Math.ceil((stop - start) / step), 0);\n    var idx = 0;\n    var range = new Array(len);\n\n    while(idx < len) {\n      range[idx++] = start;\n      start += step;\n    }\n\n    return range;\n  };\n\n  // Function (ahem) Functions\n  // ------------------\n\n  // Create a function bound to a given object (assigning `this`, and arguments,\n  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if\n  // available.\n  _.bind = function(func, context) {\n    if (func.bind === nativeBind && nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));\n    var args = slice.call(arguments, 2);\n    return function() {\n      return func.apply(context, args.concat(slice.call(arguments)));\n    };\n  };\n\n  // Partially apply a function by creating a version that has had some of its\n  // arguments pre-filled, without changing its dynamic `this` context.\n  _.partial = function(func) {\n    var args = slice.call(arguments, 1);\n    return function() {\n      return func.apply(this, args.concat(slice.call(arguments)));\n    };\n  };\n\n  // Bind all of an object's methods to that object. Useful for ensuring that\n  // all callbacks defined on an object belong to it.\n  _.bindAll = function(obj) {\n    var funcs = slice.call(arguments, 1);\n    if (funcs.length === 0) funcs = _.functions(obj);\n    each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });\n    return obj;\n  };\n\n  // Memoize an expensive function by storing its results.\n  _.memoize = function(func, hasher) {\n    var memo = {};\n    hasher || (hasher = _.identity);\n    return function() {\n      var key = hasher.apply(this, arguments);\n      return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));\n    };\n  };\n\n  // Delays a function for the given number of milliseconds, and then calls\n  // it with the arguments supplied.\n  _.delay = function(func, wait) {\n    var args = slice.call(arguments, 2);\n    return setTimeout(function(){ return func.apply(null, args); }, wait);\n  };\n\n  // Defers a function, scheduling it to run after the current call stack has\n  // cleared.\n  _.defer = function(func) {\n    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));\n  };\n\n  // Returns a function, that, when invoked, will only be triggered at most once\n  // during a given window of time.\n  _.throttle = function(func, wait) {\n    var context, args, timeout, result;\n    var previous = 0;\n    var later = function() {\n      previous = new Date;\n      timeout = null;\n      result = func.apply(context, args);\n    };\n    return function() {\n      var now = new Date;\n      var remaining = wait - (now - previous);\n      context = this;\n      args = arguments;\n      if (remaining <= 0) {\n        clearTimeout(timeout);\n        timeout = null;\n        previous = now;\n        result = func.apply(context, args);\n      } else if (!timeout) {\n        timeout = setTimeout(later, remaining);\n      }\n      return result;\n    };\n  };\n\n  // Returns a function, that, as long as it continues to be invoked, will not\n  // be triggered. The function will be called after it stops being called for\n  // N milliseconds. If `immediate` is passed, trigger the function on the\n  // leading edge, instead of the trailing.\n  _.debounce = function(func, wait, immediate) {\n    var timeout, result;\n    return function() {\n      var context = this, args = arguments;\n      var later = function() {\n        timeout = null;\n        if (!immediate) result = func.apply(context, args);\n      };\n      var callNow = immediate && !timeout;\n      clearTimeout(timeout);\n      timeout = setTimeout(later, wait);\n      if (callNow) result = func.apply(context, args);\n      return result;\n    };\n  };\n\n  // Returns a function that will be executed at most one time, no matter how\n  // often you call it. Useful for lazy initialization.\n  _.once = function(func) {\n    var ran = false, memo;\n    return function() {\n      if (ran) return memo;\n      ran = true;\n      memo = func.apply(this, arguments);\n      func = null;\n      return memo;\n    };\n  };\n\n  // Returns the first function passed as an argument to the second,\n  // allowing you to adjust arguments, run code before and after, and\n  // conditionally execute the original function.\n  _.wrap = function(func, wrapper) {\n    return function() {\n      var args = [func];\n      push.apply(args, arguments);\n      return wrapper.apply(this, args);\n    };\n  };\n\n  // Returns a function that is the composition of a list of functions, each\n  // consuming the return value of the function that follows.\n  _.compose = function() {\n    var funcs = arguments;\n    return function() {\n      var args = arguments;\n      for (var i = funcs.length - 1; i >= 0; i--) {\n        args = [funcs[i].apply(this, args)];\n      }\n      return args[0];\n    };\n  };\n\n  // Returns a function that will only be executed after being called N times.\n  _.after = function(times, func) {\n    if (times <= 0) return func();\n    return function() {\n      if (--times < 1) {\n        return func.apply(this, arguments);\n      }\n    };\n  };\n\n  // Object Functions\n  // ----------------\n\n  // Retrieve the names of an object's properties.\n  // Delegates to **ECMAScript 5**'s native `Object.keys`\n  _.keys = nativeKeys || function(obj) {\n    if (obj !== Object(obj)) throw new TypeError('Invalid object');\n    var keys = [];\n    for (var key in obj) if (_.has(obj, key)) keys[keys.length] = key;\n    return keys;\n  };\n\n  // Retrieve the values of an object's properties.\n  _.values = function(obj) {\n    var values = [];\n    for (var key in obj) if (_.has(obj, key)) values.push(obj[key]);\n    return values;\n  };\n\n  // Convert an object into a list of `[key, value]` pairs.\n  _.pairs = function(obj) {\n    var pairs = [];\n    for (var key in obj) if (_.has(obj, key)) pairs.push([key, obj[key]]);\n    return pairs;\n  };\n\n  // Invert the keys and values of an object. The values must be serializable.\n  _.invert = function(obj) {\n    var result = {};\n    for (var key in obj) if (_.has(obj, key)) result[obj[key]] = key;\n    return result;\n  };\n\n  // Return a sorted list of the function names available on the object.\n  // Aliased as `methods`\n  _.functions = _.methods = function(obj) {\n    var names = [];\n    for (var key in obj) {\n      if (_.isFunction(obj[key])) names.push(key);\n    }\n    return names.sort();\n  };\n\n  // Extend a given object with all the properties in passed-in object(s).\n  _.extend = function(obj) {\n    each(slice.call(arguments, 1), function(source) {\n      if (source) {\n        for (var prop in source) {\n          obj[prop] = source[prop];\n        }\n      }\n    });\n    return obj;\n  };\n\n  // Return a copy of the object only containing the whitelisted properties.\n  _.pick = function(obj) {\n    var copy = {};\n    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));\n    each(keys, function(key) {\n      if (key in obj) copy[key] = obj[key];\n    });\n    return copy;\n  };\n\n   // Return a copy of the object without the blacklisted properties.\n  _.omit = function(obj) {\n    var copy = {};\n    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));\n    for (var key in obj) {\n      if (!_.contains(keys, key)) copy[key] = obj[key];\n    }\n    return copy;\n  };\n\n  // Fill in a given object with default properties.\n  _.defaults = function(obj) {\n    each(slice.call(arguments, 1), function(source) {\n      if (source) {\n        for (var prop in source) {\n          if (obj[prop] == null) obj[prop] = source[prop];\n        }\n      }\n    });\n    return obj;\n  };\n\n  // Create a (shallow-cloned) duplicate of an object.\n  _.clone = function(obj) {\n    if (!_.isObject(obj)) return obj;\n    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);\n  };\n\n  // Invokes interceptor with the obj, and then returns obj.\n  // The primary purpose of this method is to \"tap into\" a method chain, in\n  // order to perform operations on intermediate results within the chain.\n  _.tap = function(obj, interceptor) {\n    interceptor(obj);\n    return obj;\n  };\n\n  // Internal recursive comparison function for `isEqual`.\n  var eq = function(a, b, aStack, bStack) {\n    // Identical objects are equal. `0 === -0`, but they aren't identical.\n    // See the Harmony `egal` proposal: http://wiki.ecmascript.org/doku.php?id=harmony:egal.\n    if (a === b) return a !== 0 || 1 / a == 1 / b;\n    // A strict comparison is necessary because `null == undefined`.\n    if (a == null || b == null) return a === b;\n    // Unwrap any wrapped objects.\n    if (a instanceof _) a = a._wrapped;\n    if (b instanceof _) b = b._wrapped;\n    // Compare `[[Class]]` names.\n    var className = toString.call(a);\n    if (className != toString.call(b)) return false;\n    switch (className) {\n      // Strings, numbers, dates, and booleans are compared by value.\n      case '[object String]':\n        // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is\n        // equivalent to `new String(\"5\")`.\n        return a == String(b);\n      case '[object Number]':\n        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for\n        // other numeric values.\n        return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);\n      case '[object Date]':\n      case '[object Boolean]':\n        // Coerce dates and booleans to numeric primitive values. Dates are compared by their\n        // millisecond representations. Note that invalid dates with millisecond representations\n        // of `NaN` are not equivalent.\n        return +a == +b;\n      // RegExps are compared by their source patterns and flags.\n      case '[object RegExp]':\n        return a.source == b.source &&\n               a.global == b.global &&\n               a.multiline == b.multiline &&\n               a.ignoreCase == b.ignoreCase;\n    }\n    if (typeof a != 'object' || typeof b != 'object') return false;\n    // Assume equality for cyclic structures. The algorithm for detecting cyclic\n    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\n    var length = aStack.length;\n    while (length--) {\n      // Linear search. Performance is inversely proportional to the number of\n      // unique nested structures.\n      if (aStack[length] == a) return bStack[length] == b;\n    }\n    // Add the first object to the stack of traversed objects.\n    aStack.push(a);\n    bStack.push(b);\n    var size = 0, result = true;\n    // Recursively compare objects and arrays.\n    if (className == '[object Array]') {\n      // Compare array lengths to determine if a deep comparison is necessary.\n      size = a.length;\n      result = size == b.length;\n      if (result) {\n        // Deep compare the contents, ignoring non-numeric properties.\n        while (size--) {\n          if (!(result = eq(a[size], b[size], aStack, bStack))) break;\n        }\n      }\n    } else {\n      // Objects with different constructors are not equivalent, but `Object`s\n      // from different frames are.\n      var aCtor = a.constructor, bCtor = b.constructor;\n      if (aCtor !== bCtor && !(_.isFunction(aCtor) && (aCtor instanceof aCtor) &&\n                               _.isFunction(bCtor) && (bCtor instanceof bCtor))) {\n        return false;\n      }\n      // Deep compare objects.\n      for (var key in a) {\n        if (_.has(a, key)) {\n          // Count the expected number of properties.\n          size++;\n          // Deep compare each member.\n          if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack))) break;\n        }\n      }\n      // Ensure that both objects contain the same number of properties.\n      if (result) {\n        for (key in b) {\n          if (_.has(b, key) && !(size--)) break;\n        }\n        result = !size;\n      }\n    }\n    // Remove the first object from the stack of traversed objects.\n    aStack.pop();\n    bStack.pop();\n    return result;\n  };\n\n  // Perform a deep comparison to check if two objects are equal.\n  _.isEqual = function(a, b) {\n    return eq(a, b, [], []);\n  };\n\n  // Is a given array, string, or object empty?\n  // An \"empty\" object has no enumerable own-properties.\n  _.isEmpty = function(obj) {\n    if (obj == null) return true;\n    if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;\n    for (var key in obj) if (_.has(obj, key)) return false;\n    return true;\n  };\n\n  // Is a given value a DOM element?\n  _.isElement = function(obj) {\n    return !!(obj && obj.nodeType === 1);\n  };\n\n  // Is a given value an array?\n  // Delegates to ECMA5's native Array.isArray\n  _.isArray = nativeIsArray || function(obj) {\n    return toString.call(obj) == '[object Array]';\n  };\n\n  // Is a given variable an object?\n  _.isObject = function(obj) {\n    return obj === Object(obj);\n  };\n\n  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.\n  each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'], function(name) {\n    _['is' + name] = function(obj) {\n      return toString.call(obj) == '[object ' + name + ']';\n    };\n  });\n\n  // Define a fallback version of the method in browsers (ahem, IE), where\n  // there isn't any inspectable \"Arguments\" type.\n  if (!_.isArguments(arguments)) {\n    _.isArguments = function(obj) {\n      return !!(obj && _.has(obj, 'callee'));\n    };\n  }\n\n  // Optimize `isFunction` if appropriate.\n  if (true) {\n    _.isFunction = function(obj) {\n      return typeof obj === 'function';\n    };\n  }\n\n  // Is a given object a finite number?\n  _.isFinite = function(obj) {\n    return isFinite(obj) && !isNaN(parseFloat(obj));\n  };\n\n  // Is the given value `NaN`? (NaN is the only number which does not equal itself).\n  _.isNaN = function(obj) {\n    return _.isNumber(obj) && obj != +obj;\n  };\n\n  // Is a given value a boolean?\n  _.isBoolean = function(obj) {\n    return obj === true || obj === false || toString.call(obj) == '[object Boolean]';\n  };\n\n  // Is a given value equal to null?\n  _.isNull = function(obj) {\n    return obj === null;\n  };\n\n  // Is a given variable undefined?\n  _.isUndefined = function(obj) {\n    return obj === void 0;\n  };\n\n  // Shortcut function for checking if an object has a given property directly\n  // on itself (in other words, not on a prototype).\n  _.has = function(obj, key) {\n    return hasOwnProperty.call(obj, key);\n  };\n\n  // Utility Functions\n  // -----------------\n\n  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its\n  // previous owner. Returns a reference to the Underscore object.\n  _.noConflict = function() {\n    root._ = previousUnderscore;\n    return this;\n  };\n\n  // Keep the identity function around for default iterators.\n  _.identity = function(value) {\n    return value;\n  };\n\n  // Run a function **n** times.\n  _.times = function(n, iterator, context) {\n    var accum = Array(n);\n    for (var i = 0; i < n; i++) accum[i] = iterator.call(context, i);\n    return accum;\n  };\n\n  // Return a random integer between min and max (inclusive).\n  _.random = function(min, max) {\n    if (max == null) {\n      max = min;\n      min = 0;\n    }\n    return min + Math.floor(Math.random() * (max - min + 1));\n  };\n\n  // List of HTML entities for escaping.\n  var entityMap = {\n    escape: {\n      '&': '&amp;',\n      '<': '&lt;',\n      '>': '&gt;',\n      '\"': '&quot;',\n      \"'\": '&#x27;',\n      '/': '&#x2F;'\n    }\n  };\n  entityMap.unescape = _.invert(entityMap.escape);\n\n  // Regexes containing the keys and values listed immediately above.\n  var entityRegexes = {\n    escape:   new RegExp('[' + _.keys(entityMap.escape).join('') + ']', 'g'),\n    unescape: new RegExp('(' + _.keys(entityMap.unescape).join('|') + ')', 'g')\n  };\n\n  // Functions for escaping and unescaping strings to/from HTML interpolation.\n  _.each(['escape', 'unescape'], function(method) {\n    _[method] = function(string) {\n      if (string == null) return '';\n      return ('' + string).replace(entityRegexes[method], function(match) {\n        return entityMap[method][match];\n      });\n    };\n  });\n\n  // If the value of the named property is a function then invoke it;\n  // otherwise, return it.\n  _.result = function(object, property) {\n    if (object == null) return null;\n    var value = object[property];\n    return _.isFunction(value) ? value.call(object) : value;\n  };\n\n  // Add your own custom functions to the Underscore object.\n  _.mixin = function(obj) {\n    each(_.functions(obj), function(name){\n      var func = _[name] = obj[name];\n      _.prototype[name] = function() {\n        var args = [this._wrapped];\n        push.apply(args, arguments);\n        return result.call(this, func.apply(_, args));\n      };\n    });\n  };\n\n  // Generate a unique integer id (unique within the entire client session).\n  // Useful for temporary DOM ids.\n  var idCounter = 0;\n  _.uniqueId = function(prefix) {\n    var id = ++idCounter + '';\n    return prefix ? prefix + id : id;\n  };\n\n  // By default, Underscore uses ERB-style template delimiters, change the\n  // following template settings to use alternative delimiters.\n  _.templateSettings = {\n    evaluate    : /<%([\\s\\S]+?)%>/g,\n    interpolate : /<%=([\\s\\S]+?)%>/g,\n    escape      : /<%-([\\s\\S]+?)%>/g\n  };\n\n  // When customizing `templateSettings`, if you don't want to define an\n  // interpolation, evaluation or escaping regex, we need one that is\n  // guaranteed not to match.\n  var noMatch = /(.)^/;\n\n  // Certain characters need to be escaped so that they can be put into a\n  // string literal.\n  var escapes = {\n    \"'\":      \"'\",\n    '\\\\':     '\\\\',\n    '\\r':     'r',\n    '\\n':     'n',\n    '\\t':     't',\n    '\\u2028': 'u2028',\n    '\\u2029': 'u2029'\n  };\n\n  var escaper = /\\\\|'|\\r|\\n|\\t|\\u2028|\\u2029/g;\n\n  // JavaScript micro-templating, similar to John Resig's implementation.\n  // Underscore templating handles arbitrary delimiters, preserves whitespace,\n  // and correctly escapes quotes within interpolated code.\n  _.template = function(text, data, settings) {\n    var render;\n    settings = _.defaults({}, settings, _.templateSettings);\n\n    // Combine delimiters into one regular expression via alternation.\n    var matcher = new RegExp([\n      (settings.escape || noMatch).source,\n      (settings.interpolate || noMatch).source,\n      (settings.evaluate || noMatch).source\n    ].join('|') + '|$', 'g');\n\n    // Compile the template source, escaping string literals appropriately.\n    var index = 0;\n    var source = \"__p+='\";\n    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {\n      source += text.slice(index, offset)\n        .replace(escaper, function(match) { return '\\\\' + escapes[match]; });\n\n      if (escape) {\n        source += \"'+\\n((__t=(\" + escape + \"))==null?'':_.escape(__t))+\\n'\";\n      }\n      if (interpolate) {\n        source += \"'+\\n((__t=(\" + interpolate + \"))==null?'':__t)+\\n'\";\n      }\n      if (evaluate) {\n        source += \"';\\n\" + evaluate + \"\\n__p+='\";\n      }\n      index = offset + match.length;\n      return match;\n    });\n    source += \"';\\n\";\n\n    // If a variable is not specified, place data values in local scope.\n    if (!settings.variable) source = 'with(obj||{}){\\n' + source + '}\\n';\n\n    source = \"var __t,__p='',__j=Array.prototype.join,\" +\n      \"print=function(){__p+=__j.call(arguments,'');};\\n\" +\n      source + \"return __p;\\n\";\n\n    try {\n      render = new Function(settings.variable || 'obj', '_', source);\n    } catch (e) {\n      e.source = source;\n      throw e;\n    }\n\n    if (data) return render(data, _);\n    var template = function(data) {\n      return render.call(this, data, _);\n    };\n\n    // Provide the compiled function source as a convenience for precompilation.\n    template.source = 'function(' + (settings.variable || 'obj') + '){\\n' + source + '}';\n\n    return template;\n  };\n\n  // Add a \"chain\" function, which will delegate to the wrapper.\n  _.chain = function(obj) {\n    return _(obj).chain();\n  };\n\n  // OOP\n  // ---------------\n  // If Underscore is called as a function, it returns a wrapped object that\n  // can be used OO-style. This wrapper holds altered versions of all the\n  // underscore functions. Wrapped objects may be chained.\n\n  // Helper function to continue chaining intermediate results.\n  var result = function(obj) {\n    return this._chain ? _(obj).chain() : obj;\n  };\n\n  // Add all of the Underscore functions to the wrapper object.\n  _.mixin(_);\n\n  // Add all mutator Array functions to the wrapper.\n  each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {\n    var method = ArrayProto[name];\n    _.prototype[name] = function() {\n      var obj = this._wrapped;\n      method.apply(obj, arguments);\n      if ((name == 'shift' || name == 'splice') && obj.length === 0) delete obj[0];\n      return result.call(this, obj);\n    };\n  });\n\n  // Add all accessor Array functions to the wrapper.\n  each(['concat', 'join', 'slice'], function(name) {\n    var method = ArrayProto[name];\n    _.prototype[name] = function() {\n      return result.call(this, method.apply(this._wrapped, arguments));\n    };\n  });\n\n  _.extend(_.prototype, {\n\n    // Start chaining a wrapped Underscore object.\n    chain: function() {\n      this._chain = true;\n      return this;\n    },\n\n    // Extracts the result from a wrapped and chained object.\n    value: function() {\n      return this._wrapped;\n    }\n\n  });\n\n}).call(this);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91bmRlcnNjb3JlL3VuZGVyc2NvcmUuanM/YWRkMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyAgICAgVW5kZXJzY29yZS5qcyAxLjQuNFxuLy8gICAgIGh0dHA6Ly91bmRlcnNjb3JlanMub3JnXG4vLyAgICAgKGMpIDIwMDktMjAxMyBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgSW5jLlxuLy8gICAgIFVuZGVyc2NvcmUgbWF5IGJlIGZyZWVseSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG5cbihmdW5jdGlvbigpIHtcblxuICAvLyBCYXNlbGluZSBzZXR1cFxuICAvLyAtLS0tLS0tLS0tLS0tLVxuXG4gIC8vIEVzdGFibGlzaCB0aGUgcm9vdCBvYmplY3QsIGB3aW5kb3dgIGluIHRoZSBicm93c2VyLCBvciBgZ2xvYmFsYCBvbiB0aGUgc2VydmVyLlxuICB2YXIgcm9vdCA9IHRoaXM7XG5cbiAgLy8gU2F2ZSB0aGUgcHJldmlvdXMgdmFsdWUgb2YgdGhlIGBfYCB2YXJpYWJsZS5cbiAgdmFyIHByZXZpb3VzVW5kZXJzY29yZSA9IHJvb3QuXztcblxuICAvLyBFc3RhYmxpc2ggdGhlIG9iamVjdCB0aGF0IGdldHMgcmV0dXJuZWQgdG8gYnJlYWsgb3V0IG9mIGEgbG9vcCBpdGVyYXRpb24uXG4gIHZhciBicmVha2VyID0ge307XG5cbiAgLy8gU2F2ZSBieXRlcyBpbiB0aGUgbWluaWZpZWQgKGJ1dCBub3QgZ3ppcHBlZCkgdmVyc2lvbjpcbiAgdmFyIEFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGUsIE9ialByb3RvID0gT2JqZWN0LnByb3RvdHlwZSwgRnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlO1xuXG4gIC8vIENyZWF0ZSBxdWljayByZWZlcmVuY2UgdmFyaWFibGVzIGZvciBzcGVlZCBhY2Nlc3MgdG8gY29yZSBwcm90b3R5cGVzLlxuICB2YXIgcHVzaCAgICAgICAgICAgICA9IEFycmF5UHJvdG8ucHVzaCxcbiAgICAgIHNsaWNlICAgICAgICAgICAgPSBBcnJheVByb3RvLnNsaWNlLFxuICAgICAgY29uY2F0ICAgICAgICAgICA9IEFycmF5UHJvdG8uY29uY2F0LFxuICAgICAgdG9TdHJpbmcgICAgICAgICA9IE9ialByb3RvLnRvU3RyaW5nLFxuICAgICAgaGFzT3duUHJvcGVydHkgICA9IE9ialByb3RvLmhhc093blByb3BlcnR5O1xuXG4gIC8vIEFsbCAqKkVDTUFTY3JpcHQgNSoqIG5hdGl2ZSBmdW5jdGlvbiBpbXBsZW1lbnRhdGlvbnMgdGhhdCB3ZSBob3BlIHRvIHVzZVxuICAvLyBhcmUgZGVjbGFyZWQgaGVyZS5cbiAgdmFyXG4gICAgbmF0aXZlRm9yRWFjaCAgICAgID0gQXJyYXlQcm90by5mb3JFYWNoLFxuICAgIG5hdGl2ZU1hcCAgICAgICAgICA9IEFycmF5UHJvdG8ubWFwLFxuICAgIG5hdGl2ZVJlZHVjZSAgICAgICA9IEFycmF5UHJvdG8ucmVkdWNlLFxuICAgIG5hdGl2ZVJlZHVjZVJpZ2h0ICA9IEFycmF5UHJvdG8ucmVkdWNlUmlnaHQsXG4gICAgbmF0aXZlRmlsdGVyICAgICAgID0gQXJyYXlQcm90by5maWx0ZXIsXG4gICAgbmF0aXZlRXZlcnkgICAgICAgID0gQXJyYXlQcm90by5ldmVyeSxcbiAgICBuYXRpdmVTb21lICAgICAgICAgPSBBcnJheVByb3RvLnNvbWUsXG4gICAgbmF0aXZlSW5kZXhPZiAgICAgID0gQXJyYXlQcm90by5pbmRleE9mLFxuICAgIG5hdGl2ZUxhc3RJbmRleE9mICA9IEFycmF5UHJvdG8ubGFzdEluZGV4T2YsXG4gICAgbmF0aXZlSXNBcnJheSAgICAgID0gQXJyYXkuaXNBcnJheSxcbiAgICBuYXRpdmVLZXlzICAgICAgICAgPSBPYmplY3Qua2V5cyxcbiAgICBuYXRpdmVCaW5kICAgICAgICAgPSBGdW5jUHJvdG8uYmluZDtcblxuICAvLyBDcmVhdGUgYSBzYWZlIHJlZmVyZW5jZSB0byB0aGUgVW5kZXJzY29yZSBvYmplY3QgZm9yIHVzZSBiZWxvdy5cbiAgdmFyIF8gPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAob2JqIGluc3RhbmNlb2YgXykgcmV0dXJuIG9iajtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgXykpIHJldHVybiBuZXcgXyhvYmopO1xuICAgIHRoaXMuX3dyYXBwZWQgPSBvYmo7XG4gIH07XG5cbiAgLy8gRXhwb3J0IHRoZSBVbmRlcnNjb3JlIG9iamVjdCBmb3IgKipOb2RlLmpzKiosIHdpdGhcbiAgLy8gYmFja3dhcmRzLWNvbXBhdGliaWxpdHkgZm9yIHRoZSBvbGQgYHJlcXVpcmUoKWAgQVBJLiBJZiB3ZSdyZSBpblxuICAvLyB0aGUgYnJvd3NlciwgYWRkIGBfYCBhcyBhIGdsb2JhbCBvYmplY3QgdmlhIGEgc3RyaW5nIGlkZW50aWZpZXIsXG4gIC8vIGZvciBDbG9zdXJlIENvbXBpbGVyIFwiYWR2YW5jZWRcIiBtb2RlLlxuICBpZiAodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBfO1xuICAgIH1cbiAgICBleHBvcnRzLl8gPSBfO1xuICB9IGVsc2Uge1xuICAgIHJvb3QuXyA9IF87XG4gIH1cblxuICAvLyBDdXJyZW50IHZlcnNpb24uXG4gIF8uVkVSU0lPTiA9ICcxLjQuNCc7XG5cbiAgLy8gQ29sbGVjdGlvbiBGdW5jdGlvbnNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvLyBUaGUgY29ybmVyc3RvbmUsIGFuIGBlYWNoYCBpbXBsZW1lbnRhdGlvbiwgYWthIGBmb3JFYWNoYC5cbiAgLy8gSGFuZGxlcyBvYmplY3RzIHdpdGggdGhlIGJ1aWx0LWluIGBmb3JFYWNoYCwgYXJyYXlzLCBhbmQgcmF3IG9iamVjdHMuXG4gIC8vIERlbGVnYXRlcyB0byAqKkVDTUFTY3JpcHQgNSoqJ3MgbmF0aXZlIGBmb3JFYWNoYCBpZiBhdmFpbGFibGUuXG4gIHZhciBlYWNoID0gXy5lYWNoID0gXy5mb3JFYWNoID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRvciwgY29udGV4dCkge1xuICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuO1xuICAgIGlmIChuYXRpdmVGb3JFYWNoICYmIG9iai5mb3JFYWNoID09PSBuYXRpdmVGb3JFYWNoKSB7XG4gICAgICBvYmouZm9yRWFjaChpdGVyYXRvciwgY29udGV4dCk7XG4gICAgfSBlbHNlIGlmIChvYmoubGVuZ3RoID09PSArb2JqLmxlbmd0aCkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBvYmoubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGlmIChpdGVyYXRvci5jYWxsKGNvbnRleHQsIG9ialtpXSwgaSwgb2JqKSA9PT0gYnJlYWtlcikgcmV0dXJuO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgIGlmIChfLmhhcyhvYmosIGtleSkpIHtcbiAgICAgICAgICBpZiAoaXRlcmF0b3IuY2FsbChjb250ZXh0LCBvYmpba2V5XSwga2V5LCBvYmopID09PSBicmVha2VyKSByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLy8gUmV0dXJuIHRoZSByZXN1bHRzIG9mIGFwcGx5aW5nIHRoZSBpdGVyYXRvciB0byBlYWNoIGVsZW1lbnQuXG4gIC8vIERlbGVnYXRlcyB0byAqKkVDTUFTY3JpcHQgNSoqJ3MgbmF0aXZlIGBtYXBgIGlmIGF2YWlsYWJsZS5cbiAgXy5tYXAgPSBfLmNvbGxlY3QgPSBmdW5jdGlvbihvYmosIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiByZXN1bHRzO1xuICAgIGlmIChuYXRpdmVNYXAgJiYgb2JqLm1hcCA9PT0gbmF0aXZlTWFwKSByZXR1cm4gb2JqLm1hcChpdGVyYXRvciwgY29udGV4dCk7XG4gICAgZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgcmVzdWx0c1tyZXN1bHRzLmxlbmd0aF0gPSBpdGVyYXRvci5jYWxsKGNvbnRleHQsIHZhbHVlLCBpbmRleCwgbGlzdCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH07XG5cbiAgdmFyIHJlZHVjZUVycm9yID0gJ1JlZHVjZSBvZiBlbXB0eSBhcnJheSB3aXRoIG5vIGluaXRpYWwgdmFsdWUnO1xuXG4gIC8vICoqUmVkdWNlKiogYnVpbGRzIHVwIGEgc2luZ2xlIHJlc3VsdCBmcm9tIGEgbGlzdCBvZiB2YWx1ZXMsIGFrYSBgaW5qZWN0YCxcbiAgLy8gb3IgYGZvbGRsYC4gRGVsZWdhdGVzIHRvICoqRUNNQVNjcmlwdCA1KioncyBuYXRpdmUgYHJlZHVjZWAgaWYgYXZhaWxhYmxlLlxuICBfLnJlZHVjZSA9IF8uZm9sZGwgPSBfLmluamVjdCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0b3IsIG1lbW8sIGNvbnRleHQpIHtcbiAgICB2YXIgaW5pdGlhbCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyO1xuICAgIGlmIChvYmogPT0gbnVsbCkgb2JqID0gW107XG4gICAgaWYgKG5hdGl2ZVJlZHVjZSAmJiBvYmoucmVkdWNlID09PSBuYXRpdmVSZWR1Y2UpIHtcbiAgICAgIGlmIChjb250ZXh0KSBpdGVyYXRvciA9IF8uYmluZChpdGVyYXRvciwgY29udGV4dCk7XG4gICAgICByZXR1cm4gaW5pdGlhbCA/IG9iai5yZWR1Y2UoaXRlcmF0b3IsIG1lbW8pIDogb2JqLnJlZHVjZShpdGVyYXRvcik7XG4gICAgfVxuICAgIGVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgIGlmICghaW5pdGlhbCkge1xuICAgICAgICBtZW1vID0gdmFsdWU7XG4gICAgICAgIGluaXRpYWwgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWVtbyA9IGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgbWVtbywgdmFsdWUsIGluZGV4LCBsaXN0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoIWluaXRpYWwpIHRocm93IG5ldyBUeXBlRXJyb3IocmVkdWNlRXJyb3IpO1xuICAgIHJldHVybiBtZW1vO1xuICB9O1xuXG4gIC8vIFRoZSByaWdodC1hc3NvY2lhdGl2ZSB2ZXJzaW9uIG9mIHJlZHVjZSwgYWxzbyBrbm93biBhcyBgZm9sZHJgLlxuICAvLyBEZWxlZ2F0ZXMgdG8gKipFQ01BU2NyaXB0IDUqKidzIG5hdGl2ZSBgcmVkdWNlUmlnaHRgIGlmIGF2YWlsYWJsZS5cbiAgXy5yZWR1Y2VSaWdodCA9IF8uZm9sZHIgPSBmdW5jdGlvbihvYmosIGl0ZXJhdG9yLCBtZW1vLCBjb250ZXh0KSB7XG4gICAgdmFyIGluaXRpYWwgPSBhcmd1bWVudHMubGVuZ3RoID4gMjtcbiAgICBpZiAob2JqID09IG51bGwpIG9iaiA9IFtdO1xuICAgIGlmIChuYXRpdmVSZWR1Y2VSaWdodCAmJiBvYmoucmVkdWNlUmlnaHQgPT09IG5hdGl2ZVJlZHVjZVJpZ2h0KSB7XG4gICAgICBpZiAoY29udGV4dCkgaXRlcmF0b3IgPSBfLmJpbmQoaXRlcmF0b3IsIGNvbnRleHQpO1xuICAgICAgcmV0dXJuIGluaXRpYWwgPyBvYmoucmVkdWNlUmlnaHQoaXRlcmF0b3IsIG1lbW8pIDogb2JqLnJlZHVjZVJpZ2h0KGl0ZXJhdG9yKTtcbiAgICB9XG4gICAgdmFyIGxlbmd0aCA9IG9iai5sZW5ndGg7XG4gICAgaWYgKGxlbmd0aCAhPT0gK2xlbmd0aCkge1xuICAgICAgdmFyIGtleXMgPSBfLmtleXMob2JqKTtcbiAgICAgIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIH1cbiAgICBlYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgICBpbmRleCA9IGtleXMgPyBrZXlzWy0tbGVuZ3RoXSA6IC0tbGVuZ3RoO1xuICAgICAgaWYgKCFpbml0aWFsKSB7XG4gICAgICAgIG1lbW8gPSBvYmpbaW5kZXhdO1xuICAgICAgICBpbml0aWFsID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1lbW8gPSBpdGVyYXRvci5jYWxsKGNvbnRleHQsIG1lbW8sIG9ialtpbmRleF0sIGluZGV4LCBsaXN0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoIWluaXRpYWwpIHRocm93IG5ldyBUeXBlRXJyb3IocmVkdWNlRXJyb3IpO1xuICAgIHJldHVybiBtZW1vO1xuICB9O1xuXG4gIC8vIFJldHVybiB0aGUgZmlyc3QgdmFsdWUgd2hpY2ggcGFzc2VzIGEgdHJ1dGggdGVzdC4gQWxpYXNlZCBhcyBgZGV0ZWN0YC5cbiAgXy5maW5kID0gXy5kZXRlY3QgPSBmdW5jdGlvbihvYmosIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgdmFyIHJlc3VsdDtcbiAgICBhbnkob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgIGlmIChpdGVyYXRvci5jYWxsKGNvbnRleHQsIHZhbHVlLCBpbmRleCwgbGlzdCkpIHtcbiAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gUmV0dXJuIGFsbCB0aGUgZWxlbWVudHMgdGhhdCBwYXNzIGEgdHJ1dGggdGVzdC5cbiAgLy8gRGVsZWdhdGVzIHRvICoqRUNNQVNjcmlwdCA1KioncyBuYXRpdmUgYGZpbHRlcmAgaWYgYXZhaWxhYmxlLlxuICAvLyBBbGlhc2VkIGFzIGBzZWxlY3RgLlxuICBfLmZpbHRlciA9IF8uc2VsZWN0ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRvciwgY29udGV4dCkge1xuICAgIHZhciByZXN1bHRzID0gW107XG4gICAgaWYgKG9iaiA9PSBudWxsKSByZXR1cm4gcmVzdWx0cztcbiAgICBpZiAobmF0aXZlRmlsdGVyICYmIG9iai5maWx0ZXIgPT09IG5hdGl2ZUZpbHRlcikgcmV0dXJuIG9iai5maWx0ZXIoaXRlcmF0b3IsIGNvbnRleHQpO1xuICAgIGVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgIGlmIChpdGVyYXRvci5jYWxsKGNvbnRleHQsIHZhbHVlLCBpbmRleCwgbGlzdCkpIHJlc3VsdHNbcmVzdWx0cy5sZW5ndGhdID0gdmFsdWU7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH07XG5cbiAgLy8gUmV0dXJuIGFsbCB0aGUgZWxlbWVudHMgZm9yIHdoaWNoIGEgdHJ1dGggdGVzdCBmYWlscy5cbiAgXy5yZWplY3QgPSBmdW5jdGlvbihvYmosIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIF8uZmlsdGVyKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgICByZXR1cm4gIWl0ZXJhdG9yLmNhbGwoY29udGV4dCwgdmFsdWUsIGluZGV4LCBsaXN0KTtcbiAgICB9LCBjb250ZXh0KTtcbiAgfTtcblxuICAvLyBEZXRlcm1pbmUgd2hldGhlciBhbGwgb2YgdGhlIGVsZW1lbnRzIG1hdGNoIGEgdHJ1dGggdGVzdC5cbiAgLy8gRGVsZWdhdGVzIHRvICoqRUNNQVNjcmlwdCA1KioncyBuYXRpdmUgYGV2ZXJ5YCBpZiBhdmFpbGFibGUuXG4gIC8vIEFsaWFzZWQgYXMgYGFsbGAuXG4gIF8uZXZlcnkgPSBfLmFsbCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0b3IsIGNvbnRleHQpIHtcbiAgICBpdGVyYXRvciB8fCAoaXRlcmF0b3IgPSBfLmlkZW50aXR5KTtcbiAgICB2YXIgcmVzdWx0ID0gdHJ1ZTtcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiByZXN1bHQ7XG4gICAgaWYgKG5hdGl2ZUV2ZXJ5ICYmIG9iai5ldmVyeSA9PT0gbmF0aXZlRXZlcnkpIHJldHVybiBvYmouZXZlcnkoaXRlcmF0b3IsIGNvbnRleHQpO1xuICAgIGVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgIGlmICghKHJlc3VsdCA9IHJlc3VsdCAmJiBpdGVyYXRvci5jYWxsKGNvbnRleHQsIHZhbHVlLCBpbmRleCwgbGlzdCkpKSByZXR1cm4gYnJlYWtlcjtcbiAgICB9KTtcbiAgICByZXR1cm4gISFyZXN1bHQ7XG4gIH07XG5cbiAgLy8gRGV0ZXJtaW5lIGlmIGF0IGxlYXN0IG9uZSBlbGVtZW50IGluIHRoZSBvYmplY3QgbWF0Y2hlcyBhIHRydXRoIHRlc3QuXG4gIC8vIERlbGVnYXRlcyB0byAqKkVDTUFTY3JpcHQgNSoqJ3MgbmF0aXZlIGBzb21lYCBpZiBhdmFpbGFibGUuXG4gIC8vIEFsaWFzZWQgYXMgYGFueWAuXG4gIHZhciBhbnkgPSBfLnNvbWUgPSBfLmFueSA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0b3IsIGNvbnRleHQpIHtcbiAgICBpdGVyYXRvciB8fCAoaXRlcmF0b3IgPSBfLmlkZW50aXR5KTtcbiAgICB2YXIgcmVzdWx0ID0gZmFsc2U7XG4gICAgaWYgKG9iaiA9PSBudWxsKSByZXR1cm4gcmVzdWx0O1xuICAgIGlmIChuYXRpdmVTb21lICYmIG9iai5zb21lID09PSBuYXRpdmVTb21lKSByZXR1cm4gb2JqLnNvbWUoaXRlcmF0b3IsIGNvbnRleHQpO1xuICAgIGVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgIGlmIChyZXN1bHQgfHwgKHJlc3VsdCA9IGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgdmFsdWUsIGluZGV4LCBsaXN0KSkpIHJldHVybiBicmVha2VyO1xuICAgIH0pO1xuICAgIHJldHVybiAhIXJlc3VsdDtcbiAgfTtcblxuICAvLyBEZXRlcm1pbmUgaWYgdGhlIGFycmF5IG9yIG9iamVjdCBjb250YWlucyBhIGdpdmVuIHZhbHVlICh1c2luZyBgPT09YCkuXG4gIC8vIEFsaWFzZWQgYXMgYGluY2x1ZGVgLlxuICBfLmNvbnRhaW5zID0gXy5pbmNsdWRlID0gZnVuY3Rpb24ob2JqLCB0YXJnZXQpIHtcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiBmYWxzZTtcbiAgICBpZiAobmF0aXZlSW5kZXhPZiAmJiBvYmouaW5kZXhPZiA9PT0gbmF0aXZlSW5kZXhPZikgcmV0dXJuIG9iai5pbmRleE9mKHRhcmdldCkgIT0gLTE7XG4gICAgcmV0dXJuIGFueShvYmosIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IHRhcmdldDtcbiAgICB9KTtcbiAgfTtcblxuICAvLyBJbnZva2UgYSBtZXRob2QgKHdpdGggYXJndW1lbnRzKSBvbiBldmVyeSBpdGVtIGluIGEgY29sbGVjdGlvbi5cbiAgXy5pbnZva2UgPSBmdW5jdGlvbihvYmosIG1ldGhvZCkge1xuICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgIHZhciBpc0Z1bmMgPSBfLmlzRnVuY3Rpb24obWV0aG9kKTtcbiAgICByZXR1cm4gXy5tYXAob2JqLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIChpc0Z1bmMgPyBtZXRob2QgOiB2YWx1ZVttZXRob2RdKS5hcHBseSh2YWx1ZSwgYXJncyk7XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gQ29udmVuaWVuY2UgdmVyc2lvbiBvZiBhIGNvbW1vbiB1c2UgY2FzZSBvZiBgbWFwYDogZmV0Y2hpbmcgYSBwcm9wZXJ0eS5cbiAgXy5wbHVjayA9IGZ1bmN0aW9uKG9iaiwga2V5KSB7XG4gICAgcmV0dXJuIF8ubWFwKG9iaiwgZnVuY3Rpb24odmFsdWUpeyByZXR1cm4gdmFsdWVba2V5XTsgfSk7XG4gIH07XG5cbiAgLy8gQ29udmVuaWVuY2UgdmVyc2lvbiBvZiBhIGNvbW1vbiB1c2UgY2FzZSBvZiBgZmlsdGVyYDogc2VsZWN0aW5nIG9ubHkgb2JqZWN0c1xuICAvLyBjb250YWluaW5nIHNwZWNpZmljIGBrZXk6dmFsdWVgIHBhaXJzLlxuICBfLndoZXJlID0gZnVuY3Rpb24ob2JqLCBhdHRycywgZmlyc3QpIHtcbiAgICBpZiAoXy5pc0VtcHR5KGF0dHJzKSkgcmV0dXJuIGZpcnN0ID8gbnVsbCA6IFtdO1xuICAgIHJldHVybiBfW2ZpcnN0ID8gJ2ZpbmQnIDogJ2ZpbHRlciddKG9iaiwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIGZvciAodmFyIGtleSBpbiBhdHRycykge1xuICAgICAgICBpZiAoYXR0cnNba2V5XSAhPT0gdmFsdWVba2V5XSkgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gQ29udmVuaWVuY2UgdmVyc2lvbiBvZiBhIGNvbW1vbiB1c2UgY2FzZSBvZiBgZmluZGA6IGdldHRpbmcgdGhlIGZpcnN0IG9iamVjdFxuICAvLyBjb250YWluaW5nIHNwZWNpZmljIGBrZXk6dmFsdWVgIHBhaXJzLlxuICBfLmZpbmRXaGVyZSA9IGZ1bmN0aW9uKG9iaiwgYXR0cnMpIHtcbiAgICByZXR1cm4gXy53aGVyZShvYmosIGF0dHJzLCB0cnVlKTtcbiAgfTtcblxuICAvLyBSZXR1cm4gdGhlIG1heGltdW0gZWxlbWVudCBvciAoZWxlbWVudC1iYXNlZCBjb21wdXRhdGlvbikuXG4gIC8vIENhbid0IG9wdGltaXplIGFycmF5cyBvZiBpbnRlZ2VycyBsb25nZXIgdGhhbiA2NSw1MzUgZWxlbWVudHMuXG4gIC8vIFNlZTogaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTgwNzk3XG4gIF8ubWF4ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRvciwgY29udGV4dCkge1xuICAgIGlmICghaXRlcmF0b3IgJiYgXy5pc0FycmF5KG9iaikgJiYgb2JqWzBdID09PSArb2JqWzBdICYmIG9iai5sZW5ndGggPCA2NTUzNSkge1xuICAgICAgcmV0dXJuIE1hdGgubWF4LmFwcGx5KE1hdGgsIG9iaik7XG4gICAgfVxuICAgIGlmICghaXRlcmF0b3IgJiYgXy5pc0VtcHR5KG9iaikpIHJldHVybiAtSW5maW5pdHk7XG4gICAgdmFyIHJlc3VsdCA9IHtjb21wdXRlZCA6IC1JbmZpbml0eSwgdmFsdWU6IC1JbmZpbml0eX07XG4gICAgZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgdmFyIGNvbXB1dGVkID0gaXRlcmF0b3IgPyBpdGVyYXRvci5jYWxsKGNvbnRleHQsIHZhbHVlLCBpbmRleCwgbGlzdCkgOiB2YWx1ZTtcbiAgICAgIGNvbXB1dGVkID49IHJlc3VsdC5jb21wdXRlZCAmJiAocmVzdWx0ID0ge3ZhbHVlIDogdmFsdWUsIGNvbXB1dGVkIDogY29tcHV0ZWR9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0LnZhbHVlO1xuICB9O1xuXG4gIC8vIFJldHVybiB0aGUgbWluaW11bSBlbGVtZW50IChvciBlbGVtZW50LWJhc2VkIGNvbXB1dGF0aW9uKS5cbiAgXy5taW4gPSBmdW5jdGlvbihvYmosIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgaWYgKCFpdGVyYXRvciAmJiBfLmlzQXJyYXkob2JqKSAmJiBvYmpbMF0gPT09ICtvYmpbMF0gJiYgb2JqLmxlbmd0aCA8IDY1NTM1KSB7XG4gICAgICByZXR1cm4gTWF0aC5taW4uYXBwbHkoTWF0aCwgb2JqKTtcbiAgICB9XG4gICAgaWYgKCFpdGVyYXRvciAmJiBfLmlzRW1wdHkob2JqKSkgcmV0dXJuIEluZmluaXR5O1xuICAgIHZhciByZXN1bHQgPSB7Y29tcHV0ZWQgOiBJbmZpbml0eSwgdmFsdWU6IEluZmluaXR5fTtcbiAgICBlYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgICB2YXIgY29tcHV0ZWQgPSBpdGVyYXRvciA/IGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgdmFsdWUsIGluZGV4LCBsaXN0KSA6IHZhbHVlO1xuICAgICAgY29tcHV0ZWQgPCByZXN1bHQuY29tcHV0ZWQgJiYgKHJlc3VsdCA9IHt2YWx1ZSA6IHZhbHVlLCBjb21wdXRlZCA6IGNvbXB1dGVkfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdC52YWx1ZTtcbiAgfTtcblxuICAvLyBTaHVmZmxlIGFuIGFycmF5LlxuICBfLnNodWZmbGUgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgcmFuZDtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBzaHVmZmxlZCA9IFtdO1xuICAgIGVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmFuZCA9IF8ucmFuZG9tKGluZGV4KyspO1xuICAgICAgc2h1ZmZsZWRbaW5kZXggLSAxXSA9IHNodWZmbGVkW3JhbmRdO1xuICAgICAgc2h1ZmZsZWRbcmFuZF0gPSB2YWx1ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gc2h1ZmZsZWQ7XG4gIH07XG5cbiAgLy8gQW4gaW50ZXJuYWwgZnVuY3Rpb24gdG8gZ2VuZXJhdGUgbG9va3VwIGl0ZXJhdG9ycy5cbiAgdmFyIGxvb2t1cEl0ZXJhdG9yID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gXy5pc0Z1bmN0aW9uKHZhbHVlKSA/IHZhbHVlIDogZnVuY3Rpb24ob2JqKXsgcmV0dXJuIG9ialt2YWx1ZV07IH07XG4gIH07XG5cbiAgLy8gU29ydCB0aGUgb2JqZWN0J3MgdmFsdWVzIGJ5IGEgY3JpdGVyaW9uIHByb2R1Y2VkIGJ5IGFuIGl0ZXJhdG9yLlxuICBfLnNvcnRCeSA9IGZ1bmN0aW9uKG9iaiwgdmFsdWUsIGNvbnRleHQpIHtcbiAgICB2YXIgaXRlcmF0b3IgPSBsb29rdXBJdGVyYXRvcih2YWx1ZSk7XG4gICAgcmV0dXJuIF8ucGx1Y2soXy5tYXAob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlIDogdmFsdWUsXG4gICAgICAgIGluZGV4IDogaW5kZXgsXG4gICAgICAgIGNyaXRlcmlhIDogaXRlcmF0b3IuY2FsbChjb250ZXh0LCB2YWx1ZSwgaW5kZXgsIGxpc3QpXG4gICAgICB9O1xuICAgIH0pLnNvcnQoZnVuY3Rpb24obGVmdCwgcmlnaHQpIHtcbiAgICAgIHZhciBhID0gbGVmdC5jcml0ZXJpYTtcbiAgICAgIHZhciBiID0gcmlnaHQuY3JpdGVyaWE7XG4gICAgICBpZiAoYSAhPT0gYikge1xuICAgICAgICBpZiAoYSA+IGIgfHwgYSA9PT0gdm9pZCAwKSByZXR1cm4gMTtcbiAgICAgICAgaWYgKGEgPCBiIHx8IGIgPT09IHZvaWQgMCkgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxlZnQuaW5kZXggPCByaWdodC5pbmRleCA/IC0xIDogMTtcbiAgICB9KSwgJ3ZhbHVlJyk7XG4gIH07XG5cbiAgLy8gQW4gaW50ZXJuYWwgZnVuY3Rpb24gdXNlZCBmb3IgYWdncmVnYXRlIFwiZ3JvdXAgYnlcIiBvcGVyYXRpb25zLlxuICB2YXIgZ3JvdXAgPSBmdW5jdGlvbihvYmosIHZhbHVlLCBjb250ZXh0LCBiZWhhdmlvcikge1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICB2YXIgaXRlcmF0b3IgPSBsb29rdXBJdGVyYXRvcih2YWx1ZSB8fCBfLmlkZW50aXR5KTtcbiAgICBlYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4KSB7XG4gICAgICB2YXIga2V5ID0gaXRlcmF0b3IuY2FsbChjb250ZXh0LCB2YWx1ZSwgaW5kZXgsIG9iaik7XG4gICAgICBiZWhhdmlvcihyZXN1bHQsIGtleSwgdmFsdWUpO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gR3JvdXBzIHRoZSBvYmplY3QncyB2YWx1ZXMgYnkgYSBjcml0ZXJpb24uIFBhc3MgZWl0aGVyIGEgc3RyaW5nIGF0dHJpYnV0ZVxuICAvLyB0byBncm91cCBieSwgb3IgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIGNyaXRlcmlvbi5cbiAgXy5ncm91cEJ5ID0gZnVuY3Rpb24ob2JqLCB2YWx1ZSwgY29udGV4dCkge1xuICAgIHJldHVybiBncm91cChvYmosIHZhbHVlLCBjb250ZXh0LCBmdW5jdGlvbihyZXN1bHQsIGtleSwgdmFsdWUpIHtcbiAgICAgIChfLmhhcyhyZXN1bHQsIGtleSkgPyByZXN1bHRba2V5XSA6IChyZXN1bHRba2V5XSA9IFtdKSkucHVzaCh2YWx1ZSk7XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gQ291bnRzIGluc3RhbmNlcyBvZiBhbiBvYmplY3QgdGhhdCBncm91cCBieSBhIGNlcnRhaW4gY3JpdGVyaW9uLiBQYXNzXG4gIC8vIGVpdGhlciBhIHN0cmluZyBhdHRyaWJ1dGUgdG8gY291bnQgYnksIG9yIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZVxuICAvLyBjcml0ZXJpb24uXG4gIF8uY291bnRCeSA9IGZ1bmN0aW9uKG9iaiwgdmFsdWUsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gZ3JvdXAob2JqLCB2YWx1ZSwgY29udGV4dCwgZnVuY3Rpb24ocmVzdWx0LCBrZXkpIHtcbiAgICAgIGlmICghXy5oYXMocmVzdWx0LCBrZXkpKSByZXN1bHRba2V5XSA9IDA7XG4gICAgICByZXN1bHRba2V5XSsrO1xuICAgIH0pO1xuICB9O1xuXG4gIC8vIFVzZSBhIGNvbXBhcmF0b3IgZnVuY3Rpb24gdG8gZmlndXJlIG91dCB0aGUgc21hbGxlc3QgaW5kZXggYXQgd2hpY2hcbiAgLy8gYW4gb2JqZWN0IHNob3VsZCBiZSBpbnNlcnRlZCBzbyBhcyB0byBtYWludGFpbiBvcmRlci4gVXNlcyBiaW5hcnkgc2VhcmNoLlxuICBfLnNvcnRlZEluZGV4ID0gZnVuY3Rpb24oYXJyYXksIG9iaiwgaXRlcmF0b3IsIGNvbnRleHQpIHtcbiAgICBpdGVyYXRvciA9IGl0ZXJhdG9yID09IG51bGwgPyBfLmlkZW50aXR5IDogbG9va3VwSXRlcmF0b3IoaXRlcmF0b3IpO1xuICAgIHZhciB2YWx1ZSA9IGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgb2JqKTtcbiAgICB2YXIgbG93ID0gMCwgaGlnaCA9IGFycmF5Lmxlbmd0aDtcbiAgICB3aGlsZSAobG93IDwgaGlnaCkge1xuICAgICAgdmFyIG1pZCA9IChsb3cgKyBoaWdoKSA+Pj4gMTtcbiAgICAgIGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgYXJyYXlbbWlkXSkgPCB2YWx1ZSA/IGxvdyA9IG1pZCArIDEgOiBoaWdoID0gbWlkO1xuICAgIH1cbiAgICByZXR1cm4gbG93O1xuICB9O1xuXG4gIC8vIFNhZmVseSBjb252ZXJ0IGFueXRoaW5nIGl0ZXJhYmxlIGludG8gYSByZWFsLCBsaXZlIGFycmF5LlxuICBfLnRvQXJyYXkgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAoIW9iaikgcmV0dXJuIFtdO1xuICAgIGlmIChfLmlzQXJyYXkob2JqKSkgcmV0dXJuIHNsaWNlLmNhbGwob2JqKTtcbiAgICBpZiAob2JqLmxlbmd0aCA9PT0gK29iai5sZW5ndGgpIHJldHVybiBfLm1hcChvYmosIF8uaWRlbnRpdHkpO1xuICAgIHJldHVybiBfLnZhbHVlcyhvYmopO1xuICB9O1xuXG4gIC8vIFJldHVybiB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGluIGFuIG9iamVjdC5cbiAgXy5zaXplID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKG9iaiA9PSBudWxsKSByZXR1cm4gMDtcbiAgICByZXR1cm4gKG9iai5sZW5ndGggPT09ICtvYmoubGVuZ3RoKSA/IG9iai5sZW5ndGggOiBfLmtleXMob2JqKS5sZW5ndGg7XG4gIH07XG5cbiAgLy8gQXJyYXkgRnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIEdldCB0aGUgZmlyc3QgZWxlbWVudCBvZiBhbiBhcnJheS4gUGFzc2luZyAqKm4qKiB3aWxsIHJldHVybiB0aGUgZmlyc3QgTlxuICAvLyB2YWx1ZXMgaW4gdGhlIGFycmF5LiBBbGlhc2VkIGFzIGBoZWFkYCBhbmQgYHRha2VgLiBUaGUgKipndWFyZCoqIGNoZWNrXG4gIC8vIGFsbG93cyBpdCB0byB3b3JrIHdpdGggYF8ubWFwYC5cbiAgXy5maXJzdCA9IF8uaGVhZCA9IF8udGFrZSA9IGZ1bmN0aW9uKGFycmF5LCBuLCBndWFyZCkge1xuICAgIGlmIChhcnJheSA9PSBudWxsKSByZXR1cm4gdm9pZCAwO1xuICAgIHJldHVybiAobiAhPSBudWxsKSAmJiAhZ3VhcmQgPyBzbGljZS5jYWxsKGFycmF5LCAwLCBuKSA6IGFycmF5WzBdO1xuICB9O1xuXG4gIC8vIFJldHVybnMgZXZlcnl0aGluZyBidXQgdGhlIGxhc3QgZW50cnkgb2YgdGhlIGFycmF5LiBFc3BlY2lhbGx5IHVzZWZ1bCBvblxuICAvLyB0aGUgYXJndW1lbnRzIG9iamVjdC4gUGFzc2luZyAqKm4qKiB3aWxsIHJldHVybiBhbGwgdGhlIHZhbHVlcyBpblxuICAvLyB0aGUgYXJyYXksIGV4Y2x1ZGluZyB0aGUgbGFzdCBOLiBUaGUgKipndWFyZCoqIGNoZWNrIGFsbG93cyBpdCB0byB3b3JrIHdpdGhcbiAgLy8gYF8ubWFwYC5cbiAgXy5pbml0aWFsID0gZnVuY3Rpb24oYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgcmV0dXJuIHNsaWNlLmNhbGwoYXJyYXksIDAsIGFycmF5Lmxlbmd0aCAtICgobiA9PSBudWxsKSB8fCBndWFyZCA/IDEgOiBuKSk7XG4gIH07XG5cbiAgLy8gR2V0IHRoZSBsYXN0IGVsZW1lbnQgb2YgYW4gYXJyYXkuIFBhc3NpbmcgKipuKiogd2lsbCByZXR1cm4gdGhlIGxhc3QgTlxuICAvLyB2YWx1ZXMgaW4gdGhlIGFycmF5LiBUaGUgKipndWFyZCoqIGNoZWNrIGFsbG93cyBpdCB0byB3b3JrIHdpdGggYF8ubWFwYC5cbiAgXy5sYXN0ID0gZnVuY3Rpb24oYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgaWYgKGFycmF5ID09IG51bGwpIHJldHVybiB2b2lkIDA7XG4gICAgaWYgKChuICE9IG51bGwpICYmICFndWFyZCkge1xuICAgICAgcmV0dXJuIHNsaWNlLmNhbGwoYXJyYXksIE1hdGgubWF4KGFycmF5Lmxlbmd0aCAtIG4sIDApKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGFycmF5W2FycmF5Lmxlbmd0aCAtIDFdO1xuICAgIH1cbiAgfTtcblxuICAvLyBSZXR1cm5zIGV2ZXJ5dGhpbmcgYnV0IHRoZSBmaXJzdCBlbnRyeSBvZiB0aGUgYXJyYXkuIEFsaWFzZWQgYXMgYHRhaWxgIGFuZCBgZHJvcGAuXG4gIC8vIEVzcGVjaWFsbHkgdXNlZnVsIG9uIHRoZSBhcmd1bWVudHMgb2JqZWN0LiBQYXNzaW5nIGFuICoqbioqIHdpbGwgcmV0dXJuXG4gIC8vIHRoZSByZXN0IE4gdmFsdWVzIGluIHRoZSBhcnJheS4gVGhlICoqZ3VhcmQqKlxuICAvLyBjaGVjayBhbGxvd3MgaXQgdG8gd29yayB3aXRoIGBfLm1hcGAuXG4gIF8ucmVzdCA9IF8udGFpbCA9IF8uZHJvcCA9IGZ1bmN0aW9uKGFycmF5LCBuLCBndWFyZCkge1xuICAgIHJldHVybiBzbGljZS5jYWxsKGFycmF5LCAobiA9PSBudWxsKSB8fCBndWFyZCA/IDEgOiBuKTtcbiAgfTtcblxuICAvLyBUcmltIG91dCBhbGwgZmFsc3kgdmFsdWVzIGZyb20gYW4gYXJyYXkuXG4gIF8uY29tcGFjdCA9IGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgcmV0dXJuIF8uZmlsdGVyKGFycmF5LCBfLmlkZW50aXR5KTtcbiAgfTtcblxuICAvLyBJbnRlcm5hbCBpbXBsZW1lbnRhdGlvbiBvZiBhIHJlY3Vyc2l2ZSBgZmxhdHRlbmAgZnVuY3Rpb24uXG4gIHZhciBmbGF0dGVuID0gZnVuY3Rpb24oaW5wdXQsIHNoYWxsb3csIG91dHB1dCkge1xuICAgIGVhY2goaW5wdXQsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICBpZiAoXy5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICBzaGFsbG93ID8gcHVzaC5hcHBseShvdXRwdXQsIHZhbHVlKSA6IGZsYXR0ZW4odmFsdWUsIHNoYWxsb3csIG91dHB1dCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdXRwdXQucHVzaCh2YWx1ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfTtcblxuICAvLyBSZXR1cm4gYSBjb21wbGV0ZWx5IGZsYXR0ZW5lZCB2ZXJzaW9uIG9mIGFuIGFycmF5LlxuICBfLmZsYXR0ZW4gPSBmdW5jdGlvbihhcnJheSwgc2hhbGxvdykge1xuICAgIHJldHVybiBmbGF0dGVuKGFycmF5LCBzaGFsbG93LCBbXSk7XG4gIH07XG5cbiAgLy8gUmV0dXJuIGEgdmVyc2lvbiBvZiB0aGUgYXJyYXkgdGhhdCBkb2VzIG5vdCBjb250YWluIHRoZSBzcGVjaWZpZWQgdmFsdWUocykuXG4gIF8ud2l0aG91dCA9IGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgcmV0dXJuIF8uZGlmZmVyZW5jZShhcnJheSwgc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcbiAgfTtcblxuICAvLyBQcm9kdWNlIGEgZHVwbGljYXRlLWZyZWUgdmVyc2lvbiBvZiB0aGUgYXJyYXkuIElmIHRoZSBhcnJheSBoYXMgYWxyZWFkeVxuICAvLyBiZWVuIHNvcnRlZCwgeW91IGhhdmUgdGhlIG9wdGlvbiBvZiB1c2luZyBhIGZhc3RlciBhbGdvcml0aG0uXG4gIC8vIEFsaWFzZWQgYXMgYHVuaXF1ZWAuXG4gIF8udW5pcSA9IF8udW5pcXVlID0gZnVuY3Rpb24oYXJyYXksIGlzU29ydGVkLCBpdGVyYXRvciwgY29udGV4dCkge1xuICAgIGlmIChfLmlzRnVuY3Rpb24oaXNTb3J0ZWQpKSB7XG4gICAgICBjb250ZXh0ID0gaXRlcmF0b3I7XG4gICAgICBpdGVyYXRvciA9IGlzU29ydGVkO1xuICAgICAgaXNTb3J0ZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgdmFyIGluaXRpYWwgPSBpdGVyYXRvciA/IF8ubWFwKGFycmF5LCBpdGVyYXRvciwgY29udGV4dCkgOiBhcnJheTtcbiAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgIHZhciBzZWVuID0gW107XG4gICAgZWFjaChpbml0aWFsLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgpIHtcbiAgICAgIGlmIChpc1NvcnRlZCA/ICghaW5kZXggfHwgc2VlbltzZWVuLmxlbmd0aCAtIDFdICE9PSB2YWx1ZSkgOiAhXy5jb250YWlucyhzZWVuLCB2YWx1ZSkpIHtcbiAgICAgICAgc2Vlbi5wdXNoKHZhbHVlKTtcbiAgICAgICAgcmVzdWx0cy5wdXNoKGFycmF5W2luZGV4XSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH07XG5cbiAgLy8gUHJvZHVjZSBhbiBhcnJheSB0aGF0IGNvbnRhaW5zIHRoZSB1bmlvbjogZWFjaCBkaXN0aW5jdCBlbGVtZW50IGZyb20gYWxsIG9mXG4gIC8vIHRoZSBwYXNzZWQtaW4gYXJyYXlzLlxuICBfLnVuaW9uID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIF8udW5pcShjb25jYXQuYXBwbHkoQXJyYXlQcm90bywgYXJndW1lbnRzKSk7XG4gIH07XG5cbiAgLy8gUHJvZHVjZSBhbiBhcnJheSB0aGF0IGNvbnRhaW5zIGV2ZXJ5IGl0ZW0gc2hhcmVkIGJldHdlZW4gYWxsIHRoZVxuICAvLyBwYXNzZWQtaW4gYXJyYXlzLlxuICBfLmludGVyc2VjdGlvbiA9IGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgdmFyIHJlc3QgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgcmV0dXJuIF8uZmlsdGVyKF8udW5pcShhcnJheSksIGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgIHJldHVybiBfLmV2ZXJ5KHJlc3QsIGZ1bmN0aW9uKG90aGVyKSB7XG4gICAgICAgIHJldHVybiBfLmluZGV4T2Yob3RoZXIsIGl0ZW0pID49IDA7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICAvLyBUYWtlIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gb25lIGFycmF5IGFuZCBhIG51bWJlciBvZiBvdGhlciBhcnJheXMuXG4gIC8vIE9ubHkgdGhlIGVsZW1lbnRzIHByZXNlbnQgaW4ganVzdCB0aGUgZmlyc3QgYXJyYXkgd2lsbCByZW1haW4uXG4gIF8uZGlmZmVyZW5jZSA9IGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgdmFyIHJlc3QgPSBjb25jYXQuYXBwbHkoQXJyYXlQcm90bywgc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcbiAgICByZXR1cm4gXy5maWx0ZXIoYXJyYXksIGZ1bmN0aW9uKHZhbHVlKXsgcmV0dXJuICFfLmNvbnRhaW5zKHJlc3QsIHZhbHVlKTsgfSk7XG4gIH07XG5cbiAgLy8gWmlwIHRvZ2V0aGVyIG11bHRpcGxlIGxpc3RzIGludG8gYSBzaW5nbGUgYXJyYXkgLS0gZWxlbWVudHMgdGhhdCBzaGFyZVxuICAvLyBhbiBpbmRleCBnbyB0b2dldGhlci5cbiAgXy56aXAgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICB2YXIgbGVuZ3RoID0gXy5tYXgoXy5wbHVjayhhcmdzLCAnbGVuZ3RoJykpO1xuICAgIHZhciByZXN1bHRzID0gbmV3IEFycmF5KGxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgcmVzdWx0c1tpXSA9IF8ucGx1Y2soYXJncywgXCJcIiArIGkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfTtcblxuICAvLyBDb252ZXJ0cyBsaXN0cyBpbnRvIG9iamVjdHMuIFBhc3MgZWl0aGVyIGEgc2luZ2xlIGFycmF5IG9mIGBba2V5LCB2YWx1ZV1gXG4gIC8vIHBhaXJzLCBvciB0d28gcGFyYWxsZWwgYXJyYXlzIG9mIHRoZSBzYW1lIGxlbmd0aCAtLSBvbmUgb2Yga2V5cywgYW5kIG9uZSBvZlxuICAvLyB0aGUgY29ycmVzcG9uZGluZyB2YWx1ZXMuXG4gIF8ub2JqZWN0ID0gZnVuY3Rpb24obGlzdCwgdmFsdWVzKSB7XG4gICAgaWYgKGxpc3QgPT0gbnVsbCkgcmV0dXJuIHt9O1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGxpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBpZiAodmFsdWVzKSB7XG4gICAgICAgIHJlc3VsdFtsaXN0W2ldXSA9IHZhbHVlc1tpXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdFtsaXN0W2ldWzBdXSA9IGxpc3RbaV1bMV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gSWYgdGhlIGJyb3dzZXIgZG9lc24ndCBzdXBwbHkgdXMgd2l0aCBpbmRleE9mIChJJ20gbG9va2luZyBhdCB5b3UsICoqTVNJRSoqKSxcbiAgLy8gd2UgbmVlZCB0aGlzIGZ1bmN0aW9uLiBSZXR1cm4gdGhlIHBvc2l0aW9uIG9mIHRoZSBmaXJzdCBvY2N1cnJlbmNlIG9mIGFuXG4gIC8vIGl0ZW0gaW4gYW4gYXJyYXksIG9yIC0xIGlmIHRoZSBpdGVtIGlzIG5vdCBpbmNsdWRlZCBpbiB0aGUgYXJyYXkuXG4gIC8vIERlbGVnYXRlcyB0byAqKkVDTUFTY3JpcHQgNSoqJ3MgbmF0aXZlIGBpbmRleE9mYCBpZiBhdmFpbGFibGUuXG4gIC8vIElmIHRoZSBhcnJheSBpcyBsYXJnZSBhbmQgYWxyZWFkeSBpbiBzb3J0IG9yZGVyLCBwYXNzIGB0cnVlYFxuICAvLyBmb3IgKippc1NvcnRlZCoqIHRvIHVzZSBiaW5hcnkgc2VhcmNoLlxuICBfLmluZGV4T2YgPSBmdW5jdGlvbihhcnJheSwgaXRlbSwgaXNTb3J0ZWQpIHtcbiAgICBpZiAoYXJyYXkgPT0gbnVsbCkgcmV0dXJuIC0xO1xuICAgIHZhciBpID0gMCwgbCA9IGFycmF5Lmxlbmd0aDtcbiAgICBpZiAoaXNTb3J0ZWQpIHtcbiAgICAgIGlmICh0eXBlb2YgaXNTb3J0ZWQgPT0gJ251bWJlcicpIHtcbiAgICAgICAgaSA9IChpc1NvcnRlZCA8IDAgPyBNYXRoLm1heCgwLCBsICsgaXNTb3J0ZWQpIDogaXNTb3J0ZWQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaSA9IF8uc29ydGVkSW5kZXgoYXJyYXksIGl0ZW0pO1xuICAgICAgICByZXR1cm4gYXJyYXlbaV0gPT09IGl0ZW0gPyBpIDogLTE7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChuYXRpdmVJbmRleE9mICYmIGFycmF5LmluZGV4T2YgPT09IG5hdGl2ZUluZGV4T2YpIHJldHVybiBhcnJheS5pbmRleE9mKGl0ZW0sIGlzU29ydGVkKTtcbiAgICBmb3IgKDsgaSA8IGw7IGkrKykgaWYgKGFycmF5W2ldID09PSBpdGVtKSByZXR1cm4gaTtcbiAgICByZXR1cm4gLTE7XG4gIH07XG5cbiAgLy8gRGVsZWdhdGVzIHRvICoqRUNNQVNjcmlwdCA1KioncyBuYXRpdmUgYGxhc3RJbmRleE9mYCBpZiBhdmFpbGFibGUuXG4gIF8ubGFzdEluZGV4T2YgPSBmdW5jdGlvbihhcnJheSwgaXRlbSwgZnJvbSkge1xuICAgIGlmIChhcnJheSA9PSBudWxsKSByZXR1cm4gLTE7XG4gICAgdmFyIGhhc0luZGV4ID0gZnJvbSAhPSBudWxsO1xuICAgIGlmIChuYXRpdmVMYXN0SW5kZXhPZiAmJiBhcnJheS5sYXN0SW5kZXhPZiA9PT0gbmF0aXZlTGFzdEluZGV4T2YpIHtcbiAgICAgIHJldHVybiBoYXNJbmRleCA/IGFycmF5Lmxhc3RJbmRleE9mKGl0ZW0sIGZyb20pIDogYXJyYXkubGFzdEluZGV4T2YoaXRlbSk7XG4gICAgfVxuICAgIHZhciBpID0gKGhhc0luZGV4ID8gZnJvbSA6IGFycmF5Lmxlbmd0aCk7XG4gICAgd2hpbGUgKGktLSkgaWYgKGFycmF5W2ldID09PSBpdGVtKSByZXR1cm4gaTtcbiAgICByZXR1cm4gLTE7XG4gIH07XG5cbiAgLy8gR2VuZXJhdGUgYW4gaW50ZWdlciBBcnJheSBjb250YWluaW5nIGFuIGFyaXRobWV0aWMgcHJvZ3Jlc3Npb24uIEEgcG9ydCBvZlxuICAvLyB0aGUgbmF0aXZlIFB5dGhvbiBgcmFuZ2UoKWAgZnVuY3Rpb24uIFNlZVxuICAvLyBbdGhlIFB5dGhvbiBkb2N1bWVudGF0aW9uXShodHRwOi8vZG9jcy5weXRob24ub3JnL2xpYnJhcnkvZnVuY3Rpb25zLmh0bWwjcmFuZ2UpLlxuICBfLnJhbmdlID0gZnVuY3Rpb24oc3RhcnQsIHN0b3AsIHN0ZXApIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8PSAxKSB7XG4gICAgICBzdG9wID0gc3RhcnQgfHwgMDtcbiAgICAgIHN0YXJ0ID0gMDtcbiAgICB9XG4gICAgc3RlcCA9IGFyZ3VtZW50c1syXSB8fCAxO1xuXG4gICAgdmFyIGxlbiA9IE1hdGgubWF4KE1hdGguY2VpbCgoc3RvcCAtIHN0YXJ0KSAvIHN0ZXApLCAwKTtcbiAgICB2YXIgaWR4ID0gMDtcbiAgICB2YXIgcmFuZ2UgPSBuZXcgQXJyYXkobGVuKTtcblxuICAgIHdoaWxlKGlkeCA8IGxlbikge1xuICAgICAgcmFuZ2VbaWR4KytdID0gc3RhcnQ7XG4gICAgICBzdGFydCArPSBzdGVwO1xuICAgIH1cblxuICAgIHJldHVybiByYW5nZTtcbiAgfTtcblxuICAvLyBGdW5jdGlvbiAoYWhlbSkgRnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIENyZWF0ZSBhIGZ1bmN0aW9uIGJvdW5kIHRvIGEgZ2l2ZW4gb2JqZWN0IChhc3NpZ25pbmcgYHRoaXNgLCBhbmQgYXJndW1lbnRzLFxuICAvLyBvcHRpb25hbGx5KS4gRGVsZWdhdGVzIHRvICoqRUNNQVNjcmlwdCA1KioncyBuYXRpdmUgYEZ1bmN0aW9uLmJpbmRgIGlmXG4gIC8vIGF2YWlsYWJsZS5cbiAgXy5iaW5kID0gZnVuY3Rpb24oZnVuYywgY29udGV4dCkge1xuICAgIGlmIChmdW5jLmJpbmQgPT09IG5hdGl2ZUJpbmQgJiYgbmF0aXZlQmluZCkgcmV0dXJuIG5hdGl2ZUJpbmQuYXBwbHkoZnVuYywgc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcbiAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcbiAgICB9O1xuICB9O1xuXG4gIC8vIFBhcnRpYWxseSBhcHBseSBhIGZ1bmN0aW9uIGJ5IGNyZWF0aW5nIGEgdmVyc2lvbiB0aGF0IGhhcyBoYWQgc29tZSBvZiBpdHNcbiAgLy8gYXJndW1lbnRzIHByZS1maWxsZWQsIHdpdGhvdXQgY2hhbmdpbmcgaXRzIGR5bmFtaWMgYHRoaXNgIGNvbnRleHQuXG4gIF8ucGFydGlhbCA9IGZ1bmN0aW9uKGZ1bmMpIHtcbiAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzLCBhcmdzLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcbiAgICB9O1xuICB9O1xuXG4gIC8vIEJpbmQgYWxsIG9mIGFuIG9iamVjdCdzIG1ldGhvZHMgdG8gdGhhdCBvYmplY3QuIFVzZWZ1bCBmb3IgZW5zdXJpbmcgdGhhdFxuICAvLyBhbGwgY2FsbGJhY2tzIGRlZmluZWQgb24gYW4gb2JqZWN0IGJlbG9uZyB0byBpdC5cbiAgXy5iaW5kQWxsID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIGZ1bmNzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgIGlmIChmdW5jcy5sZW5ndGggPT09IDApIGZ1bmNzID0gXy5mdW5jdGlvbnMob2JqKTtcbiAgICBlYWNoKGZ1bmNzLCBmdW5jdGlvbihmKSB7IG9ialtmXSA9IF8uYmluZChvYmpbZl0sIG9iaik7IH0pO1xuICAgIHJldHVybiBvYmo7XG4gIH07XG5cbiAgLy8gTWVtb2l6ZSBhbiBleHBlbnNpdmUgZnVuY3Rpb24gYnkgc3RvcmluZyBpdHMgcmVzdWx0cy5cbiAgXy5tZW1vaXplID0gZnVuY3Rpb24oZnVuYywgaGFzaGVyKSB7XG4gICAgdmFyIG1lbW8gPSB7fTtcbiAgICBoYXNoZXIgfHwgKGhhc2hlciA9IF8uaWRlbnRpdHkpO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBrZXkgPSBoYXNoZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiBfLmhhcyhtZW1vLCBrZXkpID8gbWVtb1trZXldIDogKG1lbW9ba2V5XSA9IGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgfTtcbiAgfTtcblxuICAvLyBEZWxheXMgYSBmdW5jdGlvbiBmb3IgdGhlIGdpdmVuIG51bWJlciBvZiBtaWxsaXNlY29uZHMsIGFuZCB0aGVuIGNhbGxzXG4gIC8vIGl0IHdpdGggdGhlIGFyZ3VtZW50cyBzdXBwbGllZC5cbiAgXy5kZWxheSA9IGZ1bmN0aW9uKGZ1bmMsIHdhaXQpIHtcbiAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcbiAgICByZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbigpeyByZXR1cm4gZnVuYy5hcHBseShudWxsLCBhcmdzKTsgfSwgd2FpdCk7XG4gIH07XG5cbiAgLy8gRGVmZXJzIGEgZnVuY3Rpb24sIHNjaGVkdWxpbmcgaXQgdG8gcnVuIGFmdGVyIHRoZSBjdXJyZW50IGNhbGwgc3RhY2sgaGFzXG4gIC8vIGNsZWFyZWQuXG4gIF8uZGVmZXIgPSBmdW5jdGlvbihmdW5jKSB7XG4gICAgcmV0dXJuIF8uZGVsYXkuYXBwbHkoXywgW2Z1bmMsIDFdLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpKTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24sIHRoYXQsIHdoZW4gaW52b2tlZCwgd2lsbCBvbmx5IGJlIHRyaWdnZXJlZCBhdCBtb3N0IG9uY2VcbiAgLy8gZHVyaW5nIGEgZ2l2ZW4gd2luZG93IG9mIHRpbWUuXG4gIF8udGhyb3R0bGUgPSBmdW5jdGlvbihmdW5jLCB3YWl0KSB7XG4gICAgdmFyIGNvbnRleHQsIGFyZ3MsIHRpbWVvdXQsIHJlc3VsdDtcbiAgICB2YXIgcHJldmlvdXMgPSAwO1xuICAgIHZhciBsYXRlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgcHJldmlvdXMgPSBuZXcgRGF0ZTtcbiAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBub3cgPSBuZXcgRGF0ZTtcbiAgICAgIHZhciByZW1haW5pbmcgPSB3YWl0IC0gKG5vdyAtIHByZXZpb3VzKTtcbiAgICAgIGNvbnRleHQgPSB0aGlzO1xuICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgIGlmIChyZW1haW5pbmcgPD0gMCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICBwcmV2aW91cyA9IG5vdztcbiAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgIH0gZWxzZSBpZiAoIXRpbWVvdXQpIHtcbiAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHJlbWFpbmluZyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uLCB0aGF0LCBhcyBsb25nIGFzIGl0IGNvbnRpbnVlcyB0byBiZSBpbnZva2VkLCB3aWxsIG5vdFxuICAvLyBiZSB0cmlnZ2VyZWQuIFRoZSBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCBhZnRlciBpdCBzdG9wcyBiZWluZyBjYWxsZWQgZm9yXG4gIC8vIE4gbWlsbGlzZWNvbmRzLiBJZiBgaW1tZWRpYXRlYCBpcyBwYXNzZWQsIHRyaWdnZXIgdGhlIGZ1bmN0aW9uIG9uIHRoZVxuICAvLyBsZWFkaW5nIGVkZ2UsIGluc3RlYWQgb2YgdGhlIHRyYWlsaW5nLlxuICBfLmRlYm91bmNlID0gZnVuY3Rpb24oZnVuYywgd2FpdCwgaW1tZWRpYXRlKSB7XG4gICAgdmFyIHRpbWVvdXQsIHJlc3VsdDtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY29udGV4dCA9IHRoaXMsIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICB2YXIgbGF0ZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICAgIGlmICghaW1tZWRpYXRlKSByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgfTtcbiAgICAgIHZhciBjYWxsTm93ID0gaW1tZWRpYXRlICYmICF0aW1lb3V0O1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHdhaXQpO1xuICAgICAgaWYgKGNhbGxOb3cpIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBleGVjdXRlZCBhdCBtb3N0IG9uZSB0aW1lLCBubyBtYXR0ZXIgaG93XG4gIC8vIG9mdGVuIHlvdSBjYWxsIGl0LiBVc2VmdWwgZm9yIGxhenkgaW5pdGlhbGl6YXRpb24uXG4gIF8ub25jZSA9IGZ1bmN0aW9uKGZ1bmMpIHtcbiAgICB2YXIgcmFuID0gZmFsc2UsIG1lbW87XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHJhbikgcmV0dXJuIG1lbW87XG4gICAgICByYW4gPSB0cnVlO1xuICAgICAgbWVtbyA9IGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIGZ1bmMgPSBudWxsO1xuICAgICAgcmV0dXJuIG1lbW87XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIHRoZSBmaXJzdCBmdW5jdGlvbiBwYXNzZWQgYXMgYW4gYXJndW1lbnQgdG8gdGhlIHNlY29uZCxcbiAgLy8gYWxsb3dpbmcgeW91IHRvIGFkanVzdCBhcmd1bWVudHMsIHJ1biBjb2RlIGJlZm9yZSBhbmQgYWZ0ZXIsIGFuZFxuICAvLyBjb25kaXRpb25hbGx5IGV4ZWN1dGUgdGhlIG9yaWdpbmFsIGZ1bmN0aW9uLlxuICBfLndyYXAgPSBmdW5jdGlvbihmdW5jLCB3cmFwcGVyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGFyZ3MgPSBbZnVuY107XG4gICAgICBwdXNoLmFwcGx5KGFyZ3MsIGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gd3JhcHBlci5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGlzIHRoZSBjb21wb3NpdGlvbiBvZiBhIGxpc3Qgb2YgZnVuY3Rpb25zLCBlYWNoXG4gIC8vIGNvbnN1bWluZyB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBmdW5jdGlvbiB0aGF0IGZvbGxvd3MuXG4gIF8uY29tcG9zZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBmdW5jcyA9IGFyZ3VtZW50cztcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgIGZvciAodmFyIGkgPSBmdW5jcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBhcmdzID0gW2Z1bmNzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcmdzWzBdO1xuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBvbmx5IGJlIGV4ZWN1dGVkIGFmdGVyIGJlaW5nIGNhbGxlZCBOIHRpbWVzLlxuICBfLmFmdGVyID0gZnVuY3Rpb24odGltZXMsIGZ1bmMpIHtcbiAgICBpZiAodGltZXMgPD0gMCkgcmV0dXJuIGZ1bmMoKTtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoLS10aW1lcyA8IDEpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuXG4gIC8vIE9iamVjdCBGdW5jdGlvbnNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIFJldHJpZXZlIHRoZSBuYW1lcyBvZiBhbiBvYmplY3QncyBwcm9wZXJ0aWVzLlxuICAvLyBEZWxlZ2F0ZXMgdG8gKipFQ01BU2NyaXB0IDUqKidzIG5hdGl2ZSBgT2JqZWN0LmtleXNgXG4gIF8ua2V5cyA9IG5hdGl2ZUtleXMgfHwgZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKG9iaiAhPT0gT2JqZWN0KG9iaikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgb2JqZWN0Jyk7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSBpZiAoXy5oYXMob2JqLCBrZXkpKSBrZXlzW2tleXMubGVuZ3RoXSA9IGtleTtcbiAgICByZXR1cm4ga2V5cztcbiAgfTtcblxuICAvLyBSZXRyaWV2ZSB0aGUgdmFsdWVzIG9mIGFuIG9iamVjdCdzIHByb3BlcnRpZXMuXG4gIF8udmFsdWVzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIHZhbHVlcyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIGlmIChfLmhhcyhvYmosIGtleSkpIHZhbHVlcy5wdXNoKG9ialtrZXldKTtcbiAgICByZXR1cm4gdmFsdWVzO1xuICB9O1xuXG4gIC8vIENvbnZlcnQgYW4gb2JqZWN0IGludG8gYSBsaXN0IG9mIGBba2V5LCB2YWx1ZV1gIHBhaXJzLlxuICBfLnBhaXJzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIHBhaXJzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikgaWYgKF8uaGFzKG9iaiwga2V5KSkgcGFpcnMucHVzaChba2V5LCBvYmpba2V5XV0pO1xuICAgIHJldHVybiBwYWlycztcbiAgfTtcblxuICAvLyBJbnZlcnQgdGhlIGtleXMgYW5kIHZhbHVlcyBvZiBhbiBvYmplY3QuIFRoZSB2YWx1ZXMgbXVzdCBiZSBzZXJpYWxpemFibGUuXG4gIF8uaW52ZXJ0ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIGlmIChfLmhhcyhvYmosIGtleSkpIHJlc3VsdFtvYmpba2V5XV0gPSBrZXk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBSZXR1cm4gYSBzb3J0ZWQgbGlzdCBvZiB0aGUgZnVuY3Rpb24gbmFtZXMgYXZhaWxhYmxlIG9uIHRoZSBvYmplY3QuXG4gIC8vIEFsaWFzZWQgYXMgYG1ldGhvZHNgXG4gIF8uZnVuY3Rpb25zID0gXy5tZXRob2RzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIG5hbWVzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgaWYgKF8uaXNGdW5jdGlvbihvYmpba2V5XSkpIG5hbWVzLnB1c2goa2V5KTtcbiAgICB9XG4gICAgcmV0dXJuIG5hbWVzLnNvcnQoKTtcbiAgfTtcblxuICAvLyBFeHRlbmQgYSBnaXZlbiBvYmplY3Qgd2l0aCBhbGwgdGhlIHByb3BlcnRpZXMgaW4gcGFzc2VkLWluIG9iamVjdChzKS5cbiAgXy5leHRlbmQgPSBmdW5jdGlvbihvYmopIHtcbiAgICBlYWNoKHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSwgZnVuY3Rpb24oc291cmNlKSB7XG4gICAgICBpZiAoc291cmNlKSB7XG4gICAgICAgIGZvciAodmFyIHByb3AgaW4gc291cmNlKSB7XG4gICAgICAgICAgb2JqW3Byb3BdID0gc291cmNlW3Byb3BdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcblxuICAvLyBSZXR1cm4gYSBjb3B5IG9mIHRoZSBvYmplY3Qgb25seSBjb250YWluaW5nIHRoZSB3aGl0ZWxpc3RlZCBwcm9wZXJ0aWVzLlxuICBfLnBpY2sgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgY29weSA9IHt9O1xuICAgIHZhciBrZXlzID0gY29uY2F0LmFwcGx5KEFycmF5UHJvdG8sIHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XG4gICAgZWFjaChrZXlzLCBmdW5jdGlvbihrZXkpIHtcbiAgICAgIGlmIChrZXkgaW4gb2JqKSBjb3B5W2tleV0gPSBvYmpba2V5XTtcbiAgICB9KTtcbiAgICByZXR1cm4gY29weTtcbiAgfTtcblxuICAgLy8gUmV0dXJuIGEgY29weSBvZiB0aGUgb2JqZWN0IHdpdGhvdXQgdGhlIGJsYWNrbGlzdGVkIHByb3BlcnRpZXMuXG4gIF8ub21pdCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBjb3B5ID0ge307XG4gICAgdmFyIGtleXMgPSBjb25jYXQuYXBwbHkoQXJyYXlQcm90bywgc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICBpZiAoIV8uY29udGFpbnMoa2V5cywga2V5KSkgY29weVtrZXldID0gb2JqW2tleV07XG4gICAgfVxuICAgIHJldHVybiBjb3B5O1xuICB9O1xuXG4gIC8vIEZpbGwgaW4gYSBnaXZlbiBvYmplY3Qgd2l0aCBkZWZhdWx0IHByb3BlcnRpZXMuXG4gIF8uZGVmYXVsdHMgPSBmdW5jdGlvbihvYmopIHtcbiAgICBlYWNoKHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSwgZnVuY3Rpb24oc291cmNlKSB7XG4gICAgICBpZiAoc291cmNlKSB7XG4gICAgICAgIGZvciAodmFyIHByb3AgaW4gc291cmNlKSB7XG4gICAgICAgICAgaWYgKG9ialtwcm9wXSA9PSBudWxsKSBvYmpbcHJvcF0gPSBzb3VyY2VbcHJvcF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gb2JqO1xuICB9O1xuXG4gIC8vIENyZWF0ZSBhIChzaGFsbG93LWNsb25lZCkgZHVwbGljYXRlIG9mIGFuIG9iamVjdC5cbiAgXy5jbG9uZSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmICghXy5pc09iamVjdChvYmopKSByZXR1cm4gb2JqO1xuICAgIHJldHVybiBfLmlzQXJyYXkob2JqKSA/IG9iai5zbGljZSgpIDogXy5leHRlbmQoe30sIG9iaik7XG4gIH07XG5cbiAgLy8gSW52b2tlcyBpbnRlcmNlcHRvciB3aXRoIHRoZSBvYmosIGFuZCB0aGVuIHJldHVybnMgb2JqLlxuICAvLyBUaGUgcHJpbWFyeSBwdXJwb3NlIG9mIHRoaXMgbWV0aG9kIGlzIHRvIFwidGFwIGludG9cIiBhIG1ldGhvZCBjaGFpbiwgaW5cbiAgLy8gb3JkZXIgdG8gcGVyZm9ybSBvcGVyYXRpb25zIG9uIGludGVybWVkaWF0ZSByZXN1bHRzIHdpdGhpbiB0aGUgY2hhaW4uXG4gIF8udGFwID0gZnVuY3Rpb24ob2JqLCBpbnRlcmNlcHRvcikge1xuICAgIGludGVyY2VwdG9yKG9iaik7XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcblxuICAvLyBJbnRlcm5hbCByZWN1cnNpdmUgY29tcGFyaXNvbiBmdW5jdGlvbiBmb3IgYGlzRXF1YWxgLlxuICB2YXIgZXEgPSBmdW5jdGlvbihhLCBiLCBhU3RhY2ssIGJTdGFjaykge1xuICAgIC8vIElkZW50aWNhbCBvYmplY3RzIGFyZSBlcXVhbC4gYDAgPT09IC0wYCwgYnV0IHRoZXkgYXJlbid0IGlkZW50aWNhbC5cbiAgICAvLyBTZWUgdGhlIEhhcm1vbnkgYGVnYWxgIHByb3Bvc2FsOiBodHRwOi8vd2lraS5lY21hc2NyaXB0Lm9yZy9kb2t1LnBocD9pZD1oYXJtb255OmVnYWwuXG4gICAgaWYgKGEgPT09IGIpIHJldHVybiBhICE9PSAwIHx8IDEgLyBhID09IDEgLyBiO1xuICAgIC8vIEEgc3RyaWN0IGNvbXBhcmlzb24gaXMgbmVjZXNzYXJ5IGJlY2F1c2UgYG51bGwgPT0gdW5kZWZpbmVkYC5cbiAgICBpZiAoYSA9PSBudWxsIHx8IGIgPT0gbnVsbCkgcmV0dXJuIGEgPT09IGI7XG4gICAgLy8gVW53cmFwIGFueSB3cmFwcGVkIG9iamVjdHMuXG4gICAgaWYgKGEgaW5zdGFuY2VvZiBfKSBhID0gYS5fd3JhcHBlZDtcbiAgICBpZiAoYiBpbnN0YW5jZW9mIF8pIGIgPSBiLl93cmFwcGVkO1xuICAgIC8vIENvbXBhcmUgYFtbQ2xhc3NdXWAgbmFtZXMuXG4gICAgdmFyIGNsYXNzTmFtZSA9IHRvU3RyaW5nLmNhbGwoYSk7XG4gICAgaWYgKGNsYXNzTmFtZSAhPSB0b1N0cmluZy5jYWxsKGIpKSByZXR1cm4gZmFsc2U7XG4gICAgc3dpdGNoIChjbGFzc05hbWUpIHtcbiAgICAgIC8vIFN0cmluZ3MsIG51bWJlcnMsIGRhdGVzLCBhbmQgYm9vbGVhbnMgYXJlIGNvbXBhcmVkIGJ5IHZhbHVlLlxuICAgICAgY2FzZSAnW29iamVjdCBTdHJpbmddJzpcbiAgICAgICAgLy8gUHJpbWl0aXZlcyBhbmQgdGhlaXIgY29ycmVzcG9uZGluZyBvYmplY3Qgd3JhcHBlcnMgYXJlIGVxdWl2YWxlbnQ7IHRodXMsIGBcIjVcImAgaXNcbiAgICAgICAgLy8gZXF1aXZhbGVudCB0byBgbmV3IFN0cmluZyhcIjVcIilgLlxuICAgICAgICByZXR1cm4gYSA9PSBTdHJpbmcoYik7XG4gICAgICBjYXNlICdbb2JqZWN0IE51bWJlcl0nOlxuICAgICAgICAvLyBgTmFOYHMgYXJlIGVxdWl2YWxlbnQsIGJ1dCBub24tcmVmbGV4aXZlLiBBbiBgZWdhbGAgY29tcGFyaXNvbiBpcyBwZXJmb3JtZWQgZm9yXG4gICAgICAgIC8vIG90aGVyIG51bWVyaWMgdmFsdWVzLlxuICAgICAgICByZXR1cm4gYSAhPSArYSA/IGIgIT0gK2IgOiAoYSA9PSAwID8gMSAvIGEgPT0gMSAvIGIgOiBhID09ICtiKTtcbiAgICAgIGNhc2UgJ1tvYmplY3QgRGF0ZV0nOlxuICAgICAgY2FzZSAnW29iamVjdCBCb29sZWFuXSc6XG4gICAgICAgIC8vIENvZXJjZSBkYXRlcyBhbmQgYm9vbGVhbnMgdG8gbnVtZXJpYyBwcmltaXRpdmUgdmFsdWVzLiBEYXRlcyBhcmUgY29tcGFyZWQgYnkgdGhlaXJcbiAgICAgICAgLy8gbWlsbGlzZWNvbmQgcmVwcmVzZW50YXRpb25zLiBOb3RlIHRoYXQgaW52YWxpZCBkYXRlcyB3aXRoIG1pbGxpc2Vjb25kIHJlcHJlc2VudGF0aW9uc1xuICAgICAgICAvLyBvZiBgTmFOYCBhcmUgbm90IGVxdWl2YWxlbnQuXG4gICAgICAgIHJldHVybiArYSA9PSArYjtcbiAgICAgIC8vIFJlZ0V4cHMgYXJlIGNvbXBhcmVkIGJ5IHRoZWlyIHNvdXJjZSBwYXR0ZXJucyBhbmQgZmxhZ3MuXG4gICAgICBjYXNlICdbb2JqZWN0IFJlZ0V4cF0nOlxuICAgICAgICByZXR1cm4gYS5zb3VyY2UgPT0gYi5zb3VyY2UgJiZcbiAgICAgICAgICAgICAgIGEuZ2xvYmFsID09IGIuZ2xvYmFsICYmXG4gICAgICAgICAgICAgICBhLm11bHRpbGluZSA9PSBiLm11bHRpbGluZSAmJlxuICAgICAgICAgICAgICAgYS5pZ25vcmVDYXNlID09IGIuaWdub3JlQ2FzZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBhICE9ICdvYmplY3QnIHx8IHR5cGVvZiBiICE9ICdvYmplY3QnKSByZXR1cm4gZmFsc2U7XG4gICAgLy8gQXNzdW1lIGVxdWFsaXR5IGZvciBjeWNsaWMgc3RydWN0dXJlcy4gVGhlIGFsZ29yaXRobSBmb3IgZGV0ZWN0aW5nIGN5Y2xpY1xuICAgIC8vIHN0cnVjdHVyZXMgaXMgYWRhcHRlZCBmcm9tIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjMsIGFic3RyYWN0IG9wZXJhdGlvbiBgSk9gLlxuICAgIHZhciBsZW5ndGggPSBhU3RhY2subGVuZ3RoO1xuICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgLy8gTGluZWFyIHNlYXJjaC4gUGVyZm9ybWFuY2UgaXMgaW52ZXJzZWx5IHByb3BvcnRpb25hbCB0byB0aGUgbnVtYmVyIG9mXG4gICAgICAvLyB1bmlxdWUgbmVzdGVkIHN0cnVjdHVyZXMuXG4gICAgICBpZiAoYVN0YWNrW2xlbmd0aF0gPT0gYSkgcmV0dXJuIGJTdGFja1tsZW5ndGhdID09IGI7XG4gICAgfVxuICAgIC8vIEFkZCB0aGUgZmlyc3Qgb2JqZWN0IHRvIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgICBhU3RhY2sucHVzaChhKTtcbiAgICBiU3RhY2sucHVzaChiKTtcbiAgICB2YXIgc2l6ZSA9IDAsIHJlc3VsdCA9IHRydWU7XG4gICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIGFuZCBhcnJheXMuXG4gICAgaWYgKGNsYXNzTmFtZSA9PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgICAvLyBDb21wYXJlIGFycmF5IGxlbmd0aHMgdG8gZGV0ZXJtaW5lIGlmIGEgZGVlcCBjb21wYXJpc29uIGlzIG5lY2Vzc2FyeS5cbiAgICAgIHNpemUgPSBhLmxlbmd0aDtcbiAgICAgIHJlc3VsdCA9IHNpemUgPT0gYi5sZW5ndGg7XG4gICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgIC8vIERlZXAgY29tcGFyZSB0aGUgY29udGVudHMsIGlnbm9yaW5nIG5vbi1udW1lcmljIHByb3BlcnRpZXMuXG4gICAgICAgIHdoaWxlIChzaXplLS0pIHtcbiAgICAgICAgICBpZiAoIShyZXN1bHQgPSBlcShhW3NpemVdLCBiW3NpemVdLCBhU3RhY2ssIGJTdGFjaykpKSBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBPYmplY3RzIHdpdGggZGlmZmVyZW50IGNvbnN0cnVjdG9ycyBhcmUgbm90IGVxdWl2YWxlbnQsIGJ1dCBgT2JqZWN0YHNcbiAgICAgIC8vIGZyb20gZGlmZmVyZW50IGZyYW1lcyBhcmUuXG4gICAgICB2YXIgYUN0b3IgPSBhLmNvbnN0cnVjdG9yLCBiQ3RvciA9IGIuY29uc3RydWN0b3I7XG4gICAgICBpZiAoYUN0b3IgIT09IGJDdG9yICYmICEoXy5pc0Z1bmN0aW9uKGFDdG9yKSAmJiAoYUN0b3IgaW5zdGFuY2VvZiBhQ3RvcikgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfLmlzRnVuY3Rpb24oYkN0b3IpICYmIChiQ3RvciBpbnN0YW5jZW9mIGJDdG9yKSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgLy8gRGVlcCBjb21wYXJlIG9iamVjdHMuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gYSkge1xuICAgICAgICBpZiAoXy5oYXMoYSwga2V5KSkge1xuICAgICAgICAgIC8vIENvdW50IHRoZSBleHBlY3RlZCBudW1iZXIgb2YgcHJvcGVydGllcy5cbiAgICAgICAgICBzaXplKys7XG4gICAgICAgICAgLy8gRGVlcCBjb21wYXJlIGVhY2ggbWVtYmVyLlxuICAgICAgICAgIGlmICghKHJlc3VsdCA9IF8uaGFzKGIsIGtleSkgJiYgZXEoYVtrZXldLCBiW2tleV0sIGFTdGFjaywgYlN0YWNrKSkpIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBFbnN1cmUgdGhhdCBib3RoIG9iamVjdHMgY29udGFpbiB0aGUgc2FtZSBudW1iZXIgb2YgcHJvcGVydGllcy5cbiAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgZm9yIChrZXkgaW4gYikge1xuICAgICAgICAgIGlmIChfLmhhcyhiLCBrZXkpICYmICEoc2l6ZS0tKSkgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ID0gIXNpemU7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIFJlbW92ZSB0aGUgZmlyc3Qgb2JqZWN0IGZyb20gdGhlIHN0YWNrIG9mIHRyYXZlcnNlZCBvYmplY3RzLlxuICAgIGFTdGFjay5wb3AoKTtcbiAgICBiU3RhY2sucG9wKCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBQZXJmb3JtIGEgZGVlcCBjb21wYXJpc29uIHRvIGNoZWNrIGlmIHR3byBvYmplY3RzIGFyZSBlcXVhbC5cbiAgXy5pc0VxdWFsID0gZnVuY3Rpb24oYSwgYikge1xuICAgIHJldHVybiBlcShhLCBiLCBbXSwgW10pO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gYXJyYXksIHN0cmluZywgb3Igb2JqZWN0IGVtcHR5P1xuICAvLyBBbiBcImVtcHR5XCIgb2JqZWN0IGhhcyBubyBlbnVtZXJhYmxlIG93bi1wcm9wZXJ0aWVzLlxuICBfLmlzRW1wdHkgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiB0cnVlO1xuICAgIGlmIChfLmlzQXJyYXkob2JqKSB8fCBfLmlzU3RyaW5nKG9iaikpIHJldHVybiBvYmoubGVuZ3RoID09PSAwO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIGlmIChfLmhhcyhvYmosIGtleSkpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhbHVlIGEgRE9NIGVsZW1lbnQ/XG4gIF8uaXNFbGVtZW50ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuICEhKG9iaiAmJiBvYmoubm9kZVR5cGUgPT09IDEpO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gdmFsdWUgYW4gYXJyYXk/XG4gIC8vIERlbGVnYXRlcyB0byBFQ01BNSdzIG5hdGl2ZSBBcnJheS5pc0FycmF5XG4gIF8uaXNBcnJheSA9IG5hdGl2ZUlzQXJyYXkgfHwgZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PSAnW29iamVjdCBBcnJheV0nO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gdmFyaWFibGUgYW4gb2JqZWN0P1xuICBfLmlzT2JqZWN0ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIG9iaiA9PT0gT2JqZWN0KG9iaik7XG4gIH07XG5cbiAgLy8gQWRkIHNvbWUgaXNUeXBlIG1ldGhvZHM6IGlzQXJndW1lbnRzLCBpc0Z1bmN0aW9uLCBpc1N0cmluZywgaXNOdW1iZXIsIGlzRGF0ZSwgaXNSZWdFeHAuXG4gIGVhY2goWydBcmd1bWVudHMnLCAnRnVuY3Rpb24nLCAnU3RyaW5nJywgJ051bWJlcicsICdEYXRlJywgJ1JlZ0V4cCddLCBmdW5jdGlvbihuYW1lKSB7XG4gICAgX1snaXMnICsgbmFtZV0gPSBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT0gJ1tvYmplY3QgJyArIG5hbWUgKyAnXSc7XG4gICAgfTtcbiAgfSk7XG5cbiAgLy8gRGVmaW5lIGEgZmFsbGJhY2sgdmVyc2lvbiBvZiB0aGUgbWV0aG9kIGluIGJyb3dzZXJzIChhaGVtLCBJRSksIHdoZXJlXG4gIC8vIHRoZXJlIGlzbid0IGFueSBpbnNwZWN0YWJsZSBcIkFyZ3VtZW50c1wiIHR5cGUuXG4gIGlmICghXy5pc0FyZ3VtZW50cyhhcmd1bWVudHMpKSB7XG4gICAgXy5pc0FyZ3VtZW50cyA9IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuICEhKG9iaiAmJiBfLmhhcyhvYmosICdjYWxsZWUnKSk7XG4gICAgfTtcbiAgfVxuXG4gIC8vIE9wdGltaXplIGBpc0Z1bmN0aW9uYCBpZiBhcHByb3ByaWF0ZS5cbiAgaWYgKHR5cGVvZiAoLy4vKSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIF8uaXNGdW5jdGlvbiA9IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbic7XG4gICAgfTtcbiAgfVxuXG4gIC8vIElzIGEgZ2l2ZW4gb2JqZWN0IGEgZmluaXRlIG51bWJlcj9cbiAgXy5pc0Zpbml0ZSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBpc0Zpbml0ZShvYmopICYmICFpc05hTihwYXJzZUZsb2F0KG9iaikpO1xuICB9O1xuXG4gIC8vIElzIHRoZSBnaXZlbiB2YWx1ZSBgTmFOYD8gKE5hTiBpcyB0aGUgb25seSBudW1iZXIgd2hpY2ggZG9lcyBub3QgZXF1YWwgaXRzZWxmKS5cbiAgXy5pc05hTiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBfLmlzTnVtYmVyKG9iaikgJiYgb2JqICE9ICtvYmo7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YWx1ZSBhIGJvb2xlYW4/XG4gIF8uaXNCb29sZWFuID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIG9iaiA9PT0gdHJ1ZSB8fCBvYmogPT09IGZhbHNlIHx8IHRvU3RyaW5nLmNhbGwob2JqKSA9PSAnW29iamVjdCBCb29sZWFuXSc7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YWx1ZSBlcXVhbCB0byBudWxsP1xuICBfLmlzTnVsbCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBvYmogPT09IG51bGw7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YXJpYWJsZSB1bmRlZmluZWQ/XG4gIF8uaXNVbmRlZmluZWQgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gb2JqID09PSB2b2lkIDA7XG4gIH07XG5cbiAgLy8gU2hvcnRjdXQgZnVuY3Rpb24gZm9yIGNoZWNraW5nIGlmIGFuIG9iamVjdCBoYXMgYSBnaXZlbiBwcm9wZXJ0eSBkaXJlY3RseVxuICAvLyBvbiBpdHNlbGYgKGluIG90aGVyIHdvcmRzLCBub3Qgb24gYSBwcm90b3R5cGUpLlxuICBfLmhhcyA9IGZ1bmN0aW9uKG9iaiwga2V5KSB7XG4gICAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpO1xuICB9O1xuXG4gIC8vIFV0aWxpdHkgRnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gUnVuIFVuZGVyc2NvcmUuanMgaW4gKm5vQ29uZmxpY3QqIG1vZGUsIHJldHVybmluZyB0aGUgYF9gIHZhcmlhYmxlIHRvIGl0c1xuICAvLyBwcmV2aW91cyBvd25lci4gUmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGUgVW5kZXJzY29yZSBvYmplY3QuXG4gIF8ubm9Db25mbGljdCA9IGZ1bmN0aW9uKCkge1xuICAgIHJvb3QuXyA9IHByZXZpb3VzVW5kZXJzY29yZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBLZWVwIHRoZSBpZGVudGl0eSBmdW5jdGlvbiBhcm91bmQgZm9yIGRlZmF1bHQgaXRlcmF0b3JzLlxuICBfLmlkZW50aXR5ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG5cbiAgLy8gUnVuIGEgZnVuY3Rpb24gKipuKiogdGltZXMuXG4gIF8udGltZXMgPSBmdW5jdGlvbihuLCBpdGVyYXRvciwgY29udGV4dCkge1xuICAgIHZhciBhY2N1bSA9IEFycmF5KG4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSBhY2N1bVtpXSA9IGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgaSk7XG4gICAgcmV0dXJuIGFjY3VtO1xuICB9O1xuXG4gIC8vIFJldHVybiBhIHJhbmRvbSBpbnRlZ2VyIGJldHdlZW4gbWluIGFuZCBtYXggKGluY2x1c2l2ZSkuXG4gIF8ucmFuZG9tID0gZnVuY3Rpb24obWluLCBtYXgpIHtcbiAgICBpZiAobWF4ID09IG51bGwpIHtcbiAgICAgIG1heCA9IG1pbjtcbiAgICAgIG1pbiA9IDA7XG4gICAgfVxuICAgIHJldHVybiBtaW4gKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluICsgMSkpO1xuICB9O1xuXG4gIC8vIExpc3Qgb2YgSFRNTCBlbnRpdGllcyBmb3IgZXNjYXBpbmcuXG4gIHZhciBlbnRpdHlNYXAgPSB7XG4gICAgZXNjYXBlOiB7XG4gICAgICAnJic6ICcmYW1wOycsXG4gICAgICAnPCc6ICcmbHQ7JyxcbiAgICAgICc+JzogJyZndDsnLFxuICAgICAgJ1wiJzogJyZxdW90OycsXG4gICAgICBcIidcIjogJyYjeDI3OycsXG4gICAgICAnLyc6ICcmI3gyRjsnXG4gICAgfVxuICB9O1xuICBlbnRpdHlNYXAudW5lc2NhcGUgPSBfLmludmVydChlbnRpdHlNYXAuZXNjYXBlKTtcblxuICAvLyBSZWdleGVzIGNvbnRhaW5pbmcgdGhlIGtleXMgYW5kIHZhbHVlcyBsaXN0ZWQgaW1tZWRpYXRlbHkgYWJvdmUuXG4gIHZhciBlbnRpdHlSZWdleGVzID0ge1xuICAgIGVzY2FwZTogICBuZXcgUmVnRXhwKCdbJyArIF8ua2V5cyhlbnRpdHlNYXAuZXNjYXBlKS5qb2luKCcnKSArICddJywgJ2cnKSxcbiAgICB1bmVzY2FwZTogbmV3IFJlZ0V4cCgnKCcgKyBfLmtleXMoZW50aXR5TWFwLnVuZXNjYXBlKS5qb2luKCd8JykgKyAnKScsICdnJylcbiAgfTtcblxuICAvLyBGdW5jdGlvbnMgZm9yIGVzY2FwaW5nIGFuZCB1bmVzY2FwaW5nIHN0cmluZ3MgdG8vZnJvbSBIVE1MIGludGVycG9sYXRpb24uXG4gIF8uZWFjaChbJ2VzY2FwZScsICd1bmVzY2FwZSddLCBmdW5jdGlvbihtZXRob2QpIHtcbiAgICBfW21ldGhvZF0gPSBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgIGlmIChzdHJpbmcgPT0gbnVsbCkgcmV0dXJuICcnO1xuICAgICAgcmV0dXJuICgnJyArIHN0cmluZykucmVwbGFjZShlbnRpdHlSZWdleGVzW21ldGhvZF0sIGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgICAgIHJldHVybiBlbnRpdHlNYXBbbWV0aG9kXVttYXRjaF07XG4gICAgICB9KTtcbiAgICB9O1xuICB9KTtcblxuICAvLyBJZiB0aGUgdmFsdWUgb2YgdGhlIG5hbWVkIHByb3BlcnR5IGlzIGEgZnVuY3Rpb24gdGhlbiBpbnZva2UgaXQ7XG4gIC8vIG90aGVyd2lzZSwgcmV0dXJuIGl0LlxuICBfLnJlc3VsdCA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHtcbiAgICBpZiAob2JqZWN0ID09IG51bGwpIHJldHVybiBudWxsO1xuICAgIHZhciB2YWx1ZSA9IG9iamVjdFtwcm9wZXJ0eV07XG4gICAgcmV0dXJuIF8uaXNGdW5jdGlvbih2YWx1ZSkgPyB2YWx1ZS5jYWxsKG9iamVjdCkgOiB2YWx1ZTtcbiAgfTtcblxuICAvLyBBZGQgeW91ciBvd24gY3VzdG9tIGZ1bmN0aW9ucyB0byB0aGUgVW5kZXJzY29yZSBvYmplY3QuXG4gIF8ubWl4aW4gPSBmdW5jdGlvbihvYmopIHtcbiAgICBlYWNoKF8uZnVuY3Rpb25zKG9iaiksIGZ1bmN0aW9uKG5hbWUpe1xuICAgICAgdmFyIGZ1bmMgPSBfW25hbWVdID0gb2JqW25hbWVdO1xuICAgICAgXy5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbdGhpcy5fd3JhcHBlZF07XG4gICAgICAgIHB1c2guYXBwbHkoYXJncywgYXJndW1lbnRzKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5jYWxsKHRoaXMsIGZ1bmMuYXBwbHkoXywgYXJncykpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfTtcblxuICAvLyBHZW5lcmF0ZSBhIHVuaXF1ZSBpbnRlZ2VyIGlkICh1bmlxdWUgd2l0aGluIHRoZSBlbnRpcmUgY2xpZW50IHNlc3Npb24pLlxuICAvLyBVc2VmdWwgZm9yIHRlbXBvcmFyeSBET00gaWRzLlxuICB2YXIgaWRDb3VudGVyID0gMDtcbiAgXy51bmlxdWVJZCA9IGZ1bmN0aW9uKHByZWZpeCkge1xuICAgIHZhciBpZCA9ICsraWRDb3VudGVyICsgJyc7XG4gICAgcmV0dXJuIHByZWZpeCA/IHByZWZpeCArIGlkIDogaWQ7XG4gIH07XG5cbiAgLy8gQnkgZGVmYXVsdCwgVW5kZXJzY29yZSB1c2VzIEVSQi1zdHlsZSB0ZW1wbGF0ZSBkZWxpbWl0ZXJzLCBjaGFuZ2UgdGhlXG4gIC8vIGZvbGxvd2luZyB0ZW1wbGF0ZSBzZXR0aW5ncyB0byB1c2UgYWx0ZXJuYXRpdmUgZGVsaW1pdGVycy5cbiAgXy50ZW1wbGF0ZVNldHRpbmdzID0ge1xuICAgIGV2YWx1YXRlICAgIDogLzwlKFtcXHNcXFNdKz8pJT4vZyxcbiAgICBpbnRlcnBvbGF0ZSA6IC88JT0oW1xcc1xcU10rPyklPi9nLFxuICAgIGVzY2FwZSAgICAgIDogLzwlLShbXFxzXFxTXSs/KSU+L2dcbiAgfTtcblxuICAvLyBXaGVuIGN1c3RvbWl6aW5nIGB0ZW1wbGF0ZVNldHRpbmdzYCwgaWYgeW91IGRvbid0IHdhbnQgdG8gZGVmaW5lIGFuXG4gIC8vIGludGVycG9sYXRpb24sIGV2YWx1YXRpb24gb3IgZXNjYXBpbmcgcmVnZXgsIHdlIG5lZWQgb25lIHRoYXQgaXNcbiAgLy8gZ3VhcmFudGVlZCBub3QgdG8gbWF0Y2guXG4gIHZhciBub01hdGNoID0gLyguKV4vO1xuXG4gIC8vIENlcnRhaW4gY2hhcmFjdGVycyBuZWVkIHRvIGJlIGVzY2FwZWQgc28gdGhhdCB0aGV5IGNhbiBiZSBwdXQgaW50byBhXG4gIC8vIHN0cmluZyBsaXRlcmFsLlxuICB2YXIgZXNjYXBlcyA9IHtcbiAgICBcIidcIjogICAgICBcIidcIixcbiAgICAnXFxcXCc6ICAgICAnXFxcXCcsXG4gICAgJ1xccic6ICAgICAncicsXG4gICAgJ1xcbic6ICAgICAnbicsXG4gICAgJ1xcdCc6ICAgICAndCcsXG4gICAgJ1xcdTIwMjgnOiAndTIwMjgnLFxuICAgICdcXHUyMDI5JzogJ3UyMDI5J1xuICB9O1xuXG4gIHZhciBlc2NhcGVyID0gL1xcXFx8J3xcXHJ8XFxufFxcdHxcXHUyMDI4fFxcdTIwMjkvZztcblxuICAvLyBKYXZhU2NyaXB0IG1pY3JvLXRlbXBsYXRpbmcsIHNpbWlsYXIgdG8gSm9obiBSZXNpZydzIGltcGxlbWVudGF0aW9uLlxuICAvLyBVbmRlcnNjb3JlIHRlbXBsYXRpbmcgaGFuZGxlcyBhcmJpdHJhcnkgZGVsaW1pdGVycywgcHJlc2VydmVzIHdoaXRlc3BhY2UsXG4gIC8vIGFuZCBjb3JyZWN0bHkgZXNjYXBlcyBxdW90ZXMgd2l0aGluIGludGVycG9sYXRlZCBjb2RlLlxuICBfLnRlbXBsYXRlID0gZnVuY3Rpb24odGV4dCwgZGF0YSwgc2V0dGluZ3MpIHtcbiAgICB2YXIgcmVuZGVyO1xuICAgIHNldHRpbmdzID0gXy5kZWZhdWx0cyh7fSwgc2V0dGluZ3MsIF8udGVtcGxhdGVTZXR0aW5ncyk7XG5cbiAgICAvLyBDb21iaW5lIGRlbGltaXRlcnMgaW50byBvbmUgcmVndWxhciBleHByZXNzaW9uIHZpYSBhbHRlcm5hdGlvbi5cbiAgICB2YXIgbWF0Y2hlciA9IG5ldyBSZWdFeHAoW1xuICAgICAgKHNldHRpbmdzLmVzY2FwZSB8fCBub01hdGNoKS5zb3VyY2UsXG4gICAgICAoc2V0dGluZ3MuaW50ZXJwb2xhdGUgfHwgbm9NYXRjaCkuc291cmNlLFxuICAgICAgKHNldHRpbmdzLmV2YWx1YXRlIHx8IG5vTWF0Y2gpLnNvdXJjZVxuICAgIF0uam9pbignfCcpICsgJ3wkJywgJ2cnKTtcblxuICAgIC8vIENvbXBpbGUgdGhlIHRlbXBsYXRlIHNvdXJjZSwgZXNjYXBpbmcgc3RyaW5nIGxpdGVyYWxzIGFwcHJvcHJpYXRlbHkuXG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgc291cmNlID0gXCJfX3ArPSdcIjtcbiAgICB0ZXh0LnJlcGxhY2UobWF0Y2hlciwgZnVuY3Rpb24obWF0Y2gsIGVzY2FwZSwgaW50ZXJwb2xhdGUsIGV2YWx1YXRlLCBvZmZzZXQpIHtcbiAgICAgIHNvdXJjZSArPSB0ZXh0LnNsaWNlKGluZGV4LCBvZmZzZXQpXG4gICAgICAgIC5yZXBsYWNlKGVzY2FwZXIsIGZ1bmN0aW9uKG1hdGNoKSB7IHJldHVybiAnXFxcXCcgKyBlc2NhcGVzW21hdGNoXTsgfSk7XG5cbiAgICAgIGlmIChlc2NhcGUpIHtcbiAgICAgICAgc291cmNlICs9IFwiJytcXG4oKF9fdD0oXCIgKyBlc2NhcGUgKyBcIikpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xcbidcIjtcbiAgICAgIH1cbiAgICAgIGlmIChpbnRlcnBvbGF0ZSkge1xuICAgICAgICBzb3VyY2UgKz0gXCInK1xcbigoX190PShcIiArIGludGVycG9sYXRlICsgXCIpKT09bnVsbD8nJzpfX3QpK1xcbidcIjtcbiAgICAgIH1cbiAgICAgIGlmIChldmFsdWF0ZSkge1xuICAgICAgICBzb3VyY2UgKz0gXCInO1xcblwiICsgZXZhbHVhdGUgKyBcIlxcbl9fcCs9J1wiO1xuICAgICAgfVxuICAgICAgaW5kZXggPSBvZmZzZXQgKyBtYXRjaC5sZW5ndGg7XG4gICAgICByZXR1cm4gbWF0Y2g7XG4gICAgfSk7XG4gICAgc291cmNlICs9IFwiJztcXG5cIjtcblxuICAgIC8vIElmIGEgdmFyaWFibGUgaXMgbm90IHNwZWNpZmllZCwgcGxhY2UgZGF0YSB2YWx1ZXMgaW4gbG9jYWwgc2NvcGUuXG4gICAgaWYgKCFzZXR0aW5ncy52YXJpYWJsZSkgc291cmNlID0gJ3dpdGgob2JqfHx7fSl7XFxuJyArIHNvdXJjZSArICd9XFxuJztcblxuICAgIHNvdXJjZSA9IFwidmFyIF9fdCxfX3A9JycsX19qPUFycmF5LnByb3RvdHlwZS5qb2luLFwiICtcbiAgICAgIFwicHJpbnQ9ZnVuY3Rpb24oKXtfX3ArPV9fai5jYWxsKGFyZ3VtZW50cywnJyk7fTtcXG5cIiArXG4gICAgICBzb3VyY2UgKyBcInJldHVybiBfX3A7XFxuXCI7XG5cbiAgICB0cnkge1xuICAgICAgcmVuZGVyID0gbmV3IEZ1bmN0aW9uKHNldHRpbmdzLnZhcmlhYmxlIHx8ICdvYmonLCAnXycsIHNvdXJjZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZS5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICB0aHJvdyBlO1xuICAgIH1cblxuICAgIGlmIChkYXRhKSByZXR1cm4gcmVuZGVyKGRhdGEsIF8pO1xuICAgIHZhciB0ZW1wbGF0ZSA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgIHJldHVybiByZW5kZXIuY2FsbCh0aGlzLCBkYXRhLCBfKTtcbiAgICB9O1xuXG4gICAgLy8gUHJvdmlkZSB0aGUgY29tcGlsZWQgZnVuY3Rpb24gc291cmNlIGFzIGEgY29udmVuaWVuY2UgZm9yIHByZWNvbXBpbGF0aW9uLlxuICAgIHRlbXBsYXRlLnNvdXJjZSA9ICdmdW5jdGlvbignICsgKHNldHRpbmdzLnZhcmlhYmxlIHx8ICdvYmonKSArICcpe1xcbicgKyBzb3VyY2UgKyAnfSc7XG5cbiAgICByZXR1cm4gdGVtcGxhdGU7XG4gIH07XG5cbiAgLy8gQWRkIGEgXCJjaGFpblwiIGZ1bmN0aW9uLCB3aGljaCB3aWxsIGRlbGVnYXRlIHRvIHRoZSB3cmFwcGVyLlxuICBfLmNoYWluID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIF8ob2JqKS5jaGFpbigpO1xuICB9O1xuXG4gIC8vIE9PUFxuICAvLyAtLS0tLS0tLS0tLS0tLS1cbiAgLy8gSWYgVW5kZXJzY29yZSBpcyBjYWxsZWQgYXMgYSBmdW5jdGlvbiwgaXQgcmV0dXJucyBhIHdyYXBwZWQgb2JqZWN0IHRoYXRcbiAgLy8gY2FuIGJlIHVzZWQgT08tc3R5bGUuIFRoaXMgd3JhcHBlciBob2xkcyBhbHRlcmVkIHZlcnNpb25zIG9mIGFsbCB0aGVcbiAgLy8gdW5kZXJzY29yZSBmdW5jdGlvbnMuIFdyYXBwZWQgb2JqZWN0cyBtYXkgYmUgY2hhaW5lZC5cblxuICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gY29udGludWUgY2hhaW5pbmcgaW50ZXJtZWRpYXRlIHJlc3VsdHMuXG4gIHZhciByZXN1bHQgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gdGhpcy5fY2hhaW4gPyBfKG9iaikuY2hhaW4oKSA6IG9iajtcbiAgfTtcblxuICAvLyBBZGQgYWxsIG9mIHRoZSBVbmRlcnNjb3JlIGZ1bmN0aW9ucyB0byB0aGUgd3JhcHBlciBvYmplY3QuXG4gIF8ubWl4aW4oXyk7XG5cbiAgLy8gQWRkIGFsbCBtdXRhdG9yIEFycmF5IGZ1bmN0aW9ucyB0byB0aGUgd3JhcHBlci5cbiAgZWFjaChbJ3BvcCcsICdwdXNoJywgJ3JldmVyc2UnLCAnc2hpZnQnLCAnc29ydCcsICdzcGxpY2UnLCAndW5zaGlmdCddLCBmdW5jdGlvbihuYW1lKSB7XG4gICAgdmFyIG1ldGhvZCA9IEFycmF5UHJvdG9bbmFtZV07XG4gICAgXy5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBvYmogPSB0aGlzLl93cmFwcGVkO1xuICAgICAgbWV0aG9kLmFwcGx5KG9iaiwgYXJndW1lbnRzKTtcbiAgICAgIGlmICgobmFtZSA9PSAnc2hpZnQnIHx8IG5hbWUgPT0gJ3NwbGljZScpICYmIG9iai5sZW5ndGggPT09IDApIGRlbGV0ZSBvYmpbMF07XG4gICAgICByZXR1cm4gcmVzdWx0LmNhbGwodGhpcywgb2JqKTtcbiAgICB9O1xuICB9KTtcblxuICAvLyBBZGQgYWxsIGFjY2Vzc29yIEFycmF5IGZ1bmN0aW9ucyB0byB0aGUgd3JhcHBlci5cbiAgZWFjaChbJ2NvbmNhdCcsICdqb2luJywgJ3NsaWNlJ10sIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICB2YXIgbWV0aG9kID0gQXJyYXlQcm90b1tuYW1lXTtcbiAgICBfLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHJlc3VsdC5jYWxsKHRoaXMsIG1ldGhvZC5hcHBseSh0aGlzLl93cmFwcGVkLCBhcmd1bWVudHMpKTtcbiAgICB9O1xuICB9KTtcblxuICBfLmV4dGVuZChfLnByb3RvdHlwZSwge1xuXG4gICAgLy8gU3RhcnQgY2hhaW5pbmcgYSB3cmFwcGVkIFVuZGVyc2NvcmUgb2JqZWN0LlxuICAgIGNoYWluOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX2NoYWluID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBFeHRyYWN0cyB0aGUgcmVzdWx0IGZyb20gYSB3cmFwcGVkIGFuZCBjaGFpbmVkIG9iamVjdC5cbiAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fd3JhcHBlZDtcbiAgICB9XG5cbiAgfSk7XG5cbn0pLmNhbGwodGhpcyk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy91bmRlcnNjb3JlL3VuZGVyc2NvcmUuanNcbi8vIG1vZHVsZSBpZCA9IDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1\n");

/***/ }),
/* 2 */
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports) {

eval("module.exports = require(\"path\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9leHRlcm5hbCBcInBhdGhcIj81YjJhIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInBhdGhcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJwYXRoXCJcbi8vIG1vZHVsZSBpZCA9IDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///2\n");

/***/ }),
/* 3 */
/*!***********************************!*\
  !*** external "react-router-dom" ***!
  \***********************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports) {

eval("module.exports = require(\"react-router-dom\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9leHRlcm5hbCBcInJlYWN0LXJvdXRlci1kb21cIj8wOTU2Il0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInJlYWN0LXJvdXRlci1kb21cIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJyZWFjdC1yb3V0ZXItZG9tXCJcbi8vIG1vZHVsZSBpZCA9IDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///3\n");

/***/ }),
/* 4 */
/*!****************************************!*\
  !*** ./node_modules/nedb/lib/model.js ***!
  \****************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * Handle models (i.e. docs)\n * Serialization/deserialization\n * Copying\n * Querying, update\n */\n\nvar util = __webpack_require__(/*! util */ 5)\n  , _ = __webpack_require__(/*! underscore */ 1)\n  , modifierFunctions = {}\n  , lastStepModifierFunctions = {}\n  , comparisonFunctions = {}\n  , logicalOperators = {}\n  , arrayComparisonFunctions = {}\n  ;\n\n\n/**\n * Check a key, throw an error if the key is non valid\n * @param {String} k key\n * @param {Model} v value, needed to treat the Date edge case\n * Non-treatable edge cases here: if part of the object if of the form { $$date: number } or { $$deleted: true }\n * Its serialized-then-deserialized version it will transformed into a Date object\n * But you really need to want it to trigger such behaviour, even when warned not to use '$' at the beginning of the field names...\n */\nfunction checkKey (k, v) {\n  if (typeof k === 'number') {\n    k = k.toString();\n  }\n\n  if (k[0] === '$' && !(k === '$$date' && typeof v === 'number') && !(k === '$$deleted' && v === true) && !(k === '$$indexCreated') && !(k === '$$indexRemoved')) {\n    throw new Error('Field names cannot begin with the $ character');\n  }\n\n  if (k.indexOf('.') !== -1) {\n    throw new Error('Field names cannot contain a .');\n  }\n}\n\n\n/**\n * Check a DB object and throw an error if it's not valid\n * Works by applying the above checkKey function to all fields recursively\n */\nfunction checkObject (obj) {\n  if (util.isArray(obj)) {\n    obj.forEach(function (o) {\n      checkObject(o);\n    });\n  }\n\n  if (typeof obj === 'object' && obj !== null) {\n    Object.keys(obj).forEach(function (k) {\n      checkKey(k, obj[k]);\n      checkObject(obj[k]);\n    });\n  }\n}\n\n\n/**\n * Serialize an object to be persisted to a one-line string\n * For serialization/deserialization, we use the native JSON parser and not eval or Function\n * That gives us less freedom but data entered in the database may come from users\n * so eval and the like are not safe\n * Accepted primitive types: Number, String, Boolean, Date, null\n * Accepted secondary types: Objects, Arrays\n */\nfunction serialize (obj) {\n  var res;\n\n  res = JSON.stringify(obj, function (k, v) {\n    checkKey(k, v);\n\n    if (v === undefined) { return undefined; }\n    if (v === null) { return null; }\n\n    // Hackish way of checking if object is Date (this way it works between execution contexts in node-webkit).\n    // We can't use value directly because for dates it is already string in this function (date.toJSON was already called), so we use this\n    if (typeof this[k].getTime === 'function') { return { $$date: this[k].getTime() }; }\n\n    return v;\n  });\n\n  return res;\n}\n\n\n/**\n * From a one-line representation of an object generate by the serialize function\n * Return the object itself\n */\nfunction deserialize (rawData) {\n  return JSON.parse(rawData, function (k, v) {\n    if (k === '$$date') { return new Date(v); }\n    if (typeof v === 'string' || typeof v === 'number' || typeof v === 'boolean' || v === null) { return v; }\n    if (v && v.$$date) { return v.$$date; }\n\n    return v;\n  });\n}\n\n\n/**\n * Deep copy a DB object\n * The optional strictKeys flag (defaulting to false) indicates whether to copy everything or only fields\n * where the keys are valid, i.e. don't begin with $ and don't contain a .\n */\nfunction deepCopy (obj, strictKeys) {\n  var res;\n\n  if ( typeof obj === 'boolean' ||\n       typeof obj === 'number' ||\n       typeof obj === 'string' ||\n       obj === null ||\n       (util.isDate(obj)) ) {\n    return obj;\n  }\n\n  if (util.isArray(obj)) {\n    res = [];\n    obj.forEach(function (o) { res.push(deepCopy(o, strictKeys)); });\n    return res;\n  }\n\n  if (typeof obj === 'object') {\n    res = {};\n    Object.keys(obj).forEach(function (k) {\n      if (!strictKeys || (k[0] !== '$' && k.indexOf('.') === -1)) {\n        res[k] = deepCopy(obj[k], strictKeys);\n      }\n    });\n    return res;\n  }\n\n  return undefined;   // For now everything else is undefined. We should probably throw an error instead\n}\n\n\n/**\n * Tells if an object is a primitive type or a \"real\" object\n * Arrays are considered primitive\n */\nfunction isPrimitiveType (obj) {\n  return ( typeof obj === 'boolean' ||\n       typeof obj === 'number' ||\n       typeof obj === 'string' ||\n       obj === null ||\n       util.isDate(obj) ||\n       util.isArray(obj));\n}\n\n\n/**\n * Utility functions for comparing things\n * Assumes type checking was already done (a and b already have the same type)\n * compareNSB works for numbers, strings and booleans\n */\nfunction compareNSB (a, b) {\n  if (a < b) { return -1; }\n  if (a > b) { return 1; }\n  return 0;\n}\n\nfunction compareArrays (a, b) {\n  var i, comp;\n\n  for (i = 0; i < Math.min(a.length, b.length); i += 1) {\n    comp = compareThings(a[i], b[i]);\n\n    if (comp !== 0) { return comp; }\n  }\n\n  // Common section was identical, longest one wins\n  return compareNSB(a.length, b.length);\n}\n\n\n/**\n * Compare { things U undefined }\n * Things are defined as any native types (string, number, boolean, null, date) and objects\n * We need to compare with undefined as it will be used in indexes\n * In the case of objects and arrays, we deep-compare\n * If two objects dont have the same type, the (arbitrary) type hierarchy is: undefined, null, number, strings, boolean, dates, arrays, objects\n * Return -1 if a < b, 1 if a > b and 0 if a = b (note that equality here is NOT the same as defined in areThingsEqual!)\n *\n * @param {Function} _compareStrings String comparing function, returning -1, 0 or 1, overriding default string comparison (useful for languages with accented letters)\n */\nfunction compareThings (a, b, _compareStrings) {\n  var aKeys, bKeys, comp, i\n    , compareStrings = _compareStrings || compareNSB;\n\n  // undefined\n  if (a === undefined) { return b === undefined ? 0 : -1; }\n  if (b === undefined) { return a === undefined ? 0 : 1; }\n\n  // null\n  if (a === null) { return b === null ? 0 : -1; }\n  if (b === null) { return a === null ? 0 : 1; }\n\n  // Numbers\n  if (typeof a === 'number') { return typeof b === 'number' ? compareNSB(a, b) : -1; }\n  if (typeof b === 'number') { return typeof a === 'number' ? compareNSB(a, b) : 1; }\n\n  // Strings\n  if (typeof a === 'string') { return typeof b === 'string' ? compareStrings(a, b) : -1; }\n  if (typeof b === 'string') { return typeof a === 'string' ? compareStrings(a, b) : 1; }\n\n  // Booleans\n  if (typeof a === 'boolean') { return typeof b === 'boolean' ? compareNSB(a, b) : -1; }\n  if (typeof b === 'boolean') { return typeof a === 'boolean' ? compareNSB(a, b) : 1; }\n\n  // Dates\n  if (util.isDate(a)) { return util.isDate(b) ? compareNSB(a.getTime(), b.getTime()) : -1; }\n  if (util.isDate(b)) { return util.isDate(a) ? compareNSB(a.getTime(), b.getTime()) : 1; }\n\n  // Arrays (first element is most significant and so on)\n  if (util.isArray(a)) { return util.isArray(b) ? compareArrays(a, b) : -1; }\n  if (util.isArray(b)) { return util.isArray(a) ? compareArrays(a, b) : 1; }\n\n  // Objects\n  aKeys = Object.keys(a).sort();\n  bKeys = Object.keys(b).sort();\n\n  for (i = 0; i < Math.min(aKeys.length, bKeys.length); i += 1) {\n    comp = compareThings(a[aKeys[i]], b[bKeys[i]]);\n\n    if (comp !== 0) { return comp; }\n  }\n\n  return compareNSB(aKeys.length, bKeys.length);\n}\n\n\n\n// ==============================================================\n// Updating documents\n// ==============================================================\n\n/**\n * The signature of modifier functions is as follows\n * Their structure is always the same: recursively follow the dot notation while creating\n * the nested documents if needed, then apply the \"last step modifier\"\n * @param {Object} obj The model to modify\n * @param {String} field Can contain dots, in that case that means we will set a subfield recursively\n * @param {Model} value\n */\n\n/**\n * Set a field to a new value\n */\nlastStepModifierFunctions.$set = function (obj, field, value) {\n  obj[field] = value;\n};\n\n\n/**\n * Unset a field\n */\nlastStepModifierFunctions.$unset = function (obj, field, value) {\n  delete obj[field];\n};\n\n\n/**\n * Push an element to the end of an array field\n * Optional modifier $each instead of value to push several values\n * Optional modifier $slice to slice the resulting array, see https://docs.mongodb.org/manual/reference/operator/update/slice/\n * Différeence with MongoDB: if $slice is specified and not $each, we act as if value is an empty array\n */\nlastStepModifierFunctions.$push = function (obj, field, value) {\n  // Create the array if it doesn't exist\n  if (!obj.hasOwnProperty(field)) { obj[field] = []; }\n\n  if (!util.isArray(obj[field])) { throw new Error(\"Can't $push an element on non-array values\"); }\n\n  if (value !== null && typeof value === 'object' && value.$slice && value.$each === undefined) {\n    value.$each = [];\n  }\n\n  if (value !== null && typeof value === 'object' && value.$each) {\n    if (Object.keys(value).length >= 3 || (Object.keys(value).length === 2 && value.$slice === undefined)) { throw new Error(\"Can only use $slice in cunjunction with $each when $push to array\"); }\n    if (!util.isArray(value.$each)) { throw new Error(\"$each requires an array value\"); }\n\n    value.$each.forEach(function (v) {\n      obj[field].push(v);\n    });\n\n    if (value.$slice === undefined || typeof value.$slice !== 'number') { return; }\n\n    if (value.$slice === 0) {\n      obj[field] = [];\n    } else {\n      var start, end, n = obj[field].length;\n      if (value.$slice < 0) {\n        start = Math.max(0, n + value.$slice);\n        end = n;\n      } else if (value.$slice > 0) {\n        start = 0;\n        end = Math.min(n, value.$slice);\n      }\n      obj[field] = obj[field].slice(start, end);\n    }\n  } else {\n    obj[field].push(value);\n  }\n};\n\n\n/**\n * Add an element to an array field only if it is not already in it\n * No modification if the element is already in the array\n * Note that it doesn't check whether the original array contains duplicates\n */\nlastStepModifierFunctions.$addToSet = function (obj, field, value) {\n  var addToSet = true;\n\n  // Create the array if it doesn't exist\n  if (!obj.hasOwnProperty(field)) { obj[field] = []; }\n\n  if (!util.isArray(obj[field])) { throw new Error(\"Can't $addToSet an element on non-array values\"); }\n\n  if (value !== null && typeof value === 'object' && value.$each) {\n    if (Object.keys(value).length > 1) { throw new Error(\"Can't use another field in conjunction with $each\"); }\n    if (!util.isArray(value.$each)) { throw new Error(\"$each requires an array value\"); }\n\n    value.$each.forEach(function (v) {\n      lastStepModifierFunctions.$addToSet(obj, field, v);\n    });\n  } else {\n    obj[field].forEach(function (v) {\n      if (compareThings(v, value) === 0) { addToSet = false; }\n    });\n    if (addToSet) { obj[field].push(value); }\n  }\n};\n\n\n/**\n * Remove the first or last element of an array\n */\nlastStepModifierFunctions.$pop = function (obj, field, value) {\n  if (!util.isArray(obj[field])) { throw new Error(\"Can't $pop an element from non-array values\"); }\n  if (typeof value !== 'number') { throw new Error(value + \" isn't an integer, can't use it with $pop\"); }\n  if (value === 0) { return; }\n\n  if (value > 0) {\n    obj[field] = obj[field].slice(0, obj[field].length - 1);\n  } else {\n    obj[field] = obj[field].slice(1);\n  }\n};\n\n\n/**\n * Removes all instances of a value from an existing array\n */\nlastStepModifierFunctions.$pull = function (obj, field, value) {\n  var arr, i;\n\n  if (!util.isArray(obj[field])) { throw new Error(\"Can't $pull an element from non-array values\"); }\n\n  arr = obj[field];\n  for (i = arr.length - 1; i >= 0; i -= 1) {\n    if (match(arr[i], value)) {\n      arr.splice(i, 1);\n    }\n  }\n};\n\n\n/**\n * Increment a numeric field's value\n */\nlastStepModifierFunctions.$inc = function (obj, field, value) {\n  if (typeof value !== 'number') { throw new Error(value + \" must be a number\"); }\n\n  if (typeof obj[field] !== 'number') {\n    if (!_.has(obj, field)) {\n      obj[field] = value;\n    } else {\n      throw new Error(\"Don't use the $inc modifier on non-number fields\");\n    }\n  } else {\n    obj[field] += value;\n  }\n};\n\n/**\n * Updates the value of the field, only if specified field is greater than the current value of the field\n */\nlastStepModifierFunctions.$max = function (obj, field, value) {\n  if (typeof obj[field] === 'undefined') {\n    obj[field] = value;\n  } else if (value > obj[field]) {\n    obj[field] = value;\n  }\n};\n\n/**\n * Updates the value of the field, only if specified field is smaller than the current value of the field\n */\nlastStepModifierFunctions.$min = function (obj, field, value) {\n  if (typeof obj[field] === 'undefined') { \n    obj[field] = value;\n  } else if (value < obj[field]) {\n    obj[field] = value;\n  }\n};\n\n// Given its name, create the complete modifier function\nfunction createModifierFunction (modifier) {\n  return function (obj, field, value) {\n    var fieldParts = typeof field === 'string' ? field.split('.') : field;\n\n    if (fieldParts.length === 1) {\n      lastStepModifierFunctions[modifier](obj, field, value);\n    } else {\n      if (obj[fieldParts[0]] === undefined) {\n        if (modifier === '$unset') { return; }   // Bad looking specific fix, needs to be generalized modifiers that behave like $unset are implemented\n        obj[fieldParts[0]] = {};\n      }\n      modifierFunctions[modifier](obj[fieldParts[0]], fieldParts.slice(1), value);\n    }\n  };\n}\n\n// Actually create all modifier functions\nObject.keys(lastStepModifierFunctions).forEach(function (modifier) {\n  modifierFunctions[modifier] = createModifierFunction(modifier);\n});\n\n\n/**\n * Modify a DB object according to an update query\n */\nfunction modify (obj, updateQuery) {\n  var keys = Object.keys(updateQuery)\n    , firstChars = _.map(keys, function (item) { return item[0]; })\n    , dollarFirstChars = _.filter(firstChars, function (c) { return c === '$'; })\n    , newDoc, modifiers\n    ;\n\n  if (keys.indexOf('_id') !== -1 && updateQuery._id !== obj._id) { throw new Error(\"You cannot change a document's _id\"); }\n\n  if (dollarFirstChars.length !== 0 && dollarFirstChars.length !== firstChars.length) {\n    throw new Error(\"You cannot mix modifiers and normal fields\");\n  }\n\n  if (dollarFirstChars.length === 0) {\n    // Simply replace the object with the update query contents\n    newDoc = deepCopy(updateQuery);\n    newDoc._id = obj._id;\n  } else {\n    // Apply modifiers\n    modifiers = _.uniq(keys);\n    newDoc = deepCopy(obj);\n    modifiers.forEach(function (m) {\n      var keys;\n\n      if (!modifierFunctions[m]) { throw new Error(\"Unknown modifier \" + m); }\n\n      // Can't rely on Object.keys throwing on non objects since ES6\n      // Not 100% satisfying as non objects can be interpreted as objects but no false negatives so we can live with it\n      if (typeof updateQuery[m] !== 'object') {\n        throw new Error(\"Modifier \" + m + \"'s argument must be an object\");\n      }\n\n      keys = Object.keys(updateQuery[m]);\n      keys.forEach(function (k) {\n        modifierFunctions[m](newDoc, k, updateQuery[m][k]);\n      });\n    });\n  }\n\n  // Check result is valid and return it\n  checkObject(newDoc);\n\n  if (obj._id !== newDoc._id) { throw new Error(\"You can't change a document's _id\"); }\n  return newDoc;\n};\n\n\n// ==============================================================\n// Finding documents\n// ==============================================================\n\n/**\n * Get a value from object with dot notation\n * @param {Object} obj\n * @param {String} field\n */\nfunction getDotValue (obj, field) {\n  var fieldParts = typeof field === 'string' ? field.split('.') : field\n    , i, objs;\n\n  if (!obj) { return undefined; }   // field cannot be empty so that means we should return undefined so that nothing can match\n\n  if (fieldParts.length === 0) { return obj; }\n\n  if (fieldParts.length === 1) { return obj[fieldParts[0]]; }\n\n  if (util.isArray(obj[fieldParts[0]])) {\n    // If the next field is an integer, return only this item of the array\n    i = parseInt(fieldParts[1], 10);\n    if (typeof i === 'number' && !isNaN(i)) {\n      return getDotValue(obj[fieldParts[0]][i], fieldParts.slice(2))\n    }\n\n    // Return the array of values\n    objs = new Array();\n    for (i = 0; i < obj[fieldParts[0]].length; i += 1) {\n       objs.push(getDotValue(obj[fieldParts[0]][i], fieldParts.slice(1)));\n    }\n    return objs;\n  } else {\n    return getDotValue(obj[fieldParts[0]], fieldParts.slice(1));\n  }\n}\n\n\n/**\n * Check whether 'things' are equal\n * Things are defined as any native types (string, number, boolean, null, date) and objects\n * In the case of object, we check deep equality\n * Returns true if they are, false otherwise\n */\nfunction areThingsEqual (a, b) {\n  var aKeys , bKeys , i;\n\n  // Strings, booleans, numbers, null\n  if (a === null || typeof a === 'string' || typeof a === 'boolean' || typeof a === 'number' ||\n      b === null || typeof b === 'string' || typeof b === 'boolean' || typeof b === 'number') { return a === b; }\n\n  // Dates\n  if (util.isDate(a) || util.isDate(b)) { return util.isDate(a) && util.isDate(b) && a.getTime() === b.getTime(); }\n\n  // Arrays (no match since arrays are used as a $in)\n  // undefined (no match since they mean field doesn't exist and can't be serialized)\n  if ((!(util.isArray(a) && util.isArray(b)) && (util.isArray(a) || util.isArray(b))) || a === undefined || b === undefined) { return false; }\n\n  // General objects (check for deep equality)\n  // a and b should be objects at this point\n  try {\n    aKeys = Object.keys(a);\n    bKeys = Object.keys(b);\n  } catch (e) {\n    return false;\n  }\n\n  if (aKeys.length !== bKeys.length) { return false; }\n  for (i = 0; i < aKeys.length; i += 1) {\n    if (bKeys.indexOf(aKeys[i]) === -1) { return false; }\n    if (!areThingsEqual(a[aKeys[i]], b[aKeys[i]])) { return false; }\n  }\n  return true;\n}\n\n\n/**\n * Check that two values are comparable\n */\nfunction areComparable (a, b) {\n  if (typeof a !== 'string' && typeof a !== 'number' && !util.isDate(a) &&\n      typeof b !== 'string' && typeof b !== 'number' && !util.isDate(b)) {\n    return false;\n  }\n\n  if (typeof a !== typeof b) { return false; }\n\n  return true;\n}\n\n\n/**\n * Arithmetic and comparison operators\n * @param {Native value} a Value in the object\n * @param {Native value} b Value in the query\n */\ncomparisonFunctions.$lt = function (a, b) {\n  return areComparable(a, b) && a < b;\n};\n\ncomparisonFunctions.$lte = function (a, b) {\n  return areComparable(a, b) && a <= b;\n};\n\ncomparisonFunctions.$gt = function (a, b) {\n  return areComparable(a, b) && a > b;\n};\n\ncomparisonFunctions.$gte = function (a, b) {\n  return areComparable(a, b) && a >= b;\n};\n\ncomparisonFunctions.$ne = function (a, b) {\n  if (a === undefined) { return true; }\n  return !areThingsEqual(a, b);\n};\n\ncomparisonFunctions.$in = function (a, b) {\n  var i;\n\n  if (!util.isArray(b)) { throw new Error(\"$in operator called with a non-array\"); }\n\n  for (i = 0; i < b.length; i += 1) {\n    if (areThingsEqual(a, b[i])) { return true; }\n  }\n\n  return false;\n};\n\ncomparisonFunctions.$nin = function (a, b) {\n  if (!util.isArray(b)) { throw new Error(\"$nin operator called with a non-array\"); }\n\n  return !comparisonFunctions.$in(a, b);\n};\n\ncomparisonFunctions.$regex = function (a, b) {\n  if (!util.isRegExp(b)) { throw new Error(\"$regex operator called with non regular expression\"); }\n\n  if (typeof a !== 'string') {\n    return false\n  } else {\n    return b.test(a);\n  }\n};\n\ncomparisonFunctions.$exists = function (value, exists) {\n  if (exists || exists === '') {   // This will be true for all values of exists except false, null, undefined and 0\n    exists = true;                 // That's strange behaviour (we should only use true/false) but that's the way Mongo does it...\n  } else {\n    exists = false;\n  }\n\n  if (value === undefined) {\n    return !exists\n  } else {\n    return exists;\n  }\n};\n\n// Specific to arrays\ncomparisonFunctions.$size = function (obj, value) {\n    if (!util.isArray(obj)) { return false; }\n    if (value % 1 !== 0) { throw new Error(\"$size operator called without an integer\"); }\n\n    return (obj.length == value);\n};\ncomparisonFunctions.$elemMatch = function (obj, value) {\n  if (!util.isArray(obj)) { return false; }\n  var i = obj.length;\n  var result = false;   // Initialize result\n  while (i--) {\n    if (match(obj[i], value)) {   // If match for array element, return true\n      result = true;\n      break;\n    }\n  }\n  return result;\n};\narrayComparisonFunctions.$size = true;\narrayComparisonFunctions.$elemMatch = true;\n\n\n/**\n * Match any of the subqueries\n * @param {Model} obj\n * @param {Array of Queries} query\n */\nlogicalOperators.$or = function (obj, query) {\n  var i;\n\n  if (!util.isArray(query)) { throw new Error(\"$or operator used without an array\"); }\n\n  for (i = 0; i < query.length; i += 1) {\n    if (match(obj, query[i])) { return true; }\n  }\n\n  return false;\n};\n\n\n/**\n * Match all of the subqueries\n * @param {Model} obj\n * @param {Array of Queries} query\n */\nlogicalOperators.$and = function (obj, query) {\n  var i;\n\n  if (!util.isArray(query)) { throw new Error(\"$and operator used without an array\"); }\n\n  for (i = 0; i < query.length; i += 1) {\n    if (!match(obj, query[i])) { return false; }\n  }\n\n  return true;\n};\n\n\n/**\n * Inverted match of the query\n * @param {Model} obj\n * @param {Query} query\n */\nlogicalOperators.$not = function (obj, query) {\n  return !match(obj, query);\n};\n\n\n/**\n * Use a function to match\n * @param {Model} obj\n * @param {Query} query\n */\nlogicalOperators.$where = function (obj, fn) {\n  var result;\n\n  if (!_.isFunction(fn)) { throw new Error(\"$where operator used without a function\"); }\n\n  result = fn.call(obj);\n  if (!_.isBoolean(result)) { throw new Error(\"$where function must return boolean\"); }\n\n  return result;\n};\n\n\n/**\n * Tell if a given document matches a query\n * @param {Object} obj Document to check\n * @param {Object} query\n */\nfunction match (obj, query) {\n  var queryKeys, queryKey, queryValue, i;\n\n  // Primitive query against a primitive type\n  // This is a bit of a hack since we construct an object with an arbitrary key only to dereference it later\n  // But I don't have time for a cleaner implementation now\n  if (isPrimitiveType(obj) || isPrimitiveType(query)) {\n    return matchQueryPart({ needAKey: obj }, 'needAKey', query);\n  }\n\n  // Normal query\n  queryKeys = Object.keys(query);\n  for (i = 0; i < queryKeys.length; i += 1) {\n    queryKey = queryKeys[i];\n    queryValue = query[queryKey];\n\n    if (queryKey[0] === '$') {\n      if (!logicalOperators[queryKey]) { throw new Error(\"Unknown logical operator \" + queryKey); }\n      if (!logicalOperators[queryKey](obj, queryValue)) { return false; }\n    } else {\n      if (!matchQueryPart(obj, queryKey, queryValue)) { return false; }\n    }\n  }\n\n  return true;\n};\n\n\n/**\n * Match an object against a specific { key: value } part of a query\n * if the treatObjAsValue flag is set, don't try to match every part separately, but the array as a whole\n */\nfunction matchQueryPart (obj, queryKey, queryValue, treatObjAsValue) {\n  var objValue = getDotValue(obj, queryKey)\n    , i, keys, firstChars, dollarFirstChars;\n\n  // Check if the value is an array if we don't force a treatment as value\n  if (util.isArray(objValue) && !treatObjAsValue) {\n    // If the queryValue is an array, try to perform an exact match\n    if (util.isArray(queryValue)) {\n      return matchQueryPart(obj, queryKey, queryValue, true);\n    }\n\n    // Check if we are using an array-specific comparison function\n    if (queryValue !== null && typeof queryValue === 'object' && !util.isRegExp(queryValue)) {\n      keys = Object.keys(queryValue);\n      for (i = 0; i < keys.length; i += 1) {\n        if (arrayComparisonFunctions[keys[i]]) { return matchQueryPart(obj, queryKey, queryValue, true); }\n      }\n    }\n\n    // If not, treat it as an array of { obj, query } where there needs to be at least one match\n    for (i = 0; i < objValue.length; i += 1) {\n      if (matchQueryPart({ k: objValue[i] }, 'k', queryValue)) { return true; }   // k here could be any string\n    }\n    return false;\n  }\n\n  // queryValue is an actual object. Determine whether it contains comparison operators\n  // or only normal fields. Mixed objects are not allowed\n  if (queryValue !== null && typeof queryValue === 'object' && !util.isRegExp(queryValue) && !util.isArray(queryValue)) {\n    keys = Object.keys(queryValue);\n    firstChars = _.map(keys, function (item) { return item[0]; });\n    dollarFirstChars = _.filter(firstChars, function (c) { return c === '$'; });\n\n    if (dollarFirstChars.length !== 0 && dollarFirstChars.length !== firstChars.length) {\n      throw new Error(\"You cannot mix operators and normal fields\");\n    }\n\n    // queryValue is an object of this form: { $comparisonOperator1: value1, ... }\n    if (dollarFirstChars.length > 0) {\n      for (i = 0; i < keys.length; i += 1) {\n        if (!comparisonFunctions[keys[i]]) { throw new Error(\"Unknown comparison function \" + keys[i]); }\n\n        if (!comparisonFunctions[keys[i]](objValue, queryValue[keys[i]])) { return false; }\n      }\n      return true;\n    }\n  }\n\n  // Using regular expressions with basic querying\n  if (util.isRegExp(queryValue)) { return comparisonFunctions.$regex(objValue, queryValue); }\n\n  // queryValue is either a native value or a normal object\n  // Basic matching is possible\n  if (!areThingsEqual(objValue, queryValue)) { return false; }\n\n  return true;\n}\n\n\n// Interface\nmodule.exports.serialize = serialize;\nmodule.exports.deserialize = deserialize;\nmodule.exports.deepCopy = deepCopy;\nmodule.exports.checkObject = checkObject;\nmodule.exports.isPrimitiveType = isPrimitiveType;\nmodule.exports.modify = modify;\nmodule.exports.getDotValue = getDotValue;\nmodule.exports.match = match;\nmodule.exports.areThingsEqual = areThingsEqual;\nmodule.exports.compareThings = compareThings;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9uZWRiL2xpYi9tb2RlbC5qcz9lMWU1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogSGFuZGxlIG1vZGVscyAoaS5lLiBkb2NzKVxuICogU2VyaWFsaXphdGlvbi9kZXNlcmlhbGl6YXRpb25cbiAqIENvcHlpbmdcbiAqIFF1ZXJ5aW5nLCB1cGRhdGVcbiAqL1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKVxuICAsIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJylcbiAgLCBtb2RpZmllckZ1bmN0aW9ucyA9IHt9XG4gICwgbGFzdFN0ZXBNb2RpZmllckZ1bmN0aW9ucyA9IHt9XG4gICwgY29tcGFyaXNvbkZ1bmN0aW9ucyA9IHt9XG4gICwgbG9naWNhbE9wZXJhdG9ycyA9IHt9XG4gICwgYXJyYXlDb21wYXJpc29uRnVuY3Rpb25zID0ge31cbiAgO1xuXG5cbi8qKlxuICogQ2hlY2sgYSBrZXksIHRocm93IGFuIGVycm9yIGlmIHRoZSBrZXkgaXMgbm9uIHZhbGlkXG4gKiBAcGFyYW0ge1N0cmluZ30gayBrZXlcbiAqIEBwYXJhbSB7TW9kZWx9IHYgdmFsdWUsIG5lZWRlZCB0byB0cmVhdCB0aGUgRGF0ZSBlZGdlIGNhc2VcbiAqIE5vbi10cmVhdGFibGUgZWRnZSBjYXNlcyBoZXJlOiBpZiBwYXJ0IG9mIHRoZSBvYmplY3QgaWYgb2YgdGhlIGZvcm0geyAkJGRhdGU6IG51bWJlciB9IG9yIHsgJCRkZWxldGVkOiB0cnVlIH1cbiAqIEl0cyBzZXJpYWxpemVkLXRoZW4tZGVzZXJpYWxpemVkIHZlcnNpb24gaXQgd2lsbCB0cmFuc2Zvcm1lZCBpbnRvIGEgRGF0ZSBvYmplY3RcbiAqIEJ1dCB5b3UgcmVhbGx5IG5lZWQgdG8gd2FudCBpdCB0byB0cmlnZ2VyIHN1Y2ggYmVoYXZpb3VyLCBldmVuIHdoZW4gd2FybmVkIG5vdCB0byB1c2UgJyQnIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGZpZWxkIG5hbWVzLi4uXG4gKi9cbmZ1bmN0aW9uIGNoZWNrS2V5IChrLCB2KSB7XG4gIGlmICh0eXBlb2YgayA9PT0gJ251bWJlcicpIHtcbiAgICBrID0gay50b1N0cmluZygpO1xuICB9XG5cbiAgaWYgKGtbMF0gPT09ICckJyAmJiAhKGsgPT09ICckJGRhdGUnICYmIHR5cGVvZiB2ID09PSAnbnVtYmVyJykgJiYgIShrID09PSAnJCRkZWxldGVkJyAmJiB2ID09PSB0cnVlKSAmJiAhKGsgPT09ICckJGluZGV4Q3JlYXRlZCcpICYmICEoayA9PT0gJyQkaW5kZXhSZW1vdmVkJykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZpZWxkIG5hbWVzIGNhbm5vdCBiZWdpbiB3aXRoIHRoZSAkIGNoYXJhY3RlcicpO1xuICB9XG5cbiAgaWYgKGsuaW5kZXhPZignLicpICE9PSAtMSkge1xuICAgIHRocm93IG5ldyBFcnJvcignRmllbGQgbmFtZXMgY2Fubm90IGNvbnRhaW4gYSAuJyk7XG4gIH1cbn1cblxuXG4vKipcbiAqIENoZWNrIGEgREIgb2JqZWN0IGFuZCB0aHJvdyBhbiBlcnJvciBpZiBpdCdzIG5vdCB2YWxpZFxuICogV29ya3MgYnkgYXBwbHlpbmcgdGhlIGFib3ZlIGNoZWNrS2V5IGZ1bmN0aW9uIHRvIGFsbCBmaWVsZHMgcmVjdXJzaXZlbHlcbiAqL1xuZnVuY3Rpb24gY2hlY2tPYmplY3QgKG9iaikge1xuICBpZiAodXRpbC5pc0FycmF5KG9iaikpIHtcbiAgICBvYmouZm9yRWFjaChmdW5jdGlvbiAobykge1xuICAgICAgY2hlY2tPYmplY3Qobyk7XG4gICAgfSk7XG4gIH1cblxuICBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgb2JqICE9PSBudWxsKSB7XG4gICAgT2JqZWN0LmtleXMob2JqKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICBjaGVja0tleShrLCBvYmpba10pO1xuICAgICAgY2hlY2tPYmplY3Qob2JqW2tdKTtcbiAgICB9KTtcbiAgfVxufVxuXG5cbi8qKlxuICogU2VyaWFsaXplIGFuIG9iamVjdCB0byBiZSBwZXJzaXN0ZWQgdG8gYSBvbmUtbGluZSBzdHJpbmdcbiAqIEZvciBzZXJpYWxpemF0aW9uL2Rlc2VyaWFsaXphdGlvbiwgd2UgdXNlIHRoZSBuYXRpdmUgSlNPTiBwYXJzZXIgYW5kIG5vdCBldmFsIG9yIEZ1bmN0aW9uXG4gKiBUaGF0IGdpdmVzIHVzIGxlc3MgZnJlZWRvbSBidXQgZGF0YSBlbnRlcmVkIGluIHRoZSBkYXRhYmFzZSBtYXkgY29tZSBmcm9tIHVzZXJzXG4gKiBzbyBldmFsIGFuZCB0aGUgbGlrZSBhcmUgbm90IHNhZmVcbiAqIEFjY2VwdGVkIHByaW1pdGl2ZSB0eXBlczogTnVtYmVyLCBTdHJpbmcsIEJvb2xlYW4sIERhdGUsIG51bGxcbiAqIEFjY2VwdGVkIHNlY29uZGFyeSB0eXBlczogT2JqZWN0cywgQXJyYXlzXG4gKi9cbmZ1bmN0aW9uIHNlcmlhbGl6ZSAob2JqKSB7XG4gIHZhciByZXM7XG5cbiAgcmVzID0gSlNPTi5zdHJpbmdpZnkob2JqLCBmdW5jdGlvbiAoaywgdikge1xuICAgIGNoZWNrS2V5KGssIHYpO1xuXG4gICAgaWYgKHYgPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gICAgaWYgKHYgPT09IG51bGwpIHsgcmV0dXJuIG51bGw7IH1cblxuICAgIC8vIEhhY2tpc2ggd2F5IG9mIGNoZWNraW5nIGlmIG9iamVjdCBpcyBEYXRlICh0aGlzIHdheSBpdCB3b3JrcyBiZXR3ZWVuIGV4ZWN1dGlvbiBjb250ZXh0cyBpbiBub2RlLXdlYmtpdCkuXG4gICAgLy8gV2UgY2FuJ3QgdXNlIHZhbHVlIGRpcmVjdGx5IGJlY2F1c2UgZm9yIGRhdGVzIGl0IGlzIGFscmVhZHkgc3RyaW5nIGluIHRoaXMgZnVuY3Rpb24gKGRhdGUudG9KU09OIHdhcyBhbHJlYWR5IGNhbGxlZCksIHNvIHdlIHVzZSB0aGlzXG4gICAgaWYgKHR5cGVvZiB0aGlzW2tdLmdldFRpbWUgPT09ICdmdW5jdGlvbicpIHsgcmV0dXJuIHsgJCRkYXRlOiB0aGlzW2tdLmdldFRpbWUoKSB9OyB9XG5cbiAgICByZXR1cm4gdjtcbiAgfSk7XG5cbiAgcmV0dXJuIHJlcztcbn1cblxuXG4vKipcbiAqIEZyb20gYSBvbmUtbGluZSByZXByZXNlbnRhdGlvbiBvZiBhbiBvYmplY3QgZ2VuZXJhdGUgYnkgdGhlIHNlcmlhbGl6ZSBmdW5jdGlvblxuICogUmV0dXJuIHRoZSBvYmplY3QgaXRzZWxmXG4gKi9cbmZ1bmN0aW9uIGRlc2VyaWFsaXplIChyYXdEYXRhKSB7XG4gIHJldHVybiBKU09OLnBhcnNlKHJhd0RhdGEsIGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKGsgPT09ICckJGRhdGUnKSB7IHJldHVybiBuZXcgRGF0ZSh2KTsgfVxuICAgIGlmICh0eXBlb2YgdiA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHYgPT09ICdudW1iZXInIHx8IHR5cGVvZiB2ID09PSAnYm9vbGVhbicgfHwgdiA9PT0gbnVsbCkgeyByZXR1cm4gdjsgfVxuICAgIGlmICh2ICYmIHYuJCRkYXRlKSB7IHJldHVybiB2LiQkZGF0ZTsgfVxuXG4gICAgcmV0dXJuIHY7XG4gIH0pO1xufVxuXG5cbi8qKlxuICogRGVlcCBjb3B5IGEgREIgb2JqZWN0XG4gKiBUaGUgb3B0aW9uYWwgc3RyaWN0S2V5cyBmbGFnIChkZWZhdWx0aW5nIHRvIGZhbHNlKSBpbmRpY2F0ZXMgd2hldGhlciB0byBjb3B5IGV2ZXJ5dGhpbmcgb3Igb25seSBmaWVsZHNcbiAqIHdoZXJlIHRoZSBrZXlzIGFyZSB2YWxpZCwgaS5lLiBkb24ndCBiZWdpbiB3aXRoICQgYW5kIGRvbid0IGNvbnRhaW4gYSAuXG4gKi9cbmZ1bmN0aW9uIGRlZXBDb3B5IChvYmosIHN0cmljdEtleXMpIHtcbiAgdmFyIHJlcztcblxuICBpZiAoIHR5cGVvZiBvYmogPT09ICdib29sZWFuJyB8fFxuICAgICAgIHR5cGVvZiBvYmogPT09ICdudW1iZXInIHx8XG4gICAgICAgdHlwZW9mIG9iaiA9PT0gJ3N0cmluZycgfHxcbiAgICAgICBvYmogPT09IG51bGwgfHxcbiAgICAgICAodXRpbC5pc0RhdGUob2JqKSkgKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIGlmICh1dGlsLmlzQXJyYXkob2JqKSkge1xuICAgIHJlcyA9IFtdO1xuICAgIG9iai5mb3JFYWNoKGZ1bmN0aW9uIChvKSB7IHJlcy5wdXNoKGRlZXBDb3B5KG8sIHN0cmljdEtleXMpKTsgfSk7XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jykge1xuICAgIHJlcyA9IHt9O1xuICAgIE9iamVjdC5rZXlzKG9iaikuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgICAgaWYgKCFzdHJpY3RLZXlzIHx8IChrWzBdICE9PSAnJCcgJiYgay5pbmRleE9mKCcuJykgPT09IC0xKSkge1xuICAgICAgICByZXNba10gPSBkZWVwQ29weShvYmpba10sIHN0cmljdEtleXMpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXM7XG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkOyAgIC8vIEZvciBub3cgZXZlcnl0aGluZyBlbHNlIGlzIHVuZGVmaW5lZC4gV2Ugc2hvdWxkIHByb2JhYmx5IHRocm93IGFuIGVycm9yIGluc3RlYWRcbn1cblxuXG4vKipcbiAqIFRlbGxzIGlmIGFuIG9iamVjdCBpcyBhIHByaW1pdGl2ZSB0eXBlIG9yIGEgXCJyZWFsXCIgb2JqZWN0XG4gKiBBcnJheXMgYXJlIGNvbnNpZGVyZWQgcHJpbWl0aXZlXG4gKi9cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlVHlwZSAob2JqKSB7XG4gIHJldHVybiAoIHR5cGVvZiBvYmogPT09ICdib29sZWFuJyB8fFxuICAgICAgIHR5cGVvZiBvYmogPT09ICdudW1iZXInIHx8XG4gICAgICAgdHlwZW9mIG9iaiA9PT0gJ3N0cmluZycgfHxcbiAgICAgICBvYmogPT09IG51bGwgfHxcbiAgICAgICB1dGlsLmlzRGF0ZShvYmopIHx8XG4gICAgICAgdXRpbC5pc0FycmF5KG9iaikpO1xufVxuXG5cbi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbnMgZm9yIGNvbXBhcmluZyB0aGluZ3NcbiAqIEFzc3VtZXMgdHlwZSBjaGVja2luZyB3YXMgYWxyZWFkeSBkb25lIChhIGFuZCBiIGFscmVhZHkgaGF2ZSB0aGUgc2FtZSB0eXBlKVxuICogY29tcGFyZU5TQiB3b3JrcyBmb3IgbnVtYmVycywgc3RyaW5ncyBhbmQgYm9vbGVhbnNcbiAqL1xuZnVuY3Rpb24gY29tcGFyZU5TQiAoYSwgYikge1xuICBpZiAoYSA8IGIpIHsgcmV0dXJuIC0xOyB9XG4gIGlmIChhID4gYikgeyByZXR1cm4gMTsgfVxuICByZXR1cm4gMDtcbn1cblxuZnVuY3Rpb24gY29tcGFyZUFycmF5cyAoYSwgYikge1xuICB2YXIgaSwgY29tcDtcblxuICBmb3IgKGkgPSAwOyBpIDwgTWF0aC5taW4oYS5sZW5ndGgsIGIubGVuZ3RoKTsgaSArPSAxKSB7XG4gICAgY29tcCA9IGNvbXBhcmVUaGluZ3MoYVtpXSwgYltpXSk7XG5cbiAgICBpZiAoY29tcCAhPT0gMCkgeyByZXR1cm4gY29tcDsgfVxuICB9XG5cbiAgLy8gQ29tbW9uIHNlY3Rpb24gd2FzIGlkZW50aWNhbCwgbG9uZ2VzdCBvbmUgd2luc1xuICByZXR1cm4gY29tcGFyZU5TQihhLmxlbmd0aCwgYi5sZW5ndGgpO1xufVxuXG5cbi8qKlxuICogQ29tcGFyZSB7IHRoaW5ncyBVIHVuZGVmaW5lZCB9XG4gKiBUaGluZ3MgYXJlIGRlZmluZWQgYXMgYW55IG5hdGl2ZSB0eXBlcyAoc3RyaW5nLCBudW1iZXIsIGJvb2xlYW4sIG51bGwsIGRhdGUpIGFuZCBvYmplY3RzXG4gKiBXZSBuZWVkIHRvIGNvbXBhcmUgd2l0aCB1bmRlZmluZWQgYXMgaXQgd2lsbCBiZSB1c2VkIGluIGluZGV4ZXNcbiAqIEluIHRoZSBjYXNlIG9mIG9iamVjdHMgYW5kIGFycmF5cywgd2UgZGVlcC1jb21wYXJlXG4gKiBJZiB0d28gb2JqZWN0cyBkb250IGhhdmUgdGhlIHNhbWUgdHlwZSwgdGhlIChhcmJpdHJhcnkpIHR5cGUgaGllcmFyY2h5IGlzOiB1bmRlZmluZWQsIG51bGwsIG51bWJlciwgc3RyaW5ncywgYm9vbGVhbiwgZGF0ZXMsIGFycmF5cywgb2JqZWN0c1xuICogUmV0dXJuIC0xIGlmIGEgPCBiLCAxIGlmIGEgPiBiIGFuZCAwIGlmIGEgPSBiIChub3RlIHRoYXQgZXF1YWxpdHkgaGVyZSBpcyBOT1QgdGhlIHNhbWUgYXMgZGVmaW5lZCBpbiBhcmVUaGluZ3NFcXVhbCEpXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gX2NvbXBhcmVTdHJpbmdzIFN0cmluZyBjb21wYXJpbmcgZnVuY3Rpb24sIHJldHVybmluZyAtMSwgMCBvciAxLCBvdmVycmlkaW5nIGRlZmF1bHQgc3RyaW5nIGNvbXBhcmlzb24gKHVzZWZ1bCBmb3IgbGFuZ3VhZ2VzIHdpdGggYWNjZW50ZWQgbGV0dGVycylcbiAqL1xuZnVuY3Rpb24gY29tcGFyZVRoaW5ncyAoYSwgYiwgX2NvbXBhcmVTdHJpbmdzKSB7XG4gIHZhciBhS2V5cywgYktleXMsIGNvbXAsIGlcbiAgICAsIGNvbXBhcmVTdHJpbmdzID0gX2NvbXBhcmVTdHJpbmdzIHx8IGNvbXBhcmVOU0I7XG5cbiAgLy8gdW5kZWZpbmVkXG4gIGlmIChhID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIGIgPT09IHVuZGVmaW5lZCA/IDAgOiAtMTsgfVxuICBpZiAoYiA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiBhID09PSB1bmRlZmluZWQgPyAwIDogMTsgfVxuXG4gIC8vIG51bGxcbiAgaWYgKGEgPT09IG51bGwpIHsgcmV0dXJuIGIgPT09IG51bGwgPyAwIDogLTE7IH1cbiAgaWYgKGIgPT09IG51bGwpIHsgcmV0dXJuIGEgPT09IG51bGwgPyAwIDogMTsgfVxuXG4gIC8vIE51bWJlcnNcbiAgaWYgKHR5cGVvZiBhID09PSAnbnVtYmVyJykgeyByZXR1cm4gdHlwZW9mIGIgPT09ICdudW1iZXInID8gY29tcGFyZU5TQihhLCBiKSA6IC0xOyB9XG4gIGlmICh0eXBlb2YgYiA9PT0gJ251bWJlcicpIHsgcmV0dXJuIHR5cGVvZiBhID09PSAnbnVtYmVyJyA/IGNvbXBhcmVOU0IoYSwgYikgOiAxOyB9XG5cbiAgLy8gU3RyaW5nc1xuICBpZiAodHlwZW9mIGEgPT09ICdzdHJpbmcnKSB7IHJldHVybiB0eXBlb2YgYiA9PT0gJ3N0cmluZycgPyBjb21wYXJlU3RyaW5ncyhhLCBiKSA6IC0xOyB9XG4gIGlmICh0eXBlb2YgYiA9PT0gJ3N0cmluZycpIHsgcmV0dXJuIHR5cGVvZiBhID09PSAnc3RyaW5nJyA/IGNvbXBhcmVTdHJpbmdzKGEsIGIpIDogMTsgfVxuXG4gIC8vIEJvb2xlYW5zXG4gIGlmICh0eXBlb2YgYSA9PT0gJ2Jvb2xlYW4nKSB7IHJldHVybiB0eXBlb2YgYiA9PT0gJ2Jvb2xlYW4nID8gY29tcGFyZU5TQihhLCBiKSA6IC0xOyB9XG4gIGlmICh0eXBlb2YgYiA9PT0gJ2Jvb2xlYW4nKSB7IHJldHVybiB0eXBlb2YgYSA9PT0gJ2Jvb2xlYW4nID8gY29tcGFyZU5TQihhLCBiKSA6IDE7IH1cblxuICAvLyBEYXRlc1xuICBpZiAodXRpbC5pc0RhdGUoYSkpIHsgcmV0dXJuIHV0aWwuaXNEYXRlKGIpID8gY29tcGFyZU5TQihhLmdldFRpbWUoKSwgYi5nZXRUaW1lKCkpIDogLTE7IH1cbiAgaWYgKHV0aWwuaXNEYXRlKGIpKSB7IHJldHVybiB1dGlsLmlzRGF0ZShhKSA/IGNvbXBhcmVOU0IoYS5nZXRUaW1lKCksIGIuZ2V0VGltZSgpKSA6IDE7IH1cblxuICAvLyBBcnJheXMgKGZpcnN0IGVsZW1lbnQgaXMgbW9zdCBzaWduaWZpY2FudCBhbmQgc28gb24pXG4gIGlmICh1dGlsLmlzQXJyYXkoYSkpIHsgcmV0dXJuIHV0aWwuaXNBcnJheShiKSA/IGNvbXBhcmVBcnJheXMoYSwgYikgOiAtMTsgfVxuICBpZiAodXRpbC5pc0FycmF5KGIpKSB7IHJldHVybiB1dGlsLmlzQXJyYXkoYSkgPyBjb21wYXJlQXJyYXlzKGEsIGIpIDogMTsgfVxuXG4gIC8vIE9iamVjdHNcbiAgYUtleXMgPSBPYmplY3Qua2V5cyhhKS5zb3J0KCk7XG4gIGJLZXlzID0gT2JqZWN0LmtleXMoYikuc29ydCgpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBNYXRoLm1pbihhS2V5cy5sZW5ndGgsIGJLZXlzLmxlbmd0aCk7IGkgKz0gMSkge1xuICAgIGNvbXAgPSBjb21wYXJlVGhpbmdzKGFbYUtleXNbaV1dLCBiW2JLZXlzW2ldXSk7XG5cbiAgICBpZiAoY29tcCAhPT0gMCkgeyByZXR1cm4gY29tcDsgfVxuICB9XG5cbiAgcmV0dXJuIGNvbXBhcmVOU0IoYUtleXMubGVuZ3RoLCBiS2V5cy5sZW5ndGgpO1xufVxuXG5cblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIFVwZGF0aW5nIGRvY3VtZW50c1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuLyoqXG4gKiBUaGUgc2lnbmF0dXJlIG9mIG1vZGlmaWVyIGZ1bmN0aW9ucyBpcyBhcyBmb2xsb3dzXG4gKiBUaGVpciBzdHJ1Y3R1cmUgaXMgYWx3YXlzIHRoZSBzYW1lOiByZWN1cnNpdmVseSBmb2xsb3cgdGhlIGRvdCBub3RhdGlvbiB3aGlsZSBjcmVhdGluZ1xuICogdGhlIG5lc3RlZCBkb2N1bWVudHMgaWYgbmVlZGVkLCB0aGVuIGFwcGx5IHRoZSBcImxhc3Qgc3RlcCBtb2RpZmllclwiXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBtb2RlbCB0byBtb2RpZnlcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaWVsZCBDYW4gY29udGFpbiBkb3RzLCBpbiB0aGF0IGNhc2UgdGhhdCBtZWFucyB3ZSB3aWxsIHNldCBhIHN1YmZpZWxkIHJlY3Vyc2l2ZWx5XG4gKiBAcGFyYW0ge01vZGVsfSB2YWx1ZVxuICovXG5cbi8qKlxuICogU2V0IGEgZmllbGQgdG8gYSBuZXcgdmFsdWVcbiAqL1xubGFzdFN0ZXBNb2RpZmllckZ1bmN0aW9ucy4kc2V0ID0gZnVuY3Rpb24gKG9iaiwgZmllbGQsIHZhbHVlKSB7XG4gIG9ialtmaWVsZF0gPSB2YWx1ZTtcbn07XG5cblxuLyoqXG4gKiBVbnNldCBhIGZpZWxkXG4gKi9cbmxhc3RTdGVwTW9kaWZpZXJGdW5jdGlvbnMuJHVuc2V0ID0gZnVuY3Rpb24gKG9iaiwgZmllbGQsIHZhbHVlKSB7XG4gIGRlbGV0ZSBvYmpbZmllbGRdO1xufTtcblxuXG4vKipcbiAqIFB1c2ggYW4gZWxlbWVudCB0byB0aGUgZW5kIG9mIGFuIGFycmF5IGZpZWxkXG4gKiBPcHRpb25hbCBtb2RpZmllciAkZWFjaCBpbnN0ZWFkIG9mIHZhbHVlIHRvIHB1c2ggc2V2ZXJhbCB2YWx1ZXNcbiAqIE9wdGlvbmFsIG1vZGlmaWVyICRzbGljZSB0byBzbGljZSB0aGUgcmVzdWx0aW5nIGFycmF5LCBzZWUgaHR0cHM6Ly9kb2NzLm1vbmdvZGIub3JnL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3IvdXBkYXRlL3NsaWNlL1xuICogRGlmZsOpcmVlbmNlIHdpdGggTW9uZ29EQjogaWYgJHNsaWNlIGlzIHNwZWNpZmllZCBhbmQgbm90ICRlYWNoLCB3ZSBhY3QgYXMgaWYgdmFsdWUgaXMgYW4gZW1wdHkgYXJyYXlcbiAqL1xubGFzdFN0ZXBNb2RpZmllckZ1bmN0aW9ucy4kcHVzaCA9IGZ1bmN0aW9uIChvYmosIGZpZWxkLCB2YWx1ZSkge1xuICAvLyBDcmVhdGUgdGhlIGFycmF5IGlmIGl0IGRvZXNuJ3QgZXhpc3RcbiAgaWYgKCFvYmouaGFzT3duUHJvcGVydHkoZmllbGQpKSB7IG9ialtmaWVsZF0gPSBbXTsgfVxuXG4gIGlmICghdXRpbC5pc0FycmF5KG9ialtmaWVsZF0pKSB7IHRocm93IG5ldyBFcnJvcihcIkNhbid0ICRwdXNoIGFuIGVsZW1lbnQgb24gbm9uLWFycmF5IHZhbHVlc1wiKTsgfVxuXG4gIGlmICh2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlLiRzbGljZSAmJiB2YWx1ZS4kZWFjaCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdmFsdWUuJGVhY2ggPSBbXTtcbiAgfVxuXG4gIGlmICh2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlLiRlYWNoKSB7XG4gICAgaWYgKE9iamVjdC5rZXlzKHZhbHVlKS5sZW5ndGggPj0gMyB8fCAoT2JqZWN0LmtleXModmFsdWUpLmxlbmd0aCA9PT0gMiAmJiB2YWx1ZS4kc2xpY2UgPT09IHVuZGVmaW5lZCkpIHsgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG9ubHkgdXNlICRzbGljZSBpbiBjdW5qdW5jdGlvbiB3aXRoICRlYWNoIHdoZW4gJHB1c2ggdG8gYXJyYXlcIik7IH1cbiAgICBpZiAoIXV0aWwuaXNBcnJheSh2YWx1ZS4kZWFjaCkpIHsgdGhyb3cgbmV3IEVycm9yKFwiJGVhY2ggcmVxdWlyZXMgYW4gYXJyYXkgdmFsdWVcIik7IH1cblxuICAgIHZhbHVlLiRlYWNoLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcbiAgICAgIG9ialtmaWVsZF0ucHVzaCh2KTtcbiAgICB9KTtcblxuICAgIGlmICh2YWx1ZS4kc2xpY2UgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdmFsdWUuJHNsaWNlICE9PSAnbnVtYmVyJykgeyByZXR1cm47IH1cblxuICAgIGlmICh2YWx1ZS4kc2xpY2UgPT09IDApIHtcbiAgICAgIG9ialtmaWVsZF0gPSBbXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHN0YXJ0LCBlbmQsIG4gPSBvYmpbZmllbGRdLmxlbmd0aDtcbiAgICAgIGlmICh2YWx1ZS4kc2xpY2UgPCAwKSB7XG4gICAgICAgIHN0YXJ0ID0gTWF0aC5tYXgoMCwgbiArIHZhbHVlLiRzbGljZSk7XG4gICAgICAgIGVuZCA9IG47XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlLiRzbGljZSA+IDApIHtcbiAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgICBlbmQgPSBNYXRoLm1pbihuLCB2YWx1ZS4kc2xpY2UpO1xuICAgICAgfVxuICAgICAgb2JqW2ZpZWxkXSA9IG9ialtmaWVsZF0uc2xpY2Uoc3RhcnQsIGVuZCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG9ialtmaWVsZF0ucHVzaCh2YWx1ZSk7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBBZGQgYW4gZWxlbWVudCB0byBhbiBhcnJheSBmaWVsZCBvbmx5IGlmIGl0IGlzIG5vdCBhbHJlYWR5IGluIGl0XG4gKiBObyBtb2RpZmljYXRpb24gaWYgdGhlIGVsZW1lbnQgaXMgYWxyZWFkeSBpbiB0aGUgYXJyYXlcbiAqIE5vdGUgdGhhdCBpdCBkb2Vzbid0IGNoZWNrIHdoZXRoZXIgdGhlIG9yaWdpbmFsIGFycmF5IGNvbnRhaW5zIGR1cGxpY2F0ZXNcbiAqL1xubGFzdFN0ZXBNb2RpZmllckZ1bmN0aW9ucy4kYWRkVG9TZXQgPSBmdW5jdGlvbiAob2JqLCBmaWVsZCwgdmFsdWUpIHtcbiAgdmFyIGFkZFRvU2V0ID0gdHJ1ZTtcblxuICAvLyBDcmVhdGUgdGhlIGFycmF5IGlmIGl0IGRvZXNuJ3QgZXhpc3RcbiAgaWYgKCFvYmouaGFzT3duUHJvcGVydHkoZmllbGQpKSB7IG9ialtmaWVsZF0gPSBbXTsgfVxuXG4gIGlmICghdXRpbC5pc0FycmF5KG9ialtmaWVsZF0pKSB7IHRocm93IG5ldyBFcnJvcihcIkNhbid0ICRhZGRUb1NldCBhbiBlbGVtZW50IG9uIG5vbi1hcnJheSB2YWx1ZXNcIik7IH1cblxuICBpZiAodmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZS4kZWFjaCkge1xuICAgIGlmIChPYmplY3Qua2V5cyh2YWx1ZSkubGVuZ3RoID4gMSkgeyB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCB1c2UgYW5vdGhlciBmaWVsZCBpbiBjb25qdW5jdGlvbiB3aXRoICRlYWNoXCIpOyB9XG4gICAgaWYgKCF1dGlsLmlzQXJyYXkodmFsdWUuJGVhY2gpKSB7IHRocm93IG5ldyBFcnJvcihcIiRlYWNoIHJlcXVpcmVzIGFuIGFycmF5IHZhbHVlXCIpOyB9XG5cbiAgICB2YWx1ZS4kZWFjaC5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7XG4gICAgICBsYXN0U3RlcE1vZGlmaWVyRnVuY3Rpb25zLiRhZGRUb1NldChvYmosIGZpZWxkLCB2KTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpbZmllbGRdLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcbiAgICAgIGlmIChjb21wYXJlVGhpbmdzKHYsIHZhbHVlKSA9PT0gMCkgeyBhZGRUb1NldCA9IGZhbHNlOyB9XG4gICAgfSk7XG4gICAgaWYgKGFkZFRvU2V0KSB7IG9ialtmaWVsZF0ucHVzaCh2YWx1ZSk7IH1cbiAgfVxufTtcblxuXG4vKipcbiAqIFJlbW92ZSB0aGUgZmlyc3Qgb3IgbGFzdCBlbGVtZW50IG9mIGFuIGFycmF5XG4gKi9cbmxhc3RTdGVwTW9kaWZpZXJGdW5jdGlvbnMuJHBvcCA9IGZ1bmN0aW9uIChvYmosIGZpZWxkLCB2YWx1ZSkge1xuICBpZiAoIXV0aWwuaXNBcnJheShvYmpbZmllbGRdKSkgeyB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCAkcG9wIGFuIGVsZW1lbnQgZnJvbSBub24tYXJyYXkgdmFsdWVzXCIpOyB9XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInKSB7IHRocm93IG5ldyBFcnJvcih2YWx1ZSArIFwiIGlzbid0IGFuIGludGVnZXIsIGNhbid0IHVzZSBpdCB3aXRoICRwb3BcIik7IH1cbiAgaWYgKHZhbHVlID09PSAwKSB7IHJldHVybjsgfVxuXG4gIGlmICh2YWx1ZSA+IDApIHtcbiAgICBvYmpbZmllbGRdID0gb2JqW2ZpZWxkXS5zbGljZSgwLCBvYmpbZmllbGRdLmxlbmd0aCAtIDEpO1xuICB9IGVsc2Uge1xuICAgIG9ialtmaWVsZF0gPSBvYmpbZmllbGRdLnNsaWNlKDEpO1xuICB9XG59O1xuXG5cbi8qKlxuICogUmVtb3ZlcyBhbGwgaW5zdGFuY2VzIG9mIGEgdmFsdWUgZnJvbSBhbiBleGlzdGluZyBhcnJheVxuICovXG5sYXN0U3RlcE1vZGlmaWVyRnVuY3Rpb25zLiRwdWxsID0gZnVuY3Rpb24gKG9iaiwgZmllbGQsIHZhbHVlKSB7XG4gIHZhciBhcnIsIGk7XG5cbiAgaWYgKCF1dGlsLmlzQXJyYXkob2JqW2ZpZWxkXSkpIHsgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgJHB1bGwgYW4gZWxlbWVudCBmcm9tIG5vbi1hcnJheSB2YWx1ZXNcIik7IH1cblxuICBhcnIgPSBvYmpbZmllbGRdO1xuICBmb3IgKGkgPSBhcnIubGVuZ3RoIC0gMTsgaSA+PSAwOyBpIC09IDEpIHtcbiAgICBpZiAobWF0Y2goYXJyW2ldLCB2YWx1ZSkpIHtcbiAgICAgIGFyci5zcGxpY2UoaSwgMSk7XG4gICAgfVxuICB9XG59O1xuXG5cbi8qKlxuICogSW5jcmVtZW50IGEgbnVtZXJpYyBmaWVsZCdzIHZhbHVlXG4gKi9cbmxhc3RTdGVwTW9kaWZpZXJGdW5jdGlvbnMuJGluYyA9IGZ1bmN0aW9uIChvYmosIGZpZWxkLCB2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJykgeyB0aHJvdyBuZXcgRXJyb3IodmFsdWUgKyBcIiBtdXN0IGJlIGEgbnVtYmVyXCIpOyB9XG5cbiAgaWYgKHR5cGVvZiBvYmpbZmllbGRdICE9PSAnbnVtYmVyJykge1xuICAgIGlmICghXy5oYXMob2JqLCBmaWVsZCkpIHtcbiAgICAgIG9ialtmaWVsZF0gPSB2YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRG9uJ3QgdXNlIHRoZSAkaW5jIG1vZGlmaWVyIG9uIG5vbi1udW1iZXIgZmllbGRzXCIpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBvYmpbZmllbGRdICs9IHZhbHVlO1xuICB9XG59O1xuXG4vKipcbiAqIFVwZGF0ZXMgdGhlIHZhbHVlIG9mIHRoZSBmaWVsZCwgb25seSBpZiBzcGVjaWZpZWQgZmllbGQgaXMgZ3JlYXRlciB0aGFuIHRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSBmaWVsZFxuICovXG5sYXN0U3RlcE1vZGlmaWVyRnVuY3Rpb25zLiRtYXggPSBmdW5jdGlvbiAob2JqLCBmaWVsZCwgdmFsdWUpIHtcbiAgaWYgKHR5cGVvZiBvYmpbZmllbGRdID09PSAndW5kZWZpbmVkJykge1xuICAgIG9ialtmaWVsZF0gPSB2YWx1ZTtcbiAgfSBlbHNlIGlmICh2YWx1ZSA+IG9ialtmaWVsZF0pIHtcbiAgICBvYmpbZmllbGRdID0gdmFsdWU7XG4gIH1cbn07XG5cbi8qKlxuICogVXBkYXRlcyB0aGUgdmFsdWUgb2YgdGhlIGZpZWxkLCBvbmx5IGlmIHNwZWNpZmllZCBmaWVsZCBpcyBzbWFsbGVyIHRoYW4gdGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhlIGZpZWxkXG4gKi9cbmxhc3RTdGVwTW9kaWZpZXJGdW5jdGlvbnMuJG1pbiA9IGZ1bmN0aW9uIChvYmosIGZpZWxkLCB2YWx1ZSkge1xuICBpZiAodHlwZW9mIG9ialtmaWVsZF0gPT09ICd1bmRlZmluZWQnKSB7wqBcbiAgICBvYmpbZmllbGRdID0gdmFsdWU7XG4gIH0gZWxzZSBpZiAodmFsdWUgPCBvYmpbZmllbGRdKSB7XG4gICAgb2JqW2ZpZWxkXSA9IHZhbHVlO1xuICB9XG59O1xuXG4vLyBHaXZlbiBpdHMgbmFtZSwgY3JlYXRlIHRoZSBjb21wbGV0ZSBtb2RpZmllciBmdW5jdGlvblxuZnVuY3Rpb24gY3JlYXRlTW9kaWZpZXJGdW5jdGlvbiAobW9kaWZpZXIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChvYmosIGZpZWxkLCB2YWx1ZSkge1xuICAgIHZhciBmaWVsZFBhcnRzID0gdHlwZW9mIGZpZWxkID09PSAnc3RyaW5nJyA/IGZpZWxkLnNwbGl0KCcuJykgOiBmaWVsZDtcblxuICAgIGlmIChmaWVsZFBhcnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgbGFzdFN0ZXBNb2RpZmllckZ1bmN0aW9uc1ttb2RpZmllcl0ob2JqLCBmaWVsZCwgdmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAob2JqW2ZpZWxkUGFydHNbMF1dID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKG1vZGlmaWVyID09PSAnJHVuc2V0JykgeyByZXR1cm47IH0gICAvLyBCYWQgbG9va2luZyBzcGVjaWZpYyBmaXgsIG5lZWRzIHRvIGJlIGdlbmVyYWxpemVkIG1vZGlmaWVycyB0aGF0IGJlaGF2ZSBsaWtlICR1bnNldCBhcmUgaW1wbGVtZW50ZWRcbiAgICAgICAgb2JqW2ZpZWxkUGFydHNbMF1dID0ge307XG4gICAgICB9XG4gICAgICBtb2RpZmllckZ1bmN0aW9uc1ttb2RpZmllcl0ob2JqW2ZpZWxkUGFydHNbMF1dLCBmaWVsZFBhcnRzLnNsaWNlKDEpLCB2YWx1ZSk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBBY3R1YWxseSBjcmVhdGUgYWxsIG1vZGlmaWVyIGZ1bmN0aW9uc1xuT2JqZWN0LmtleXMobGFzdFN0ZXBNb2RpZmllckZ1bmN0aW9ucykuZm9yRWFjaChmdW5jdGlvbiAobW9kaWZpZXIpIHtcbiAgbW9kaWZpZXJGdW5jdGlvbnNbbW9kaWZpZXJdID0gY3JlYXRlTW9kaWZpZXJGdW5jdGlvbihtb2RpZmllcik7XG59KTtcblxuXG4vKipcbiAqIE1vZGlmeSBhIERCIG9iamVjdCBhY2NvcmRpbmcgdG8gYW4gdXBkYXRlIHF1ZXJ5XG4gKi9cbmZ1bmN0aW9uIG1vZGlmeSAob2JqLCB1cGRhdGVRdWVyeSkge1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHVwZGF0ZVF1ZXJ5KVxuICAgICwgZmlyc3RDaGFycyA9IF8ubWFwKGtleXMsIGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiBpdGVtWzBdOyB9KVxuICAgICwgZG9sbGFyRmlyc3RDaGFycyA9IF8uZmlsdGVyKGZpcnN0Q2hhcnMsIGZ1bmN0aW9uIChjKSB7IHJldHVybiBjID09PSAnJCc7IH0pXG4gICAgLCBuZXdEb2MsIG1vZGlmaWVyc1xuICAgIDtcblxuICBpZiAoa2V5cy5pbmRleE9mKCdfaWQnKSAhPT0gLTEgJiYgdXBkYXRlUXVlcnkuX2lkICE9PSBvYmouX2lkKSB7IHRocm93IG5ldyBFcnJvcihcIllvdSBjYW5ub3QgY2hhbmdlIGEgZG9jdW1lbnQncyBfaWRcIik7IH1cblxuICBpZiAoZG9sbGFyRmlyc3RDaGFycy5sZW5ndGggIT09IDAgJiYgZG9sbGFyRmlyc3RDaGFycy5sZW5ndGggIT09IGZpcnN0Q2hhcnMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiWW91IGNhbm5vdCBtaXggbW9kaWZpZXJzIGFuZCBub3JtYWwgZmllbGRzXCIpO1xuICB9XG5cbiAgaWYgKGRvbGxhckZpcnN0Q2hhcnMubGVuZ3RoID09PSAwKSB7XG4gICAgLy8gU2ltcGx5IHJlcGxhY2UgdGhlIG9iamVjdCB3aXRoIHRoZSB1cGRhdGUgcXVlcnkgY29udGVudHNcbiAgICBuZXdEb2MgPSBkZWVwQ29weSh1cGRhdGVRdWVyeSk7XG4gICAgbmV3RG9jLl9pZCA9IG9iai5faWQ7XG4gIH0gZWxzZSB7XG4gICAgLy8gQXBwbHkgbW9kaWZpZXJzXG4gICAgbW9kaWZpZXJzID0gXy51bmlxKGtleXMpO1xuICAgIG5ld0RvYyA9IGRlZXBDb3B5KG9iaik7XG4gICAgbW9kaWZpZXJzLmZvckVhY2goZnVuY3Rpb24gKG0pIHtcbiAgICAgIHZhciBrZXlzO1xuXG4gICAgICBpZiAoIW1vZGlmaWVyRnVuY3Rpb25zW21dKSB7IHRocm93IG5ldyBFcnJvcihcIlVua25vd24gbW9kaWZpZXIgXCIgKyBtKTsgfVxuXG4gICAgICAvLyBDYW4ndCByZWx5IG9uIE9iamVjdC5rZXlzIHRocm93aW5nIG9uIG5vbiBvYmplY3RzIHNpbmNlIEVTNlxuICAgICAgLy8gTm90IDEwMCUgc2F0aXNmeWluZyBhcyBub24gb2JqZWN0cyBjYW4gYmUgaW50ZXJwcmV0ZWQgYXMgb2JqZWN0cyBidXQgbm8gZmFsc2UgbmVnYXRpdmVzIHNvIHdlIGNhbiBsaXZlIHdpdGggaXRcbiAgICAgIGlmICh0eXBlb2YgdXBkYXRlUXVlcnlbbV0gIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1vZGlmaWVyIFwiICsgbSArIFwiJ3MgYXJndW1lbnQgbXVzdCBiZSBhbiBvYmplY3RcIik7XG4gICAgICB9XG5cbiAgICAgIGtleXMgPSBPYmplY3Qua2V5cyh1cGRhdGVRdWVyeVttXSk7XG4gICAgICBrZXlzLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICAgICAgbW9kaWZpZXJGdW5jdGlvbnNbbV0obmV3RG9jLCBrLCB1cGRhdGVRdWVyeVttXVtrXSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIENoZWNrIHJlc3VsdCBpcyB2YWxpZCBhbmQgcmV0dXJuIGl0XG4gIGNoZWNrT2JqZWN0KG5ld0RvYyk7XG5cbiAgaWYgKG9iai5faWQgIT09IG5ld0RvYy5faWQpIHsgdGhyb3cgbmV3IEVycm9yKFwiWW91IGNhbid0IGNoYW5nZSBhIGRvY3VtZW50J3MgX2lkXCIpOyB9XG4gIHJldHVybiBuZXdEb2M7XG59O1xuXG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBGaW5kaW5nIGRvY3VtZW50c1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuLyoqXG4gKiBHZXQgYSB2YWx1ZSBmcm9tIG9iamVjdCB3aXRoIGRvdCBub3RhdGlvblxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHBhcmFtIHtTdHJpbmd9IGZpZWxkXG4gKi9cbmZ1bmN0aW9uIGdldERvdFZhbHVlIChvYmosIGZpZWxkKSB7XG4gIHZhciBmaWVsZFBhcnRzID0gdHlwZW9mIGZpZWxkID09PSAnc3RyaW5nJyA/IGZpZWxkLnNwbGl0KCcuJykgOiBmaWVsZFxuICAgICwgaSwgb2JqcztcblxuICBpZiAoIW9iaikgeyByZXR1cm4gdW5kZWZpbmVkOyB9ICAgLy8gZmllbGQgY2Fubm90IGJlIGVtcHR5IHNvIHRoYXQgbWVhbnMgd2Ugc2hvdWxkIHJldHVybiB1bmRlZmluZWQgc28gdGhhdCBub3RoaW5nIGNhbiBtYXRjaFxuXG4gIGlmIChmaWVsZFBhcnRzLmxlbmd0aCA9PT0gMCkgeyByZXR1cm4gb2JqOyB9XG5cbiAgaWYgKGZpZWxkUGFydHMubGVuZ3RoID09PSAxKSB7IHJldHVybiBvYmpbZmllbGRQYXJ0c1swXV07IH1cblxuICBpZiAodXRpbC5pc0FycmF5KG9ialtmaWVsZFBhcnRzWzBdXSkpIHtcbiAgICAvLyBJZiB0aGUgbmV4dCBmaWVsZCBpcyBhbiBpbnRlZ2VyLCByZXR1cm4gb25seSB0aGlzIGl0ZW0gb2YgdGhlIGFycmF5XG4gICAgaSA9IHBhcnNlSW50KGZpZWxkUGFydHNbMV0sIDEwKTtcbiAgICBpZiAodHlwZW9mIGkgPT09ICdudW1iZXInICYmICFpc05hTihpKSkge1xuICAgICAgcmV0dXJuIGdldERvdFZhbHVlKG9ialtmaWVsZFBhcnRzWzBdXVtpXSwgZmllbGRQYXJ0cy5zbGljZSgyKSlcbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gdGhlIGFycmF5IG9mIHZhbHVlc1xuICAgIG9ianMgPSBuZXcgQXJyYXkoKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgb2JqW2ZpZWxkUGFydHNbMF1dLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgb2Jqcy5wdXNoKGdldERvdFZhbHVlKG9ialtmaWVsZFBhcnRzWzBdXVtpXSwgZmllbGRQYXJ0cy5zbGljZSgxKSkpO1xuICAgIH1cbiAgICByZXR1cm4gb2JqcztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZ2V0RG90VmFsdWUob2JqW2ZpZWxkUGFydHNbMF1dLCBmaWVsZFBhcnRzLnNsaWNlKDEpKTtcbiAgfVxufVxuXG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciAndGhpbmdzJyBhcmUgZXF1YWxcbiAqIFRoaW5ncyBhcmUgZGVmaW5lZCBhcyBhbnkgbmF0aXZlIHR5cGVzIChzdHJpbmcsIG51bWJlciwgYm9vbGVhbiwgbnVsbCwgZGF0ZSkgYW5kIG9iamVjdHNcbiAqIEluIHRoZSBjYXNlIG9mIG9iamVjdCwgd2UgY2hlY2sgZGVlcCBlcXVhbGl0eVxuICogUmV0dXJucyB0cnVlIGlmIHRoZXkgYXJlLCBmYWxzZSBvdGhlcndpc2VcbiAqL1xuZnVuY3Rpb24gYXJlVGhpbmdzRXF1YWwgKGEsIGIpIHtcbiAgdmFyIGFLZXlzICwgYktleXMgLCBpO1xuXG4gIC8vIFN0cmluZ3MsIGJvb2xlYW5zLCBudW1iZXJzLCBudWxsXG4gIGlmIChhID09PSBudWxsIHx8IHR5cGVvZiBhID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgYSA9PT0gJ2Jvb2xlYW4nIHx8IHR5cGVvZiBhID09PSAnbnVtYmVyJyB8fFxuICAgICAgYiA9PT0gbnVsbCB8fCB0eXBlb2YgYiA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGIgPT09ICdib29sZWFuJyB8fCB0eXBlb2YgYiA9PT0gJ251bWJlcicpIHsgcmV0dXJuIGEgPT09IGI7IH1cblxuICAvLyBEYXRlc1xuICBpZiAodXRpbC5pc0RhdGUoYSkgfHwgdXRpbC5pc0RhdGUoYikpIHsgcmV0dXJuIHV0aWwuaXNEYXRlKGEpICYmIHV0aWwuaXNEYXRlKGIpICYmIGEuZ2V0VGltZSgpID09PSBiLmdldFRpbWUoKTsgfVxuXG4gIC8vIEFycmF5cyAobm8gbWF0Y2ggc2luY2UgYXJyYXlzIGFyZSB1c2VkIGFzIGEgJGluKVxuICAvLyB1bmRlZmluZWQgKG5vIG1hdGNoIHNpbmNlIHRoZXkgbWVhbiBmaWVsZCBkb2Vzbid0IGV4aXN0IGFuZCBjYW4ndCBiZSBzZXJpYWxpemVkKVxuICBpZiAoKCEodXRpbC5pc0FycmF5KGEpICYmIHV0aWwuaXNBcnJheShiKSkgJiYgKHV0aWwuaXNBcnJheShhKSB8fCB1dGlsLmlzQXJyYXkoYikpKSB8fCBhID09PSB1bmRlZmluZWQgfHwgYiA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIC8vIEdlbmVyYWwgb2JqZWN0cyAoY2hlY2sgZm9yIGRlZXAgZXF1YWxpdHkpXG4gIC8vIGEgYW5kIGIgc2hvdWxkIGJlIG9iamVjdHMgYXQgdGhpcyBwb2ludFxuICB0cnkge1xuICAgIGFLZXlzID0gT2JqZWN0LmtleXMoYSk7XG4gICAgYktleXMgPSBPYmplY3Qua2V5cyhiKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChhS2V5cy5sZW5ndGggIT09IGJLZXlzLmxlbmd0aCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgZm9yIChpID0gMDsgaSA8IGFLZXlzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgaWYgKGJLZXlzLmluZGV4T2YoYUtleXNbaV0pID09PSAtMSkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBpZiAoIWFyZVRoaW5nc0VxdWFsKGFbYUtleXNbaV1dLCBiW2FLZXlzW2ldXSkpIHsgcmV0dXJuIGZhbHNlOyB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cblxuLyoqXG4gKiBDaGVjayB0aGF0IHR3byB2YWx1ZXMgYXJlIGNvbXBhcmFibGVcbiAqL1xuZnVuY3Rpb24gYXJlQ29tcGFyYWJsZSAoYSwgYikge1xuICBpZiAodHlwZW9mIGEgIT09ICdzdHJpbmcnICYmIHR5cGVvZiBhICE9PSAnbnVtYmVyJyAmJiAhdXRpbC5pc0RhdGUoYSkgJiZcbiAgICAgIHR5cGVvZiBiICE9PSAnc3RyaW5nJyAmJiB0eXBlb2YgYiAhPT0gJ251bWJlcicgJiYgIXV0aWwuaXNEYXRlKGIpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBhICE9PSB0eXBlb2YgYikgeyByZXR1cm4gZmFsc2U7IH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuXG4vKipcbiAqIEFyaXRobWV0aWMgYW5kIGNvbXBhcmlzb24gb3BlcmF0b3JzXG4gKiBAcGFyYW0ge05hdGl2ZSB2YWx1ZX0gYSBWYWx1ZSBpbiB0aGUgb2JqZWN0XG4gKiBAcGFyYW0ge05hdGl2ZSB2YWx1ZX0gYiBWYWx1ZSBpbiB0aGUgcXVlcnlcbiAqL1xuY29tcGFyaXNvbkZ1bmN0aW9ucy4kbHQgPSBmdW5jdGlvbiAoYSwgYikge1xuICByZXR1cm4gYXJlQ29tcGFyYWJsZShhLCBiKSAmJiBhIDwgYjtcbn07XG5cbmNvbXBhcmlzb25GdW5jdGlvbnMuJGx0ZSA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gIHJldHVybiBhcmVDb21wYXJhYmxlKGEsIGIpICYmIGEgPD0gYjtcbn07XG5cbmNvbXBhcmlzb25GdW5jdGlvbnMuJGd0ID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgcmV0dXJuIGFyZUNvbXBhcmFibGUoYSwgYikgJiYgYSA+IGI7XG59O1xuXG5jb21wYXJpc29uRnVuY3Rpb25zLiRndGUgPSBmdW5jdGlvbiAoYSwgYikge1xuICByZXR1cm4gYXJlQ29tcGFyYWJsZShhLCBiKSAmJiBhID49IGI7XG59O1xuXG5jb21wYXJpc29uRnVuY3Rpb25zLiRuZSA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gIGlmIChhID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHRydWU7IH1cbiAgcmV0dXJuICFhcmVUaGluZ3NFcXVhbChhLCBiKTtcbn07XG5cbmNvbXBhcmlzb25GdW5jdGlvbnMuJGluID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgdmFyIGk7XG5cbiAgaWYgKCF1dGlsLmlzQXJyYXkoYikpIHsgdGhyb3cgbmV3IEVycm9yKFwiJGluIG9wZXJhdG9yIGNhbGxlZCB3aXRoIGEgbm9uLWFycmF5XCIpOyB9XG5cbiAgZm9yIChpID0gMDsgaSA8IGIubGVuZ3RoOyBpICs9IDEpIHtcbiAgICBpZiAoYXJlVGhpbmdzRXF1YWwoYSwgYltpXSkpIHsgcmV0dXJuIHRydWU7IH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn07XG5cbmNvbXBhcmlzb25GdW5jdGlvbnMuJG5pbiA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gIGlmICghdXRpbC5pc0FycmF5KGIpKSB7IHRocm93IG5ldyBFcnJvcihcIiRuaW4gb3BlcmF0b3IgY2FsbGVkIHdpdGggYSBub24tYXJyYXlcIik7IH1cblxuICByZXR1cm4gIWNvbXBhcmlzb25GdW5jdGlvbnMuJGluKGEsIGIpO1xufTtcblxuY29tcGFyaXNvbkZ1bmN0aW9ucy4kcmVnZXggPSBmdW5jdGlvbiAoYSwgYikge1xuICBpZiAoIXV0aWwuaXNSZWdFeHAoYikpIHsgdGhyb3cgbmV3IEVycm9yKFwiJHJlZ2V4IG9wZXJhdG9yIGNhbGxlZCB3aXRoIG5vbiByZWd1bGFyIGV4cHJlc3Npb25cIik7IH1cblxuICBpZiAodHlwZW9mIGEgIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGIudGVzdChhKTtcbiAgfVxufTtcblxuY29tcGFyaXNvbkZ1bmN0aW9ucy4kZXhpc3RzID0gZnVuY3Rpb24gKHZhbHVlLCBleGlzdHMpIHtcbiAgaWYgKGV4aXN0cyB8fCBleGlzdHMgPT09ICcnKSB7ICAgLy8gVGhpcyB3aWxsIGJlIHRydWUgZm9yIGFsbCB2YWx1ZXMgb2YgZXhpc3RzIGV4Y2VwdCBmYWxzZSwgbnVsbCwgdW5kZWZpbmVkIGFuZCAwXG4gICAgZXhpc3RzID0gdHJ1ZTsgICAgICAgICAgICAgICAgIC8vIFRoYXQncyBzdHJhbmdlIGJlaGF2aW91ciAod2Ugc2hvdWxkIG9ubHkgdXNlIHRydWUvZmFsc2UpIGJ1dCB0aGF0J3MgdGhlIHdheSBNb25nbyBkb2VzIGl0Li4uXG4gIH0gZWxzZSB7XG4gICAgZXhpc3RzID0gZmFsc2U7XG4gIH1cblxuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiAhZXhpc3RzXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGV4aXN0cztcbiAgfVxufTtcblxuLy8gU3BlY2lmaWMgdG8gYXJyYXlzXG5jb21wYXJpc29uRnVuY3Rpb25zLiRzaXplID0gZnVuY3Rpb24gKG9iaiwgdmFsdWUpIHtcbiAgICBpZiAoIXV0aWwuaXNBcnJheShvYmopKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGlmICh2YWx1ZSAlIDEgIT09IDApIHsgdGhyb3cgbmV3IEVycm9yKFwiJHNpemUgb3BlcmF0b3IgY2FsbGVkIHdpdGhvdXQgYW4gaW50ZWdlclwiKTsgfVxuXG4gICAgcmV0dXJuIChvYmoubGVuZ3RoID09IHZhbHVlKTtcbn07XG5jb21wYXJpc29uRnVuY3Rpb25zLiRlbGVtTWF0Y2ggPSBmdW5jdGlvbiAob2JqLCB2YWx1ZSkge1xuICBpZiAoIXV0aWwuaXNBcnJheShvYmopKSB7IHJldHVybiBmYWxzZTsgfVxuICB2YXIgaSA9IG9iai5sZW5ndGg7XG4gIHZhciByZXN1bHQgPSBmYWxzZTsgICAvLyBJbml0aWFsaXplIHJlc3VsdFxuICB3aGlsZSAoaS0tKSB7XG4gICAgaWYgKG1hdGNoKG9ialtpXSwgdmFsdWUpKSB7ICAgLy8gSWYgbWF0Y2ggZm9yIGFycmF5IGVsZW1lbnQsIHJldHVybiB0cnVlXG4gICAgICByZXN1bHQgPSB0cnVlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuYXJyYXlDb21wYXJpc29uRnVuY3Rpb25zLiRzaXplID0gdHJ1ZTtcbmFycmF5Q29tcGFyaXNvbkZ1bmN0aW9ucy4kZWxlbU1hdGNoID0gdHJ1ZTtcblxuXG4vKipcbiAqIE1hdGNoIGFueSBvZiB0aGUgc3VicXVlcmllc1xuICogQHBhcmFtIHtNb2RlbH0gb2JqXG4gKiBAcGFyYW0ge0FycmF5IG9mIFF1ZXJpZXN9IHF1ZXJ5XG4gKi9cbmxvZ2ljYWxPcGVyYXRvcnMuJG9yID0gZnVuY3Rpb24gKG9iaiwgcXVlcnkpIHtcbiAgdmFyIGk7XG5cbiAgaWYgKCF1dGlsLmlzQXJyYXkocXVlcnkpKSB7IHRocm93IG5ldyBFcnJvcihcIiRvciBvcGVyYXRvciB1c2VkIHdpdGhvdXQgYW4gYXJyYXlcIik7IH1cblxuICBmb3IgKGkgPSAwOyBpIDwgcXVlcnkubGVuZ3RoOyBpICs9IDEpIHtcbiAgICBpZiAobWF0Y2gob2JqLCBxdWVyeVtpXSkpIHsgcmV0dXJuIHRydWU7IH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn07XG5cblxuLyoqXG4gKiBNYXRjaCBhbGwgb2YgdGhlIHN1YnF1ZXJpZXNcbiAqIEBwYXJhbSB7TW9kZWx9IG9ialxuICogQHBhcmFtIHtBcnJheSBvZiBRdWVyaWVzfSBxdWVyeVxuICovXG5sb2dpY2FsT3BlcmF0b3JzLiRhbmQgPSBmdW5jdGlvbiAob2JqLCBxdWVyeSkge1xuICB2YXIgaTtcblxuICBpZiAoIXV0aWwuaXNBcnJheShxdWVyeSkpIHsgdGhyb3cgbmV3IEVycm9yKFwiJGFuZCBvcGVyYXRvciB1c2VkIHdpdGhvdXQgYW4gYXJyYXlcIik7IH1cblxuICBmb3IgKGkgPSAwOyBpIDwgcXVlcnkubGVuZ3RoOyBpICs9IDEpIHtcbiAgICBpZiAoIW1hdGNoKG9iaiwgcXVlcnlbaV0pKSB7IHJldHVybiBmYWxzZTsgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cbi8qKlxuICogSW52ZXJ0ZWQgbWF0Y2ggb2YgdGhlIHF1ZXJ5XG4gKiBAcGFyYW0ge01vZGVsfSBvYmpcbiAqIEBwYXJhbSB7UXVlcnl9IHF1ZXJ5XG4gKi9cbmxvZ2ljYWxPcGVyYXRvcnMuJG5vdCA9IGZ1bmN0aW9uIChvYmosIHF1ZXJ5KSB7XG4gIHJldHVybiAhbWF0Y2gob2JqLCBxdWVyeSk7XG59O1xuXG5cbi8qKlxuICogVXNlIGEgZnVuY3Rpb24gdG8gbWF0Y2hcbiAqIEBwYXJhbSB7TW9kZWx9IG9ialxuICogQHBhcmFtIHtRdWVyeX0gcXVlcnlcbiAqL1xubG9naWNhbE9wZXJhdG9ycy4kd2hlcmUgPSBmdW5jdGlvbiAob2JqLCBmbikge1xuICB2YXIgcmVzdWx0O1xuXG4gIGlmICghXy5pc0Z1bmN0aW9uKGZuKSkgeyB0aHJvdyBuZXcgRXJyb3IoXCIkd2hlcmUgb3BlcmF0b3IgdXNlZCB3aXRob3V0IGEgZnVuY3Rpb25cIik7IH1cblxuICByZXN1bHQgPSBmbi5jYWxsKG9iaik7XG4gIGlmICghXy5pc0Jvb2xlYW4ocmVzdWx0KSkgeyB0aHJvdyBuZXcgRXJyb3IoXCIkd2hlcmUgZnVuY3Rpb24gbXVzdCByZXR1cm4gYm9vbGVhblwiKTsgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cbi8qKlxuICogVGVsbCBpZiBhIGdpdmVuIGRvY3VtZW50IG1hdGNoZXMgYSBxdWVyeVxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBEb2N1bWVudCB0byBjaGVja1xuICogQHBhcmFtIHtPYmplY3R9IHF1ZXJ5XG4gKi9cbmZ1bmN0aW9uIG1hdGNoIChvYmosIHF1ZXJ5KSB7XG4gIHZhciBxdWVyeUtleXMsIHF1ZXJ5S2V5LCBxdWVyeVZhbHVlLCBpO1xuXG4gIC8vIFByaW1pdGl2ZSBxdWVyeSBhZ2FpbnN0IGEgcHJpbWl0aXZlIHR5cGVcbiAgLy8gVGhpcyBpcyBhIGJpdCBvZiBhIGhhY2sgc2luY2Ugd2UgY29uc3RydWN0IGFuIG9iamVjdCB3aXRoIGFuIGFyYml0cmFyeSBrZXkgb25seSB0byBkZXJlZmVyZW5jZSBpdCBsYXRlclxuICAvLyBCdXQgSSBkb24ndCBoYXZlIHRpbWUgZm9yIGEgY2xlYW5lciBpbXBsZW1lbnRhdGlvbiBub3dcbiAgaWYgKGlzUHJpbWl0aXZlVHlwZShvYmopIHx8IGlzUHJpbWl0aXZlVHlwZShxdWVyeSkpIHtcbiAgICByZXR1cm4gbWF0Y2hRdWVyeVBhcnQoeyBuZWVkQUtleTogb2JqIH0sICduZWVkQUtleScsIHF1ZXJ5KTtcbiAgfVxuXG4gIC8vIE5vcm1hbCBxdWVyeVxuICBxdWVyeUtleXMgPSBPYmplY3Qua2V5cyhxdWVyeSk7XG4gIGZvciAoaSA9IDA7IGkgPCBxdWVyeUtleXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICBxdWVyeUtleSA9IHF1ZXJ5S2V5c1tpXTtcbiAgICBxdWVyeVZhbHVlID0gcXVlcnlbcXVlcnlLZXldO1xuXG4gICAgaWYgKHF1ZXJ5S2V5WzBdID09PSAnJCcpIHtcbiAgICAgIGlmICghbG9naWNhbE9wZXJhdG9yc1txdWVyeUtleV0pIHsgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBsb2dpY2FsIG9wZXJhdG9yIFwiICsgcXVlcnlLZXkpOyB9XG4gICAgICBpZiAoIWxvZ2ljYWxPcGVyYXRvcnNbcXVlcnlLZXldKG9iaiwgcXVlcnlWYWx1ZSkpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghbWF0Y2hRdWVyeVBhcnQob2JqLCBxdWVyeUtleSwgcXVlcnlWYWx1ZSkpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cbi8qKlxuICogTWF0Y2ggYW4gb2JqZWN0IGFnYWluc3QgYSBzcGVjaWZpYyB7IGtleTogdmFsdWUgfSBwYXJ0IG9mIGEgcXVlcnlcbiAqIGlmIHRoZSB0cmVhdE9iakFzVmFsdWUgZmxhZyBpcyBzZXQsIGRvbid0IHRyeSB0byBtYXRjaCBldmVyeSBwYXJ0IHNlcGFyYXRlbHksIGJ1dCB0aGUgYXJyYXkgYXMgYSB3aG9sZVxuICovXG5mdW5jdGlvbiBtYXRjaFF1ZXJ5UGFydCAob2JqLCBxdWVyeUtleSwgcXVlcnlWYWx1ZSwgdHJlYXRPYmpBc1ZhbHVlKSB7XG4gIHZhciBvYmpWYWx1ZSA9IGdldERvdFZhbHVlKG9iaiwgcXVlcnlLZXkpXG4gICAgLCBpLCBrZXlzLCBmaXJzdENoYXJzLCBkb2xsYXJGaXJzdENoYXJzO1xuXG4gIC8vIENoZWNrIGlmIHRoZSB2YWx1ZSBpcyBhbiBhcnJheSBpZiB3ZSBkb24ndCBmb3JjZSBhIHRyZWF0bWVudCBhcyB2YWx1ZVxuICBpZiAodXRpbC5pc0FycmF5KG9ialZhbHVlKSAmJiAhdHJlYXRPYmpBc1ZhbHVlKSB7XG4gICAgLy8gSWYgdGhlIHF1ZXJ5VmFsdWUgaXMgYW4gYXJyYXksIHRyeSB0byBwZXJmb3JtIGFuIGV4YWN0IG1hdGNoXG4gICAgaWYgKHV0aWwuaXNBcnJheShxdWVyeVZhbHVlKSkge1xuICAgICAgcmV0dXJuIG1hdGNoUXVlcnlQYXJ0KG9iaiwgcXVlcnlLZXksIHF1ZXJ5VmFsdWUsIHRydWUpO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIHdlIGFyZSB1c2luZyBhbiBhcnJheS1zcGVjaWZpYyBjb21wYXJpc29uIGZ1bmN0aW9uXG4gICAgaWYgKHF1ZXJ5VmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIHF1ZXJ5VmFsdWUgPT09ICdvYmplY3QnICYmICF1dGlsLmlzUmVnRXhwKHF1ZXJ5VmFsdWUpKSB7XG4gICAgICBrZXlzID0gT2JqZWN0LmtleXMocXVlcnlWYWx1ZSk7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBpZiAoYXJyYXlDb21wYXJpc29uRnVuY3Rpb25zW2tleXNbaV1dKSB7IHJldHVybiBtYXRjaFF1ZXJ5UGFydChvYmosIHF1ZXJ5S2V5LCBxdWVyeVZhbHVlLCB0cnVlKTsgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIG5vdCwgdHJlYXQgaXQgYXMgYW4gYXJyYXkgb2YgeyBvYmosIHF1ZXJ5IH0gd2hlcmUgdGhlcmUgbmVlZHMgdG8gYmUgYXQgbGVhc3Qgb25lIG1hdGNoXG4gICAgZm9yIChpID0gMDsgaSA8IG9ialZhbHVlLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBpZiAobWF0Y2hRdWVyeVBhcnQoeyBrOiBvYmpWYWx1ZVtpXSB9LCAnaycsIHF1ZXJ5VmFsdWUpKSB7IHJldHVybiB0cnVlOyB9ICAgLy8gayBoZXJlIGNvdWxkIGJlIGFueSBzdHJpbmdcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gcXVlcnlWYWx1ZSBpcyBhbiBhY3R1YWwgb2JqZWN0LiBEZXRlcm1pbmUgd2hldGhlciBpdCBjb250YWlucyBjb21wYXJpc29uIG9wZXJhdG9yc1xuICAvLyBvciBvbmx5IG5vcm1hbCBmaWVsZHMuIE1peGVkIG9iamVjdHMgYXJlIG5vdCBhbGxvd2VkXG4gIGlmIChxdWVyeVZhbHVlICE9PSBudWxsICYmIHR5cGVvZiBxdWVyeVZhbHVlID09PSAnb2JqZWN0JyAmJiAhdXRpbC5pc1JlZ0V4cChxdWVyeVZhbHVlKSAmJiAhdXRpbC5pc0FycmF5KHF1ZXJ5VmFsdWUpKSB7XG4gICAga2V5cyA9IE9iamVjdC5rZXlzKHF1ZXJ5VmFsdWUpO1xuICAgIGZpcnN0Q2hhcnMgPSBfLm1hcChrZXlzLCBmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gaXRlbVswXTsgfSk7XG4gICAgZG9sbGFyRmlyc3RDaGFycyA9IF8uZmlsdGVyKGZpcnN0Q2hhcnMsIGZ1bmN0aW9uIChjKSB7IHJldHVybiBjID09PSAnJCc7IH0pO1xuXG4gICAgaWYgKGRvbGxhckZpcnN0Q2hhcnMubGVuZ3RoICE9PSAwICYmIGRvbGxhckZpcnN0Q2hhcnMubGVuZ3RoICE9PSBmaXJzdENoYXJzLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWW91IGNhbm5vdCBtaXggb3BlcmF0b3JzIGFuZCBub3JtYWwgZmllbGRzXCIpO1xuICAgIH1cblxuICAgIC8vIHF1ZXJ5VmFsdWUgaXMgYW4gb2JqZWN0IG9mIHRoaXMgZm9ybTogeyAkY29tcGFyaXNvbk9wZXJhdG9yMTogdmFsdWUxLCAuLi4gfVxuICAgIGlmIChkb2xsYXJGaXJzdENoYXJzLmxlbmd0aCA+IDApIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGlmICghY29tcGFyaXNvbkZ1bmN0aW9uc1trZXlzW2ldXSkgeyB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGNvbXBhcmlzb24gZnVuY3Rpb24gXCIgKyBrZXlzW2ldKTsgfVxuXG4gICAgICAgIGlmICghY29tcGFyaXNvbkZ1bmN0aW9uc1trZXlzW2ldXShvYmpWYWx1ZSwgcXVlcnlWYWx1ZVtrZXlzW2ldXSkpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICAvLyBVc2luZyByZWd1bGFyIGV4cHJlc3Npb25zIHdpdGggYmFzaWMgcXVlcnlpbmdcbiAgaWYgKHV0aWwuaXNSZWdFeHAocXVlcnlWYWx1ZSkpIHsgcmV0dXJuIGNvbXBhcmlzb25GdW5jdGlvbnMuJHJlZ2V4KG9ialZhbHVlLCBxdWVyeVZhbHVlKTsgfVxuXG4gIC8vIHF1ZXJ5VmFsdWUgaXMgZWl0aGVyIGEgbmF0aXZlIHZhbHVlIG9yIGEgbm9ybWFsIG9iamVjdFxuICAvLyBCYXNpYyBtYXRjaGluZyBpcyBwb3NzaWJsZVxuICBpZiAoIWFyZVRoaW5nc0VxdWFsKG9ialZhbHVlLCBxdWVyeVZhbHVlKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuXG4vLyBJbnRlcmZhY2Vcbm1vZHVsZS5leHBvcnRzLnNlcmlhbGl6ZSA9IHNlcmlhbGl6ZTtcbm1vZHVsZS5leHBvcnRzLmRlc2VyaWFsaXplID0gZGVzZXJpYWxpemU7XG5tb2R1bGUuZXhwb3J0cy5kZWVwQ29weSA9IGRlZXBDb3B5O1xubW9kdWxlLmV4cG9ydHMuY2hlY2tPYmplY3QgPSBjaGVja09iamVjdDtcbm1vZHVsZS5leHBvcnRzLmlzUHJpbWl0aXZlVHlwZSA9IGlzUHJpbWl0aXZlVHlwZTtcbm1vZHVsZS5leHBvcnRzLm1vZGlmeSA9IG1vZGlmeTtcbm1vZHVsZS5leHBvcnRzLmdldERvdFZhbHVlID0gZ2V0RG90VmFsdWU7XG5tb2R1bGUuZXhwb3J0cy5tYXRjaCA9IG1hdGNoO1xubW9kdWxlLmV4cG9ydHMuYXJlVGhpbmdzRXF1YWwgPSBhcmVUaGluZ3NFcXVhbDtcbm1vZHVsZS5leHBvcnRzLmNvbXBhcmVUaGluZ3MgPSBjb21wYXJlVGhpbmdzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbmVkYi9saWIvbW9kZWwuanNcbi8vIG1vZHVsZSBpZCA9IDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///4\n");

/***/ }),
/* 5 */
/*!***********************!*\
  !*** external "util" ***!
  \***********************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports) {

eval("module.exports = require(\"util\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9leHRlcm5hbCBcInV0aWxcIj83MGM1Il0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInV0aWxcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJ1dGlsXCJcbi8vIG1vZHVsZSBpZCA9IDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///5\n");

/***/ }),
/* 6 */
/*!***********************************************************!*\
  !*** ./node_modules/nedb/node_modules/async/lib/async.js ***!
  \***********************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*global setImmediate: false, setTimeout: false, console: false */\n(function () {\n\n    var async = {};\n\n    // global on the server, window in the browser\n    var root, previous_async;\n\n    root = this;\n    if (root != null) {\n      previous_async = root.async;\n    }\n\n    async.noConflict = function () {\n        root.async = previous_async;\n        return async;\n    };\n\n    function only_once(fn) {\n        var called = false;\n        return function() {\n            if (called) throw new Error(\"Callback was already called.\");\n            called = true;\n            fn.apply(root, arguments);\n        }\n    }\n\n    //// cross-browser compatiblity functions ////\n\n    var _each = function (arr, iterator) {\n        if (arr.forEach) {\n            return arr.forEach(iterator);\n        }\n        for (var i = 0; i < arr.length; i += 1) {\n            iterator(arr[i], i, arr);\n        }\n    };\n\n    var _map = function (arr, iterator) {\n        if (arr.map) {\n            return arr.map(iterator);\n        }\n        var results = [];\n        _each(arr, function (x, i, a) {\n            results.push(iterator(x, i, a));\n        });\n        return results;\n    };\n\n    var _reduce = function (arr, iterator, memo) {\n        if (arr.reduce) {\n            return arr.reduce(iterator, memo);\n        }\n        _each(arr, function (x, i, a) {\n            memo = iterator(memo, x, i, a);\n        });\n        return memo;\n    };\n\n    var _keys = function (obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        }\n        var keys = [];\n        for (var k in obj) {\n            if (obj.hasOwnProperty(k)) {\n                keys.push(k);\n            }\n        }\n        return keys;\n    };\n\n    //// exported async module functions ////\n\n    //// nextTick implementation with browser-compatible fallback ////\n    if (typeof process === 'undefined' || !(process.nextTick)) {\n        if (typeof setImmediate === 'function') {\n            async.nextTick = function (fn) {\n                // not a direct alias for IE10 compatibility\n                setImmediate(fn);\n            };\n            async.setImmediate = async.nextTick;\n        }\n        else {\n            async.nextTick = function (fn) {\n                setTimeout(fn, 0);\n            };\n            async.setImmediate = async.nextTick;\n        }\n    }\n    else {\n        async.nextTick = process.nextTick;\n        if (typeof setImmediate !== 'undefined') {\n            async.setImmediate = function (fn) {\n              // not a direct alias for IE10 compatibility\n              setImmediate(fn);\n            };\n        }\n        else {\n            async.setImmediate = async.nextTick;\n        }\n    }\n\n    async.each = function (arr, iterator, callback) {\n        callback = callback || function () {};\n        if (!arr.length) {\n            return callback();\n        }\n        var completed = 0;\n        _each(arr, function (x) {\n            iterator(x, only_once(function (err) {\n                if (err) {\n                    callback(err);\n                    callback = function () {};\n                }\n                else {\n                    completed += 1;\n                    if (completed >= arr.length) {\n                        callback(null);\n                    }\n                }\n            }));\n        });\n    };\n    async.forEach = async.each;\n\n    async.eachSeries = function (arr, iterator, callback) {\n        callback = callback || function () {};\n        if (!arr.length) {\n            return callback();\n        }\n        var completed = 0;\n        var iterate = function () {\n            iterator(arr[completed], function (err) {\n                if (err) {\n                    callback(err);\n                    callback = function () {};\n                }\n                else {\n                    completed += 1;\n                    if (completed >= arr.length) {\n                        callback(null);\n                    }\n                    else {\n                        iterate();\n                    }\n                }\n            });\n        };\n        iterate();\n    };\n    async.forEachSeries = async.eachSeries;\n\n    async.eachLimit = function (arr, limit, iterator, callback) {\n        var fn = _eachLimit(limit);\n        fn.apply(null, [arr, iterator, callback]);\n    };\n    async.forEachLimit = async.eachLimit;\n\n    var _eachLimit = function (limit) {\n\n        return function (arr, iterator, callback) {\n            callback = callback || function () {};\n            if (!arr.length || limit <= 0) {\n                return callback();\n            }\n            var completed = 0;\n            var started = 0;\n            var running = 0;\n\n            (function replenish () {\n                if (completed >= arr.length) {\n                    return callback();\n                }\n\n                while (running < limit && started < arr.length) {\n                    started += 1;\n                    running += 1;\n                    iterator(arr[started - 1], function (err) {\n                        if (err) {\n                            callback(err);\n                            callback = function () {};\n                        }\n                        else {\n                            completed += 1;\n                            running -= 1;\n                            if (completed >= arr.length) {\n                                callback();\n                            }\n                            else {\n                                replenish();\n                            }\n                        }\n                    });\n                }\n            })();\n        };\n    };\n\n\n    var doParallel = function (fn) {\n        return function () {\n            var args = Array.prototype.slice.call(arguments);\n            return fn.apply(null, [async.each].concat(args));\n        };\n    };\n    var doParallelLimit = function(limit, fn) {\n        return function () {\n            var args = Array.prototype.slice.call(arguments);\n            return fn.apply(null, [_eachLimit(limit)].concat(args));\n        };\n    };\n    var doSeries = function (fn) {\n        return function () {\n            var args = Array.prototype.slice.call(arguments);\n            return fn.apply(null, [async.eachSeries].concat(args));\n        };\n    };\n\n\n    var _asyncMap = function (eachfn, arr, iterator, callback) {\n        var results = [];\n        arr = _map(arr, function (x, i) {\n            return {index: i, value: x};\n        });\n        eachfn(arr, function (x, callback) {\n            iterator(x.value, function (err, v) {\n                results[x.index] = v;\n                callback(err);\n            });\n        }, function (err) {\n            callback(err, results);\n        });\n    };\n    async.map = doParallel(_asyncMap);\n    async.mapSeries = doSeries(_asyncMap);\n    async.mapLimit = function (arr, limit, iterator, callback) {\n        return _mapLimit(limit)(arr, iterator, callback);\n    };\n\n    var _mapLimit = function(limit) {\n        return doParallelLimit(limit, _asyncMap);\n    };\n\n    // reduce only has a series version, as doing reduce in parallel won't\n    // work in many situations.\n    async.reduce = function (arr, memo, iterator, callback) {\n        async.eachSeries(arr, function (x, callback) {\n            iterator(memo, x, function (err, v) {\n                memo = v;\n                callback(err);\n            });\n        }, function (err) {\n            callback(err, memo);\n        });\n    };\n    // inject alias\n    async.inject = async.reduce;\n    // foldl alias\n    async.foldl = async.reduce;\n\n    async.reduceRight = function (arr, memo, iterator, callback) {\n        var reversed = _map(arr, function (x) {\n            return x;\n        }).reverse();\n        async.reduce(reversed, memo, iterator, callback);\n    };\n    // foldr alias\n    async.foldr = async.reduceRight;\n\n    var _filter = function (eachfn, arr, iterator, callback) {\n        var results = [];\n        arr = _map(arr, function (x, i) {\n            return {index: i, value: x};\n        });\n        eachfn(arr, function (x, callback) {\n            iterator(x.value, function (v) {\n                if (v) {\n                    results.push(x);\n                }\n                callback();\n            });\n        }, function (err) {\n            callback(_map(results.sort(function (a, b) {\n                return a.index - b.index;\n            }), function (x) {\n                return x.value;\n            }));\n        });\n    };\n    async.filter = doParallel(_filter);\n    async.filterSeries = doSeries(_filter);\n    // select alias\n    async.select = async.filter;\n    async.selectSeries = async.filterSeries;\n\n    var _reject = function (eachfn, arr, iterator, callback) {\n        var results = [];\n        arr = _map(arr, function (x, i) {\n            return {index: i, value: x};\n        });\n        eachfn(arr, function (x, callback) {\n            iterator(x.value, function (v) {\n                if (!v) {\n                    results.push(x);\n                }\n                callback();\n            });\n        }, function (err) {\n            callback(_map(results.sort(function (a, b) {\n                return a.index - b.index;\n            }), function (x) {\n                return x.value;\n            }));\n        });\n    };\n    async.reject = doParallel(_reject);\n    async.rejectSeries = doSeries(_reject);\n\n    var _detect = function (eachfn, arr, iterator, main_callback) {\n        eachfn(arr, function (x, callback) {\n            iterator(x, function (result) {\n                if (result) {\n                    main_callback(x);\n                    main_callback = function () {};\n                }\n                else {\n                    callback();\n                }\n            });\n        }, function (err) {\n            main_callback();\n        });\n    };\n    async.detect = doParallel(_detect);\n    async.detectSeries = doSeries(_detect);\n\n    async.some = function (arr, iterator, main_callback) {\n        async.each(arr, function (x, callback) {\n            iterator(x, function (v) {\n                if (v) {\n                    main_callback(true);\n                    main_callback = function () {};\n                }\n                callback();\n            });\n        }, function (err) {\n            main_callback(false);\n        });\n    };\n    // any alias\n    async.any = async.some;\n\n    async.every = function (arr, iterator, main_callback) {\n        async.each(arr, function (x, callback) {\n            iterator(x, function (v) {\n                if (!v) {\n                    main_callback(false);\n                    main_callback = function () {};\n                }\n                callback();\n            });\n        }, function (err) {\n            main_callback(true);\n        });\n    };\n    // all alias\n    async.all = async.every;\n\n    async.sortBy = function (arr, iterator, callback) {\n        async.map(arr, function (x, callback) {\n            iterator(x, function (err, criteria) {\n                if (err) {\n                    callback(err);\n                }\n                else {\n                    callback(null, {value: x, criteria: criteria});\n                }\n            });\n        }, function (err, results) {\n            if (err) {\n                return callback(err);\n            }\n            else {\n                var fn = function (left, right) {\n                    var a = left.criteria, b = right.criteria;\n                    return a < b ? -1 : a > b ? 1 : 0;\n                };\n                callback(null, _map(results.sort(fn), function (x) {\n                    return x.value;\n                }));\n            }\n        });\n    };\n\n    async.auto = function (tasks, callback) {\n        callback = callback || function () {};\n        var keys = _keys(tasks);\n        if (!keys.length) {\n            return callback(null);\n        }\n\n        var results = {};\n\n        var listeners = [];\n        var addListener = function (fn) {\n            listeners.unshift(fn);\n        };\n        var removeListener = function (fn) {\n            for (var i = 0; i < listeners.length; i += 1) {\n                if (listeners[i] === fn) {\n                    listeners.splice(i, 1);\n                    return;\n                }\n            }\n        };\n        var taskComplete = function () {\n            _each(listeners.slice(0), function (fn) {\n                fn();\n            });\n        };\n\n        addListener(function () {\n            if (_keys(results).length === keys.length) {\n                callback(null, results);\n                callback = function () {};\n            }\n        });\n\n        _each(keys, function (k) {\n            var task = (tasks[k] instanceof Function) ? [tasks[k]]: tasks[k];\n            var taskCallback = function (err) {\n                var args = Array.prototype.slice.call(arguments, 1);\n                if (args.length <= 1) {\n                    args = args[0];\n                }\n                if (err) {\n                    var safeResults = {};\n                    _each(_keys(results), function(rkey) {\n                        safeResults[rkey] = results[rkey];\n                    });\n                    safeResults[k] = args;\n                    callback(err, safeResults);\n                    // stop subsequent errors hitting callback multiple times\n                    callback = function () {};\n                }\n                else {\n                    results[k] = args;\n                    async.setImmediate(taskComplete);\n                }\n            };\n            var requires = task.slice(0, Math.abs(task.length - 1)) || [];\n            var ready = function () {\n                return _reduce(requires, function (a, x) {\n                    return (a && results.hasOwnProperty(x));\n                }, true) && !results.hasOwnProperty(k);\n            };\n            if (ready()) {\n                task[task.length - 1](taskCallback, results);\n            }\n            else {\n                var listener = function () {\n                    if (ready()) {\n                        removeListener(listener);\n                        task[task.length - 1](taskCallback, results);\n                    }\n                };\n                addListener(listener);\n            }\n        });\n    };\n\n    async.waterfall = function (tasks, callback) {\n        callback = callback || function () {};\n        if (tasks.constructor !== Array) {\n          var err = new Error('First argument to waterfall must be an array of functions');\n          return callback(err);\n        }\n        if (!tasks.length) {\n            return callback();\n        }\n        var wrapIterator = function (iterator) {\n            return function (err) {\n                if (err) {\n                    callback.apply(null, arguments);\n                    callback = function () {};\n                }\n                else {\n                    var args = Array.prototype.slice.call(arguments, 1);\n                    var next = iterator.next();\n                    if (next) {\n                        args.push(wrapIterator(next));\n                    }\n                    else {\n                        args.push(callback);\n                    }\n                    async.setImmediate(function () {\n                        iterator.apply(null, args);\n                    });\n                }\n            };\n        };\n        wrapIterator(async.iterator(tasks))();\n    };\n\n    var _parallel = function(eachfn, tasks, callback) {\n        callback = callback || function () {};\n        if (tasks.constructor === Array) {\n            eachfn.map(tasks, function (fn, callback) {\n                if (fn) {\n                    fn(function (err) {\n                        var args = Array.prototype.slice.call(arguments, 1);\n                        if (args.length <= 1) {\n                            args = args[0];\n                        }\n                        callback.call(null, err, args);\n                    });\n                }\n            }, callback);\n        }\n        else {\n            var results = {};\n            eachfn.each(_keys(tasks), function (k, callback) {\n                tasks[k](function (err) {\n                    var args = Array.prototype.slice.call(arguments, 1);\n                    if (args.length <= 1) {\n                        args = args[0];\n                    }\n                    results[k] = args;\n                    callback(err);\n                });\n            }, function (err) {\n                callback(err, results);\n            });\n        }\n    };\n\n    async.parallel = function (tasks, callback) {\n        _parallel({ map: async.map, each: async.each }, tasks, callback);\n    };\n\n    async.parallelLimit = function(tasks, limit, callback) {\n        _parallel({ map: _mapLimit(limit), each: _eachLimit(limit) }, tasks, callback);\n    };\n\n    async.series = function (tasks, callback) {\n        callback = callback || function () {};\n        if (tasks.constructor === Array) {\n            async.mapSeries(tasks, function (fn, callback) {\n                if (fn) {\n                    fn(function (err) {\n                        var args = Array.prototype.slice.call(arguments, 1);\n                        if (args.length <= 1) {\n                            args = args[0];\n                        }\n                        callback.call(null, err, args);\n                    });\n                }\n            }, callback);\n        }\n        else {\n            var results = {};\n            async.eachSeries(_keys(tasks), function (k, callback) {\n                tasks[k](function (err) {\n                    var args = Array.prototype.slice.call(arguments, 1);\n                    if (args.length <= 1) {\n                        args = args[0];\n                    }\n                    results[k] = args;\n                    callback(err);\n                });\n            }, function (err) {\n                callback(err, results);\n            });\n        }\n    };\n\n    async.iterator = function (tasks) {\n        var makeCallback = function (index) {\n            var fn = function () {\n                if (tasks.length) {\n                    tasks[index].apply(null, arguments);\n                }\n                return fn.next();\n            };\n            fn.next = function () {\n                return (index < tasks.length - 1) ? makeCallback(index + 1): null;\n            };\n            return fn;\n        };\n        return makeCallback(0);\n    };\n\n    async.apply = function (fn) {\n        var args = Array.prototype.slice.call(arguments, 1);\n        return function () {\n            return fn.apply(\n                null, args.concat(Array.prototype.slice.call(arguments))\n            );\n        };\n    };\n\n    var _concat = function (eachfn, arr, fn, callback) {\n        var r = [];\n        eachfn(arr, function (x, cb) {\n            fn(x, function (err, y) {\n                r = r.concat(y || []);\n                cb(err);\n            });\n        }, function (err) {\n            callback(err, r);\n        });\n    };\n    async.concat = doParallel(_concat);\n    async.concatSeries = doSeries(_concat);\n\n    async.whilst = function (test, iterator, callback) {\n        if (test()) {\n            iterator(function (err) {\n                if (err) {\n                    return callback(err);\n                }\n                async.whilst(test, iterator, callback);\n            });\n        }\n        else {\n            callback();\n        }\n    };\n\n    async.doWhilst = function (iterator, test, callback) {\n        iterator(function (err) {\n            if (err) {\n                return callback(err);\n            }\n            if (test()) {\n                async.doWhilst(iterator, test, callback);\n            }\n            else {\n                callback();\n            }\n        });\n    };\n\n    async.until = function (test, iterator, callback) {\n        if (!test()) {\n            iterator(function (err) {\n                if (err) {\n                    return callback(err);\n                }\n                async.until(test, iterator, callback);\n            });\n        }\n        else {\n            callback();\n        }\n    };\n\n    async.doUntil = function (iterator, test, callback) {\n        iterator(function (err) {\n            if (err) {\n                return callback(err);\n            }\n            if (!test()) {\n                async.doUntil(iterator, test, callback);\n            }\n            else {\n                callback();\n            }\n        });\n    };\n\n    async.queue = function (worker, concurrency) {\n        if (concurrency === undefined) {\n            concurrency = 1;\n        }\n        function _insert(q, data, pos, callback) {\n          if(data.constructor !== Array) {\n              data = [data];\n          }\n          _each(data, function(task) {\n              var item = {\n                  data: task,\n                  callback: typeof callback === 'function' ? callback : null\n              };\n\n              if (pos) {\n                q.tasks.unshift(item);\n              } else {\n                q.tasks.push(item);\n              }\n\n              if (q.saturated && q.tasks.length === concurrency) {\n                  q.saturated();\n              }\n              async.setImmediate(q.process);\n          });\n        }\n\n        var workers = 0;\n        var q = {\n            tasks: [],\n            concurrency: concurrency,\n            saturated: null,\n            empty: null,\n            drain: null,\n            push: function (data, callback) {\n              _insert(q, data, false, callback);\n            },\n            unshift: function (data, callback) {\n              _insert(q, data, true, callback);\n            },\n            process: function () {\n                if (workers < q.concurrency && q.tasks.length) {\n                    var task = q.tasks.shift();\n                    if (q.empty && q.tasks.length === 0) {\n                        q.empty();\n                    }\n                    workers += 1;\n                    var next = function () {\n                        workers -= 1;\n                        if (task.callback) {\n                            task.callback.apply(task, arguments);\n                        }\n                        if (q.drain && q.tasks.length + workers === 0) {\n                            q.drain();\n                        }\n                        q.process();\n                    };\n                    var cb = only_once(next);\n                    worker(task.data, cb);\n                }\n            },\n            length: function () {\n                return q.tasks.length;\n            },\n            running: function () {\n                return workers;\n            }\n        };\n        return q;\n    };\n\n    async.cargo = function (worker, payload) {\n        var working     = false,\n            tasks       = [];\n\n        var cargo = {\n            tasks: tasks,\n            payload: payload,\n            saturated: null,\n            empty: null,\n            drain: null,\n            push: function (data, callback) {\n                if(data.constructor !== Array) {\n                    data = [data];\n                }\n                _each(data, function(task) {\n                    tasks.push({\n                        data: task,\n                        callback: typeof callback === 'function' ? callback : null\n                    });\n                    if (cargo.saturated && tasks.length === payload) {\n                        cargo.saturated();\n                    }\n                });\n                async.setImmediate(cargo.process);\n            },\n            process: function process() {\n                if (working) return;\n                if (tasks.length === 0) {\n                    if(cargo.drain) cargo.drain();\n                    return;\n                }\n\n                var ts = typeof payload === 'number'\n                            ? tasks.splice(0, payload)\n                            : tasks.splice(0);\n\n                var ds = _map(ts, function (task) {\n                    return task.data;\n                });\n\n                if(cargo.empty) cargo.empty();\n                working = true;\n                worker(ds, function () {\n                    working = false;\n\n                    var args = arguments;\n                    _each(ts, function (data) {\n                        if (data.callback) {\n                            data.callback.apply(null, args);\n                        }\n                    });\n\n                    process();\n                });\n            },\n            length: function () {\n                return tasks.length;\n            },\n            running: function () {\n                return working;\n            }\n        };\n        return cargo;\n    };\n\n    var _console_fn = function (name) {\n        return function (fn) {\n            var args = Array.prototype.slice.call(arguments, 1);\n            fn.apply(null, args.concat([function (err) {\n                var args = Array.prototype.slice.call(arguments, 1);\n                if (typeof console !== 'undefined') {\n                    if (err) {\n                        if (console.error) {\n                            console.error(err);\n                        }\n                    }\n                    else if (console[name]) {\n                        _each(args, function (x) {\n                            console[name](x);\n                        });\n                    }\n                }\n            }]));\n        };\n    };\n    async.log = _console_fn('log');\n    async.dir = _console_fn('dir');\n    /*async.info = _console_fn('info');\n    async.warn = _console_fn('warn');\n    async.error = _console_fn('error');*/\n\n    async.memoize = function (fn, hasher) {\n        var memo = {};\n        var queues = {};\n        hasher = hasher || function (x) {\n            return x;\n        };\n        var memoized = function () {\n            var args = Array.prototype.slice.call(arguments);\n            var callback = args.pop();\n            var key = hasher.apply(null, args);\n            if (key in memo) {\n                callback.apply(null, memo[key]);\n            }\n            else if (key in queues) {\n                queues[key].push(callback);\n            }\n            else {\n                queues[key] = [callback];\n                fn.apply(null, args.concat([function () {\n                    memo[key] = arguments;\n                    var q = queues[key];\n                    delete queues[key];\n                    for (var i = 0, l = q.length; i < l; i++) {\n                      q[i].apply(null, arguments);\n                    }\n                }]));\n            }\n        };\n        memoized.memo = memo;\n        memoized.unmemoized = fn;\n        return memoized;\n    };\n\n    async.unmemoize = function (fn) {\n      return function () {\n        return (fn.unmemoized || fn).apply(null, arguments);\n      };\n    };\n\n    async.times = function (count, iterator, callback) {\n        var counter = [];\n        for (var i = 0; i < count; i++) {\n            counter.push(i);\n        }\n        return async.map(counter, iterator, callback);\n    };\n\n    async.timesSeries = function (count, iterator, callback) {\n        var counter = [];\n        for (var i = 0; i < count; i++) {\n            counter.push(i);\n        }\n        return async.mapSeries(counter, iterator, callback);\n    };\n\n    async.compose = function (/* functions... */) {\n        var fns = Array.prototype.reverse.call(arguments);\n        return function () {\n            var that = this;\n            var args = Array.prototype.slice.call(arguments);\n            var callback = args.pop();\n            async.reduce(fns, args, function (newargs, fn, cb) {\n                fn.apply(that, newargs.concat([function () {\n                    var err = arguments[0];\n                    var nextargs = Array.prototype.slice.call(arguments, 1);\n                    cb(err, nextargs);\n                }]))\n            },\n            function (err, results) {\n                callback.apply(that, [err].concat(results));\n            });\n        };\n    };\n\n    var _applyEach = function (eachfn, fns /*args...*/) {\n        var go = function () {\n            var that = this;\n            var args = Array.prototype.slice.call(arguments);\n            var callback = args.pop();\n            return eachfn(fns, function (fn, cb) {\n                fn.apply(that, args.concat([cb]));\n            },\n            callback);\n        };\n        if (arguments.length > 2) {\n            var args = Array.prototype.slice.call(arguments, 2);\n            return go.apply(this, args);\n        }\n        else {\n            return go;\n        }\n    };\n    async.applyEach = doParallel(_applyEach);\n    async.applyEachSeries = doSeries(_applyEach);\n\n    async.forever = function (fn, callback) {\n        function next(err) {\n            if (err) {\n                if (callback) {\n                    return callback(err);\n                }\n                throw err;\n            }\n            fn(next);\n        }\n        next();\n    };\n\n    // AMD / RequireJS\n    if (true) {\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n            return async;\n        }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    }\n    // Node.js\n    else if (typeof module !== 'undefined' && module.exports) {\n        module.exports = async;\n    }\n    // included directly via <script> tag\n    else {\n        root.async = async;\n    }\n\n}());\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9uZWRiL25vZGVfbW9kdWxlcy9hc3luYy9saWIvYXN5bmMuanM/YzA3MCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKmdsb2JhbCBzZXRJbW1lZGlhdGU6IGZhbHNlLCBzZXRUaW1lb3V0OiBmYWxzZSwgY29uc29sZTogZmFsc2UgKi9cbihmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgYXN5bmMgPSB7fTtcblxuICAgIC8vIGdsb2JhbCBvbiB0aGUgc2VydmVyLCB3aW5kb3cgaW4gdGhlIGJyb3dzZXJcbiAgICB2YXIgcm9vdCwgcHJldmlvdXNfYXN5bmM7XG5cbiAgICByb290ID0gdGhpcztcbiAgICBpZiAocm9vdCAhPSBudWxsKSB7XG4gICAgICBwcmV2aW91c19hc3luYyA9IHJvb3QuYXN5bmM7XG4gICAgfVxuXG4gICAgYXN5bmMubm9Db25mbGljdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcm9vdC5hc3luYyA9IHByZXZpb3VzX2FzeW5jO1xuICAgICAgICByZXR1cm4gYXN5bmM7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIG9ubHlfb25jZShmbikge1xuICAgICAgICB2YXIgY2FsbGVkID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmIChjYWxsZWQpIHRocm93IG5ldyBFcnJvcihcIkNhbGxiYWNrIHdhcyBhbHJlYWR5IGNhbGxlZC5cIik7XG4gICAgICAgICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgZm4uYXBwbHkocm9vdCwgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vLy8gY3Jvc3MtYnJvd3NlciBjb21wYXRpYmxpdHkgZnVuY3Rpb25zIC8vLy9cblxuICAgIHZhciBfZWFjaCA9IGZ1bmN0aW9uIChhcnIsIGl0ZXJhdG9yKSB7XG4gICAgICAgIGlmIChhcnIuZm9yRWFjaCkge1xuICAgICAgICAgICAgcmV0dXJuIGFyci5mb3JFYWNoKGl0ZXJhdG9yKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgaXRlcmF0b3IoYXJyW2ldLCBpLCBhcnIpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBfbWFwID0gZnVuY3Rpb24gKGFyciwgaXRlcmF0b3IpIHtcbiAgICAgICAgaWYgKGFyci5tYXApIHtcbiAgICAgICAgICAgIHJldHVybiBhcnIubWFwKGl0ZXJhdG9yKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgICAgICBfZWFjaChhcnIsIGZ1bmN0aW9uICh4LCBpLCBhKSB7XG4gICAgICAgICAgICByZXN1bHRzLnB1c2goaXRlcmF0b3IoeCwgaSwgYSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfTtcblxuICAgIHZhciBfcmVkdWNlID0gZnVuY3Rpb24gKGFyciwgaXRlcmF0b3IsIG1lbW8pIHtcbiAgICAgICAgaWYgKGFyci5yZWR1Y2UpIHtcbiAgICAgICAgICAgIHJldHVybiBhcnIucmVkdWNlKGl0ZXJhdG9yLCBtZW1vKTtcbiAgICAgICAgfVxuICAgICAgICBfZWFjaChhcnIsIGZ1bmN0aW9uICh4LCBpLCBhKSB7XG4gICAgICAgICAgICBtZW1vID0gaXRlcmF0b3IobWVtbywgeCwgaSwgYSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbWVtbztcbiAgICB9O1xuXG4gICAgdmFyIF9rZXlzID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICBpZiAoT2JqZWN0LmtleXMpIHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhvYmopO1xuICAgICAgICB9XG4gICAgICAgIHZhciBrZXlzID0gW107XG4gICAgICAgIGZvciAodmFyIGsgaW4gb2JqKSB7XG4gICAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGspKSB7XG4gICAgICAgICAgICAgICAga2V5cy5wdXNoKGspO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBrZXlzO1xuICAgIH07XG5cbiAgICAvLy8vIGV4cG9ydGVkIGFzeW5jIG1vZHVsZSBmdW5jdGlvbnMgLy8vL1xuXG4gICAgLy8vLyBuZXh0VGljayBpbXBsZW1lbnRhdGlvbiB3aXRoIGJyb3dzZXItY29tcGF0aWJsZSBmYWxsYmFjayAvLy8vXG4gICAgaWYgKHR5cGVvZiBwcm9jZXNzID09PSAndW5kZWZpbmVkJyB8fCAhKHByb2Nlc3MubmV4dFRpY2spKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBhc3luYy5uZXh0VGljayA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgICAgIC8vIG5vdCBhIGRpcmVjdCBhbGlhcyBmb3IgSUUxMCBjb21wYXRpYmlsaXR5XG4gICAgICAgICAgICAgICAgc2V0SW1tZWRpYXRlKGZuKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBhc3luYy5zZXRJbW1lZGlhdGUgPSBhc3luYy5uZXh0VGljaztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFzeW5jLm5leHRUaWNrID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmbiwgMCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYXN5bmMuc2V0SW1tZWRpYXRlID0gYXN5bmMubmV4dFRpY2s7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGFzeW5jLm5leHRUaWNrID0gcHJvY2Vzcy5uZXh0VGljaztcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRJbW1lZGlhdGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBhc3luYy5zZXRJbW1lZGlhdGUgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgICAgLy8gbm90IGEgZGlyZWN0IGFsaWFzIGZvciBJRTEwIGNvbXBhdGliaWxpdHlcbiAgICAgICAgICAgICAgc2V0SW1tZWRpYXRlKGZuKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhc3luYy5zZXRJbW1lZGlhdGUgPSBhc3luYy5uZXh0VGljaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jLmVhY2ggPSBmdW5jdGlvbiAoYXJyLCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgaWYgKCFhcnIubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY29tcGxldGVkID0gMDtcbiAgICAgICAgX2VhY2goYXJyLCBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgaXRlcmF0b3IoeCwgb25seV9vbmNlKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gZnVuY3Rpb24gKCkge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZWQgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXBsZXRlZCA+PSBhcnIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBhc3luYy5mb3JFYWNoID0gYXN5bmMuZWFjaDtcblxuICAgIGFzeW5jLmVhY2hTZXJpZXMgPSBmdW5jdGlvbiAoYXJyLCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgaWYgKCFhcnIubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY29tcGxldGVkID0gMDtcbiAgICAgICAgdmFyIGl0ZXJhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpdGVyYXRvcihhcnJbY29tcGxldGVkXSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlZCArPSAxO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29tcGxldGVkID49IGFyci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlcmF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGl0ZXJhdGUoKTtcbiAgICB9O1xuICAgIGFzeW5jLmZvckVhY2hTZXJpZXMgPSBhc3luYy5lYWNoU2VyaWVzO1xuXG4gICAgYXN5bmMuZWFjaExpbWl0ID0gZnVuY3Rpb24gKGFyciwgbGltaXQsIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgZm4gPSBfZWFjaExpbWl0KGxpbWl0KTtcbiAgICAgICAgZm4uYXBwbHkobnVsbCwgW2FyciwgaXRlcmF0b3IsIGNhbGxiYWNrXSk7XG4gICAgfTtcbiAgICBhc3luYy5mb3JFYWNoTGltaXQgPSBhc3luYy5lYWNoTGltaXQ7XG5cbiAgICB2YXIgX2VhY2hMaW1pdCA9IGZ1bmN0aW9uIChsaW1pdCkge1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoYXJyLCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgZnVuY3Rpb24gKCkge307XG4gICAgICAgICAgICBpZiAoIWFyci5sZW5ndGggfHwgbGltaXQgPD0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGNvbXBsZXRlZCA9IDA7XG4gICAgICAgICAgICB2YXIgc3RhcnRlZCA9IDA7XG4gICAgICAgICAgICB2YXIgcnVubmluZyA9IDA7XG5cbiAgICAgICAgICAgIChmdW5jdGlvbiByZXBsZW5pc2ggKCkge1xuICAgICAgICAgICAgICAgIGlmIChjb21wbGV0ZWQgPj0gYXJyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB3aGlsZSAocnVubmluZyA8IGxpbWl0ICYmIHN0YXJ0ZWQgPCBhcnIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0ZWQgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgcnVubmluZyArPSAxO1xuICAgICAgICAgICAgICAgICAgICBpdGVyYXRvcihhcnJbc3RhcnRlZCAtIDFdLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayA9IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcGxldGVkICs9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVubmluZyAtPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb21wbGV0ZWQgPj0gYXJyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVwbGVuaXNoKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICB9O1xuICAgIH07XG5cblxuICAgIHZhciBkb1BhcmFsbGVsID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkobnVsbCwgW2FzeW5jLmVhY2hdLmNvbmNhdChhcmdzKSk7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICB2YXIgZG9QYXJhbGxlbExpbWl0ID0gZnVuY3Rpb24obGltaXQsIGZuKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkobnVsbCwgW19lYWNoTGltaXQobGltaXQpXS5jb25jYXQoYXJncykpO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgdmFyIGRvU2VyaWVzID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkobnVsbCwgW2FzeW5jLmVhY2hTZXJpZXNdLmNvbmNhdChhcmdzKSk7XG4gICAgICAgIH07XG4gICAgfTtcblxuXG4gICAgdmFyIF9hc3luY01hcCA9IGZ1bmN0aW9uIChlYWNoZm4sIGFyciwgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciByZXN1bHRzID0gW107XG4gICAgICAgIGFyciA9IF9tYXAoYXJyLCBmdW5jdGlvbiAoeCwgaSkge1xuICAgICAgICAgICAgcmV0dXJuIHtpbmRleDogaSwgdmFsdWU6IHh9O1xuICAgICAgICB9KTtcbiAgICAgICAgZWFjaGZuKGFyciwgZnVuY3Rpb24gKHgsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBpdGVyYXRvcih4LnZhbHVlLCBmdW5jdGlvbiAoZXJyLCB2KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0c1t4LmluZGV4XSA9IHY7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhlcnIsIHJlc3VsdHMpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGFzeW5jLm1hcCA9IGRvUGFyYWxsZWwoX2FzeW5jTWFwKTtcbiAgICBhc3luYy5tYXBTZXJpZXMgPSBkb1NlcmllcyhfYXN5bmNNYXApO1xuICAgIGFzeW5jLm1hcExpbWl0ID0gZnVuY3Rpb24gKGFyciwgbGltaXQsIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gX21hcExpbWl0KGxpbWl0KShhcnIsIGl0ZXJhdG9yLCBjYWxsYmFjayk7XG4gICAgfTtcblxuICAgIHZhciBfbWFwTGltaXQgPSBmdW5jdGlvbihsaW1pdCkge1xuICAgICAgICByZXR1cm4gZG9QYXJhbGxlbExpbWl0KGxpbWl0LCBfYXN5bmNNYXApO1xuICAgIH07XG5cbiAgICAvLyByZWR1Y2Ugb25seSBoYXMgYSBzZXJpZXMgdmVyc2lvbiwgYXMgZG9pbmcgcmVkdWNlIGluIHBhcmFsbGVsIHdvbid0XG4gICAgLy8gd29yayBpbiBtYW55IHNpdHVhdGlvbnMuXG4gICAgYXN5bmMucmVkdWNlID0gZnVuY3Rpb24gKGFyciwgbWVtbywgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgIGFzeW5jLmVhY2hTZXJpZXMoYXJyLCBmdW5jdGlvbiAoeCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yKG1lbW8sIHgsIGZ1bmN0aW9uIChlcnIsIHYpIHtcbiAgICAgICAgICAgICAgICBtZW1vID0gdjtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgbWVtbyk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLy8gaW5qZWN0IGFsaWFzXG4gICAgYXN5bmMuaW5qZWN0ID0gYXN5bmMucmVkdWNlO1xuICAgIC8vIGZvbGRsIGFsaWFzXG4gICAgYXN5bmMuZm9sZGwgPSBhc3luYy5yZWR1Y2U7XG5cbiAgICBhc3luYy5yZWR1Y2VSaWdodCA9IGZ1bmN0aW9uIChhcnIsIG1lbW8sIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgcmV2ZXJzZWQgPSBfbWFwKGFyciwgZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgIHJldHVybiB4O1xuICAgICAgICB9KS5yZXZlcnNlKCk7XG4gICAgICAgIGFzeW5jLnJlZHVjZShyZXZlcnNlZCwgbWVtbywgaXRlcmF0b3IsIGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIC8vIGZvbGRyIGFsaWFzXG4gICAgYXN5bmMuZm9sZHIgPSBhc3luYy5yZWR1Y2VSaWdodDtcblxuICAgIHZhciBfZmlsdGVyID0gZnVuY3Rpb24gKGVhY2hmbiwgYXJyLCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgYXJyID0gX21hcChhcnIsIGZ1bmN0aW9uICh4LCBpKSB7XG4gICAgICAgICAgICByZXR1cm4ge2luZGV4OiBpLCB2YWx1ZTogeH07XG4gICAgICAgIH0pO1xuICAgICAgICBlYWNoZm4oYXJyLCBmdW5jdGlvbiAoeCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yKHgudmFsdWUsIGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICAgICAgaWYgKHYpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKF9tYXAocmVzdWx0cy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGEuaW5kZXggLSBiLmluZGV4O1xuICAgICAgICAgICAgfSksIGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHgudmFsdWU7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgYXN5bmMuZmlsdGVyID0gZG9QYXJhbGxlbChfZmlsdGVyKTtcbiAgICBhc3luYy5maWx0ZXJTZXJpZXMgPSBkb1NlcmllcyhfZmlsdGVyKTtcbiAgICAvLyBzZWxlY3QgYWxpYXNcbiAgICBhc3luYy5zZWxlY3QgPSBhc3luYy5maWx0ZXI7XG4gICAgYXN5bmMuc2VsZWN0U2VyaWVzID0gYXN5bmMuZmlsdGVyU2VyaWVzO1xuXG4gICAgdmFyIF9yZWplY3QgPSBmdW5jdGlvbiAoZWFjaGZuLCBhcnIsIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgICAgICBhcnIgPSBfbWFwKGFyciwgZnVuY3Rpb24gKHgsIGkpIHtcbiAgICAgICAgICAgIHJldHVybiB7aW5kZXg6IGksIHZhbHVlOiB4fTtcbiAgICAgICAgfSk7XG4gICAgICAgIGVhY2hmbihhcnIsIGZ1bmN0aW9uICh4LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgaXRlcmF0b3IoeC52YWx1ZSwgZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXYpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKF9tYXAocmVzdWx0cy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGEuaW5kZXggLSBiLmluZGV4O1xuICAgICAgICAgICAgfSksIGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHgudmFsdWU7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgYXN5bmMucmVqZWN0ID0gZG9QYXJhbGxlbChfcmVqZWN0KTtcbiAgICBhc3luYy5yZWplY3RTZXJpZXMgPSBkb1NlcmllcyhfcmVqZWN0KTtcblxuICAgIHZhciBfZGV0ZWN0ID0gZnVuY3Rpb24gKGVhY2hmbiwgYXJyLCBpdGVyYXRvciwgbWFpbl9jYWxsYmFjaykge1xuICAgICAgICBlYWNoZm4oYXJyLCBmdW5jdGlvbiAoeCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yKHgsIGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIG1haW5fY2FsbGJhY2soeCk7XG4gICAgICAgICAgICAgICAgICAgIG1haW5fY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIG1haW5fY2FsbGJhY2soKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBhc3luYy5kZXRlY3QgPSBkb1BhcmFsbGVsKF9kZXRlY3QpO1xuICAgIGFzeW5jLmRldGVjdFNlcmllcyA9IGRvU2VyaWVzKF9kZXRlY3QpO1xuXG4gICAgYXN5bmMuc29tZSA9IGZ1bmN0aW9uIChhcnIsIGl0ZXJhdG9yLCBtYWluX2NhbGxiYWNrKSB7XG4gICAgICAgIGFzeW5jLmVhY2goYXJyLCBmdW5jdGlvbiAoeCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yKHgsIGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICAgICAgaWYgKHYpIHtcbiAgICAgICAgICAgICAgICAgICAgbWFpbl9jYWxsYmFjayh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgbWFpbl9jYWxsYmFjayA9IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIG1haW5fY2FsbGJhY2soZmFsc2UpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8vIGFueSBhbGlhc1xuICAgIGFzeW5jLmFueSA9IGFzeW5jLnNvbWU7XG5cbiAgICBhc3luYy5ldmVyeSA9IGZ1bmN0aW9uIChhcnIsIGl0ZXJhdG9yLCBtYWluX2NhbGxiYWNrKSB7XG4gICAgICAgIGFzeW5jLmVhY2goYXJyLCBmdW5jdGlvbiAoeCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yKHgsIGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICAgICAgaWYgKCF2KSB7XG4gICAgICAgICAgICAgICAgICAgIG1haW5fY2FsbGJhY2soZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICBtYWluX2NhbGxiYWNrID0gZnVuY3Rpb24gKCkge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgbWFpbl9jYWxsYmFjayh0cnVlKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvLyBhbGwgYWxpYXNcbiAgICBhc3luYy5hbGwgPSBhc3luYy5ldmVyeTtcblxuICAgIGFzeW5jLnNvcnRCeSA9IGZ1bmN0aW9uIChhcnIsIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICBhc3luYy5tYXAoYXJyLCBmdW5jdGlvbiAoeCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yKHgsIGZ1bmN0aW9uIChlcnIsIGNyaXRlcmlhKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwge3ZhbHVlOiB4LCBjcml0ZXJpYTogY3JpdGVyaWF9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVyciwgcmVzdWx0cykge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGZuID0gZnVuY3Rpb24gKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhID0gbGVmdC5jcml0ZXJpYSwgYiA9IHJpZ2h0LmNyaXRlcmlhO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYSA8IGIgPyAtMSA6IGEgPiBiID8gMSA6IDA7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCBfbWFwKHJlc3VsdHMuc29ydChmbiksIGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB4LnZhbHVlO1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIGFzeW5jLmF1dG8gPSBmdW5jdGlvbiAodGFza3MsIGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgZnVuY3Rpb24gKCkge307XG4gICAgICAgIHZhciBrZXlzID0gX2tleXModGFza3MpO1xuICAgICAgICBpZiAoIWtleXMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVzdWx0cyA9IHt9O1xuXG4gICAgICAgIHZhciBsaXN0ZW5lcnMgPSBbXTtcbiAgICAgICAgdmFyIGFkZExpc3RlbmVyID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICBsaXN0ZW5lcnMudW5zaGlmdChmbik7XG4gICAgICAgIH07XG4gICAgICAgIHZhciByZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICBpZiAobGlzdGVuZXJzW2ldID09PSBmbikge1xuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB2YXIgdGFza0NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX2VhY2gobGlzdGVuZXJzLnNsaWNlKDApLCBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgICAgICBmbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgYWRkTGlzdGVuZXIoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKF9rZXlzKHJlc3VsdHMpLmxlbmd0aCA9PT0ga2V5cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCByZXN1bHRzKTtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayA9IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBfZWFjaChrZXlzLCBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgdmFyIHRhc2sgPSAodGFza3Nba10gaW5zdGFuY2VvZiBGdW5jdGlvbikgPyBbdGFza3Nba11dOiB0YXNrc1trXTtcbiAgICAgICAgICAgIHZhciB0YXNrQ2FsbGJhY2sgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCA8PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3MgPSBhcmdzWzBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzYWZlUmVzdWx0cyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBfZWFjaChfa2V5cyhyZXN1bHRzKSwgZnVuY3Rpb24ocmtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2FmZVJlc3VsdHNbcmtleV0gPSByZXN1bHRzW3JrZXldO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc2FmZVJlc3VsdHNba10gPSBhcmdzO1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIsIHNhZmVSZXN1bHRzKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gc3RvcCBzdWJzZXF1ZW50IGVycm9ycyBoaXR0aW5nIGNhbGxiYWNrIG11bHRpcGxlIHRpbWVzXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gZnVuY3Rpb24gKCkge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzW2tdID0gYXJncztcbiAgICAgICAgICAgICAgICAgICAgYXN5bmMuc2V0SW1tZWRpYXRlKHRhc2tDb21wbGV0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciByZXF1aXJlcyA9IHRhc2suc2xpY2UoMCwgTWF0aC5hYnModGFzay5sZW5ndGggLSAxKSkgfHwgW107XG4gICAgICAgICAgICB2YXIgcmVhZHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9yZWR1Y2UocmVxdWlyZXMsIGZ1bmN0aW9uIChhLCB4KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoYSAmJiByZXN1bHRzLmhhc093blByb3BlcnR5KHgpKTtcbiAgICAgICAgICAgICAgICB9LCB0cnVlKSAmJiAhcmVzdWx0cy5oYXNPd25Qcm9wZXJ0eShrKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAocmVhZHkoKSkge1xuICAgICAgICAgICAgICAgIHRhc2tbdGFzay5sZW5ndGggLSAxXSh0YXNrQ2FsbGJhY2ssIHJlc3VsdHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGxpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVhZHkoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlTGlzdGVuZXIobGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFza1t0YXNrLmxlbmd0aCAtIDFdKHRhc2tDYWxsYmFjaywgcmVzdWx0cyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGFkZExpc3RlbmVyKGxpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIGFzeW5jLndhdGVyZmFsbCA9IGZ1bmN0aW9uICh0YXNrcywgY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgaWYgKHRhc2tzLmNvbnN0cnVjdG9yICE9PSBBcnJheSkge1xuICAgICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IHRvIHdhdGVyZmFsbCBtdXN0IGJlIGFuIGFycmF5IG9mIGZ1bmN0aW9ucycpO1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGFza3MubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgd3JhcEl0ZXJhdG9yID0gZnVuY3Rpb24gKGl0ZXJhdG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5leHQgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzLnB1c2god3JhcEl0ZXJhdG9yKG5leHQpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MucHVzaChjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYXN5bmMuc2V0SW1tZWRpYXRlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZXJhdG9yLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICB3cmFwSXRlcmF0b3IoYXN5bmMuaXRlcmF0b3IodGFza3MpKSgpO1xuICAgIH07XG5cbiAgICB2YXIgX3BhcmFsbGVsID0gZnVuY3Rpb24oZWFjaGZuLCB0YXNrcywgY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgaWYgKHRhc2tzLmNvbnN0cnVjdG9yID09PSBBcnJheSkge1xuICAgICAgICAgICAgZWFjaGZuLm1hcCh0YXNrcywgZnVuY3Rpb24gKGZuLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGlmIChmbikge1xuICAgICAgICAgICAgICAgICAgICBmbihmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXJncy5sZW5ndGggPD0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MgPSBhcmdzWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2suY2FsbChudWxsLCBlcnIsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0cyA9IHt9O1xuICAgICAgICAgICAgZWFjaGZuLmVhY2goX2tleXModGFza3MpLCBmdW5jdGlvbiAoaywgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICB0YXNrc1trXShmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoIDw9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MgPSBhcmdzWzBdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHNba10gPSBhcmdzO1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgcmVzdWx0cyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBhc3luYy5wYXJhbGxlbCA9IGZ1bmN0aW9uICh0YXNrcywgY2FsbGJhY2spIHtcbiAgICAgICAgX3BhcmFsbGVsKHsgbWFwOiBhc3luYy5tYXAsIGVhY2g6IGFzeW5jLmVhY2ggfSwgdGFza3MsIGNhbGxiYWNrKTtcbiAgICB9O1xuXG4gICAgYXN5bmMucGFyYWxsZWxMaW1pdCA9IGZ1bmN0aW9uKHRhc2tzLCBsaW1pdCwgY2FsbGJhY2spIHtcbiAgICAgICAgX3BhcmFsbGVsKHsgbWFwOiBfbWFwTGltaXQobGltaXQpLCBlYWNoOiBfZWFjaExpbWl0KGxpbWl0KSB9LCB0YXNrcywgY2FsbGJhY2spO1xuICAgIH07XG5cbiAgICBhc3luYy5zZXJpZXMgPSBmdW5jdGlvbiAodGFza3MsIGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgZnVuY3Rpb24gKCkge307XG4gICAgICAgIGlmICh0YXNrcy5jb25zdHJ1Y3RvciA9PT0gQXJyYXkpIHtcbiAgICAgICAgICAgIGFzeW5jLm1hcFNlcmllcyh0YXNrcywgZnVuY3Rpb24gKGZuLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGlmIChmbikge1xuICAgICAgICAgICAgICAgICAgICBmbihmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXJncy5sZW5ndGggPD0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MgPSBhcmdzWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2suY2FsbChudWxsLCBlcnIsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0cyA9IHt9O1xuICAgICAgICAgICAgYXN5bmMuZWFjaFNlcmllcyhfa2V5cyh0YXNrcyksIGZ1bmN0aW9uIChrLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHRhc2tzW2tdKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXJncy5sZW5ndGggPD0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJncyA9IGFyZ3NbMF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0c1trXSA9IGFyZ3M7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyLCByZXN1bHRzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGFzeW5jLml0ZXJhdG9yID0gZnVuY3Rpb24gKHRhc2tzKSB7XG4gICAgICAgIHZhciBtYWtlQ2FsbGJhY2sgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBmbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAodGFza3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhc2tzW2luZGV4XS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZm4ubmV4dCgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZuLm5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChpbmRleCA8IHRhc2tzLmxlbmd0aCAtIDEpID8gbWFrZUNhbGxiYWNrKGluZGV4ICsgMSk6IG51bGw7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIGZuO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gbWFrZUNhbGxiYWNrKDApO1xuICAgIH07XG5cbiAgICBhc3luYy5hcHBseSA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkoXG4gICAgICAgICAgICAgICAgbnVsbCwgYXJncy5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBfY29uY2F0ID0gZnVuY3Rpb24gKGVhY2hmbiwgYXJyLCBmbiwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHIgPSBbXTtcbiAgICAgICAgZWFjaGZuKGFyciwgZnVuY3Rpb24gKHgsIGNiKSB7XG4gICAgICAgICAgICBmbih4LCBmdW5jdGlvbiAoZXJyLCB5KSB7XG4gICAgICAgICAgICAgICAgciA9IHIuY29uY2F0KHkgfHwgW10pO1xuICAgICAgICAgICAgICAgIGNiKGVycik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgY2FsbGJhY2soZXJyLCByKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBhc3luYy5jb25jYXQgPSBkb1BhcmFsbGVsKF9jb25jYXQpO1xuICAgIGFzeW5jLmNvbmNhdFNlcmllcyA9IGRvU2VyaWVzKF9jb25jYXQpO1xuXG4gICAgYXN5bmMud2hpbHN0ID0gZnVuY3Rpb24gKHRlc3QsIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAodGVzdCgpKSB7XG4gICAgICAgICAgICBpdGVyYXRvcihmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXN5bmMud2hpbHN0KHRlc3QsIGl0ZXJhdG9yLCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgYXN5bmMuZG9XaGlsc3QgPSBmdW5jdGlvbiAoaXRlcmF0b3IsIHRlc3QsIGNhbGxiYWNrKSB7XG4gICAgICAgIGl0ZXJhdG9yKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0ZXN0KCkpIHtcbiAgICAgICAgICAgICAgICBhc3luYy5kb1doaWxzdChpdGVyYXRvciwgdGVzdCwgY2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIGFzeW5jLnVudGlsID0gZnVuY3Rpb24gKHRlc3QsIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAoIXRlc3QoKSkge1xuICAgICAgICAgICAgaXRlcmF0b3IoZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFzeW5jLnVudGlsKHRlc3QsIGl0ZXJhdG9yLCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgYXN5bmMuZG9VbnRpbCA9IGZ1bmN0aW9uIChpdGVyYXRvciwgdGVzdCwgY2FsbGJhY2spIHtcbiAgICAgICAgaXRlcmF0b3IoZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0ZXN0KCkpIHtcbiAgICAgICAgICAgICAgICBhc3luYy5kb1VudGlsKGl0ZXJhdG9yLCB0ZXN0LCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgYXN5bmMucXVldWUgPSBmdW5jdGlvbiAod29ya2VyLCBjb25jdXJyZW5jeSkge1xuICAgICAgICBpZiAoY29uY3VycmVuY3kgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uY3VycmVuY3kgPSAxO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIF9pbnNlcnQocSwgZGF0YSwgcG9zLCBjYWxsYmFjaykge1xuICAgICAgICAgIGlmKGRhdGEuY29uc3RydWN0b3IgIT09IEFycmF5KSB7XG4gICAgICAgICAgICAgIGRhdGEgPSBbZGF0YV07XG4gICAgICAgICAgfVxuICAgICAgICAgIF9lYWNoKGRhdGEsIGZ1bmN0aW9uKHRhc2spIHtcbiAgICAgICAgICAgICAgdmFyIGl0ZW0gPSB7XG4gICAgICAgICAgICAgICAgICBkYXRhOiB0YXNrLFxuICAgICAgICAgICAgICAgICAgY2FsbGJhY2s6IHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJyA/IGNhbGxiYWNrIDogbnVsbFxuICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgIGlmIChwb3MpIHtcbiAgICAgICAgICAgICAgICBxLnRhc2tzLnVuc2hpZnQoaXRlbSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcS50YXNrcy5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKHEuc2F0dXJhdGVkICYmIHEudGFza3MubGVuZ3RoID09PSBjb25jdXJyZW5jeSkge1xuICAgICAgICAgICAgICAgICAgcS5zYXR1cmF0ZWQoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBhc3luYy5zZXRJbW1lZGlhdGUocS5wcm9jZXNzKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB3b3JrZXJzID0gMDtcbiAgICAgICAgdmFyIHEgPSB7XG4gICAgICAgICAgICB0YXNrczogW10sXG4gICAgICAgICAgICBjb25jdXJyZW5jeTogY29uY3VycmVuY3ksXG4gICAgICAgICAgICBzYXR1cmF0ZWQ6IG51bGwsXG4gICAgICAgICAgICBlbXB0eTogbnVsbCxcbiAgICAgICAgICAgIGRyYWluOiBudWxsLFxuICAgICAgICAgICAgcHVzaDogZnVuY3Rpb24gKGRhdGEsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgIF9pbnNlcnQocSwgZGF0YSwgZmFsc2UsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1bnNoaWZ0OiBmdW5jdGlvbiAoZGF0YSwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgX2luc2VydChxLCBkYXRhLCB0cnVlLCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcHJvY2VzczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmICh3b3JrZXJzIDwgcS5jb25jdXJyZW5jeSAmJiBxLnRhc2tzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGFzayA9IHEudGFza3Muc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHEuZW1wdHkgJiYgcS50YXNrcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHEuZW1wdHkoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB3b3JrZXJzICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd29ya2VycyAtPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRhc2suY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXNrLmNhbGxiYWNrLmFwcGx5KHRhc2ssIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocS5kcmFpbiAmJiBxLnRhc2tzLmxlbmd0aCArIHdvcmtlcnMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxLmRyYWluKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBxLnByb2Nlc3MoKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNiID0gb25seV9vbmNlKG5leHQpO1xuICAgICAgICAgICAgICAgICAgICB3b3JrZXIodGFzay5kYXRhLCBjYik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxlbmd0aDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBxLnRhc2tzLmxlbmd0aDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBydW5uaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdvcmtlcnM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBxO1xuICAgIH07XG5cbiAgICBhc3luYy5jYXJnbyA9IGZ1bmN0aW9uICh3b3JrZXIsIHBheWxvYWQpIHtcbiAgICAgICAgdmFyIHdvcmtpbmcgICAgID0gZmFsc2UsXG4gICAgICAgICAgICB0YXNrcyAgICAgICA9IFtdO1xuXG4gICAgICAgIHZhciBjYXJnbyA9IHtcbiAgICAgICAgICAgIHRhc2tzOiB0YXNrcyxcbiAgICAgICAgICAgIHBheWxvYWQ6IHBheWxvYWQsXG4gICAgICAgICAgICBzYXR1cmF0ZWQ6IG51bGwsXG4gICAgICAgICAgICBlbXB0eTogbnVsbCxcbiAgICAgICAgICAgIGRyYWluOiBudWxsLFxuICAgICAgICAgICAgcHVzaDogZnVuY3Rpb24gKGRhdGEsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgaWYoZGF0YS5jb25zdHJ1Y3RvciAhPT0gQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IFtkYXRhXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX2VhY2goZGF0YSwgZnVuY3Rpb24odGFzaykge1xuICAgICAgICAgICAgICAgICAgICB0YXNrcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHRhc2ssXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjazogdHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nID8gY2FsbGJhY2sgOiBudWxsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2FyZ28uc2F0dXJhdGVkICYmIHRhc2tzLmxlbmd0aCA9PT0gcGF5bG9hZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FyZ28uc2F0dXJhdGVkKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBhc3luYy5zZXRJbW1lZGlhdGUoY2FyZ28ucHJvY2Vzcyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcHJvY2VzczogZnVuY3Rpb24gcHJvY2VzcygpIHtcbiAgICAgICAgICAgICAgICBpZiAod29ya2luZykgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGlmICh0YXNrcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYoY2FyZ28uZHJhaW4pIGNhcmdvLmRyYWluKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgdHMgPSB0eXBlb2YgcGF5bG9hZCA9PT0gJ251bWJlcidcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHRhc2tzLnNwbGljZSgwLCBwYXlsb2FkKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdGFza3Muc3BsaWNlKDApO1xuXG4gICAgICAgICAgICAgICAgdmFyIGRzID0gX21hcCh0cywgZnVuY3Rpb24gKHRhc2spIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhc2suZGF0YTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGlmKGNhcmdvLmVtcHR5KSBjYXJnby5lbXB0eSgpO1xuICAgICAgICAgICAgICAgIHdvcmtpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHdvcmtlcihkcywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB3b3JraW5nID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgICAgICAgICAgICAgIF9lYWNoKHRzLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEuY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLmNhbGxiYWNrLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbGVuZ3RoOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhc2tzLmxlbmd0aDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBydW5uaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdvcmtpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBjYXJnbztcbiAgICB9O1xuXG4gICAgdmFyIF9jb25zb2xlX2ZuID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICAgICAgZm4uYXBwbHkobnVsbCwgYXJncy5jb25jYXQoW2Z1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29uc29sZS5lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjb25zb2xlW25hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfZWFjaChhcmdzLCBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGVbbmFtZV0oeCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dKSk7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBhc3luYy5sb2cgPSBfY29uc29sZV9mbignbG9nJyk7XG4gICAgYXN5bmMuZGlyID0gX2NvbnNvbGVfZm4oJ2RpcicpO1xuICAgIC8qYXN5bmMuaW5mbyA9IF9jb25zb2xlX2ZuKCdpbmZvJyk7XG4gICAgYXN5bmMud2FybiA9IF9jb25zb2xlX2ZuKCd3YXJuJyk7XG4gICAgYXN5bmMuZXJyb3IgPSBfY29uc29sZV9mbignZXJyb3InKTsqL1xuXG4gICAgYXN5bmMubWVtb2l6ZSA9IGZ1bmN0aW9uIChmbiwgaGFzaGVyKSB7XG4gICAgICAgIHZhciBtZW1vID0ge307XG4gICAgICAgIHZhciBxdWV1ZXMgPSB7fTtcbiAgICAgICAgaGFzaGVyID0gaGFzaGVyIHx8IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICByZXR1cm4geDtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIG1lbW9pemVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICAgICAgdmFyIGNhbGxiYWNrID0gYXJncy5wb3AoKTtcbiAgICAgICAgICAgIHZhciBrZXkgPSBoYXNoZXIuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgICAgICBpZiAoa2V5IGluIG1lbW8pIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjay5hcHBseShudWxsLCBtZW1vW2tleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5IGluIHF1ZXVlcykge1xuICAgICAgICAgICAgICAgIHF1ZXVlc1trZXldLnB1c2goY2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcXVldWVzW2tleV0gPSBbY2FsbGJhY2tdO1xuICAgICAgICAgICAgICAgIGZuLmFwcGx5KG51bGwsIGFyZ3MuY29uY2F0KFtmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lbW9ba2V5XSA9IGFyZ3VtZW50cztcbiAgICAgICAgICAgICAgICAgICAgdmFyIHEgPSBxdWV1ZXNba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHF1ZXVlc1trZXldO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHEubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcVtpXS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgbWVtb2l6ZWQubWVtbyA9IG1lbW87XG4gICAgICAgIG1lbW9pemVkLnVubWVtb2l6ZWQgPSBmbjtcbiAgICAgICAgcmV0dXJuIG1lbW9pemVkO1xuICAgIH07XG5cbiAgICBhc3luYy51bm1lbW9pemUgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoZm4udW5tZW1vaXplZCB8fCBmbikuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIGFzeW5jLnRpbWVzID0gZnVuY3Rpb24gKGNvdW50LCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGNvdW50ZXIgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBjb3VudGVyLnB1c2goaSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFzeW5jLm1hcChjb3VudGVyLCBpdGVyYXRvciwgY2FsbGJhY2spO1xuICAgIH07XG5cbiAgICBhc3luYy50aW1lc1NlcmllcyA9IGZ1bmN0aW9uIChjb3VudCwgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBjb3VudGVyID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICAgY291bnRlci5wdXNoKGkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhc3luYy5tYXBTZXJpZXMoY291bnRlciwgaXRlcmF0b3IsIGNhbGxiYWNrKTtcbiAgICB9O1xuXG4gICAgYXN5bmMuY29tcG9zZSA9IGZ1bmN0aW9uICgvKiBmdW5jdGlvbnMuLi4gKi8pIHtcbiAgICAgICAgdmFyIGZucyA9IEFycmF5LnByb3RvdHlwZS5yZXZlcnNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHZhciBjYWxsYmFjayA9IGFyZ3MucG9wKCk7XG4gICAgICAgICAgICBhc3luYy5yZWR1Y2UoZm5zLCBhcmdzLCBmdW5jdGlvbiAobmV3YXJncywgZm4sIGNiKSB7XG4gICAgICAgICAgICAgICAgZm4uYXBwbHkodGhhdCwgbmV3YXJncy5jb25jYXQoW2Z1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVyciA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5leHRhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgY2IoZXJyLCBuZXh0YXJncyk7XG4gICAgICAgICAgICAgICAgfV0pKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChlcnIsIHJlc3VsdHMpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjay5hcHBseSh0aGF0LCBbZXJyXS5jb25jYXQocmVzdWx0cykpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBfYXBwbHlFYWNoID0gZnVuY3Rpb24gKGVhY2hmbiwgZm5zIC8qYXJncy4uLiovKSB7XG4gICAgICAgIHZhciBnbyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHZhciBjYWxsYmFjayA9IGFyZ3MucG9wKCk7XG4gICAgICAgICAgICByZXR1cm4gZWFjaGZuKGZucywgZnVuY3Rpb24gKGZuLCBjYikge1xuICAgICAgICAgICAgICAgIGZuLmFwcGx5KHRoYXQsIGFyZ3MuY29uY2F0KFtjYl0pKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjYWxsYmFjayk7XG4gICAgICAgIH07XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgICAgICAgICAgcmV0dXJuIGdvLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGdvO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBhc3luYy5hcHBseUVhY2ggPSBkb1BhcmFsbGVsKF9hcHBseUVhY2gpO1xuICAgIGFzeW5jLmFwcGx5RWFjaFNlcmllcyA9IGRvU2VyaWVzKF9hcHBseUVhY2gpO1xuXG4gICAgYXN5bmMuZm9yZXZlciA9IGZ1bmN0aW9uIChmbiwgY2FsbGJhY2spIHtcbiAgICAgICAgZnVuY3Rpb24gbmV4dChlcnIpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZuKG5leHQpO1xuICAgICAgICB9XG4gICAgICAgIG5leHQoKTtcbiAgICB9O1xuXG4gICAgLy8gQU1EIC8gUmVxdWlyZUpTXG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgIT09ICd1bmRlZmluZWQnICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgZGVmaW5lKFtdLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gYXN5bmM7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBOb2RlLmpzXG4gICAgZWxzZSBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBhc3luYztcbiAgICB9XG4gICAgLy8gaW5jbHVkZWQgZGlyZWN0bHkgdmlhIDxzY3JpcHQ+IHRhZ1xuICAgIGVsc2Uge1xuICAgICAgICByb290LmFzeW5jID0gYXN5bmM7XG4gICAgfVxuXG59KCkpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbmVkYi9ub2RlX21vZHVsZXMvYXN5bmMvbGliL2FzeW5jLmpzXG4vLyBtb2R1bGUgaWQgPSA2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///6\n");

/***/ }),
/* 7 */
/*!**********************************************!*\
  !*** ./node_modules/nedb/lib/customUtils.js ***!
  \**********************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

eval("var crypto = __webpack_require__(/*! crypto */ 24)\n  ;\n\n/**\n * Return a random alphanumerical string of length len\n * There is a very small probability (less than 1/1,000,000) for the length to be less than len\n * (il the base64 conversion yields too many pluses and slashes) but\n * that's not an issue here\n * The probability of a collision is extremely small (need 3*10^12 documents to have one chance in a million of a collision)\n * See http://en.wikipedia.org/wiki/Birthday_problem\n */\nfunction uid (len) {\n  return crypto.randomBytes(Math.ceil(Math.max(8, len * 2)))\n    .toString('base64')\n    .replace(/[+\\/]/g, '')\n    .slice(0, len);\n}\n\n\n// Interface\nmodule.exports.uid = uid;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9uZWRiL2xpYi9jdXN0b21VdGlscy5qcz84NWFmIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKVxuICA7XG5cbi8qKlxuICogUmV0dXJuIGEgcmFuZG9tIGFscGhhbnVtZXJpY2FsIHN0cmluZyBvZiBsZW5ndGggbGVuXG4gKiBUaGVyZSBpcyBhIHZlcnkgc21hbGwgcHJvYmFiaWxpdHkgKGxlc3MgdGhhbiAxLzEsMDAwLDAwMCkgZm9yIHRoZSBsZW5ndGggdG8gYmUgbGVzcyB0aGFuIGxlblxuICogKGlsIHRoZSBiYXNlNjQgY29udmVyc2lvbiB5aWVsZHMgdG9vIG1hbnkgcGx1c2VzIGFuZCBzbGFzaGVzKSBidXRcbiAqIHRoYXQncyBub3QgYW4gaXNzdWUgaGVyZVxuICogVGhlIHByb2JhYmlsaXR5IG9mIGEgY29sbGlzaW9uIGlzIGV4dHJlbWVseSBzbWFsbCAobmVlZCAzKjEwXjEyIGRvY3VtZW50cyB0byBoYXZlIG9uZSBjaGFuY2UgaW4gYSBtaWxsaW9uIG9mIGEgY29sbGlzaW9uKVxuICogU2VlIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQmlydGhkYXlfcHJvYmxlbVxuICovXG5mdW5jdGlvbiB1aWQgKGxlbikge1xuICByZXR1cm4gY3J5cHRvLnJhbmRvbUJ5dGVzKE1hdGguY2VpbChNYXRoLm1heCg4LCBsZW4gKiAyKSkpXG4gICAgLnRvU3RyaW5nKCdiYXNlNjQnKVxuICAgIC5yZXBsYWNlKC9bK1xcL10vZywgJycpXG4gICAgLnNsaWNlKDAsIGxlbik7XG59XG5cblxuLy8gSW50ZXJmYWNlXG5tb2R1bGUuZXhwb3J0cy51aWQgPSB1aWQ7XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL25lZGIvbGliL2N1c3RvbVV0aWxzLmpzXG4vLyBtb2R1bGUgaWQgPSA3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///7\n");

/***/ }),
/* 8 */
/*!******************************************!*\
  !*** ./node_modules/nedb/lib/indexes.js ***!
  \******************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

eval("var BinarySearchTree = __webpack_require__(/*! binary-search-tree */ 26).AVLTree\n  , model = __webpack_require__(/*! ./model */ 4)\n  , _ = __webpack_require__(/*! underscore */ 1)\n  , util = __webpack_require__(/*! util */ 5)\n  ;\n\n/**\n * Two indexed pointers are equal iif they point to the same place\n */\nfunction checkValueEquality (a, b) {\n  return a === b;\n}\n\n/**\n * Type-aware projection\n */\nfunction projectForUnique (elt) {\n  if (elt === null) { return '$null'; }\n  if (typeof elt === 'string') { return '$string' + elt; }\n  if (typeof elt === 'boolean') { return '$boolean' + elt; }\n  if (typeof elt === 'number') { return '$number' + elt; }\n  if (util.isArray(elt)) { return '$date' + elt.getTime(); }\n\n  return elt;   // Arrays and objects, will check for pointer equality\n}\n\n\n/**\n * Create a new index\n * All methods on an index guarantee that either the whole operation was successful and the index changed\n * or the operation was unsuccessful and an error is thrown while the index is unchanged\n * @param {String} options.fieldName On which field should the index apply (can use dot notation to index on sub fields)\n * @param {Boolean} options.unique Optional, enforce a unique constraint (default: false)\n * @param {Boolean} options.sparse Optional, allow a sparse index (we can have documents for which fieldName is undefined) (default: false)\n */\nfunction Index (options) {\n  this.fieldName = options.fieldName;\n  this.unique = options.unique || false;\n  this.sparse = options.sparse || false;\n\n  this.treeOptions = { unique: this.unique, compareKeys: model.compareThings, checkValueEquality: checkValueEquality };\n\n  this.reset();   // No data in the beginning\n}\n\n\n/**\n * Reset an index\n * @param {Document or Array of documents} newData Optional, data to initialize the index with\n *                                                 If an error is thrown during insertion, the index is not modified\n */\nIndex.prototype.reset = function (newData) {\n  this.tree = new BinarySearchTree(this.treeOptions);\n\n  if (newData) { this.insert(newData); }\n};\n\n\n/**\n * Insert a new document in the index\n * If an array is passed, we insert all its elements (if one insertion fails the index is not modified)\n * O(log(n))\n */\nIndex.prototype.insert = function (doc) {\n  var key, self = this\n    , keys, i, failingI, error\n    ;\n\n  if (util.isArray(doc)) { this.insertMultipleDocs(doc); return; }\n\n  key = model.getDotValue(doc, this.fieldName);\n\n  // We don't index documents that don't contain the field if the index is sparse\n  if (key === undefined && this.sparse) { return; }\n\n  if (!util.isArray(key)) {\n    this.tree.insert(key, doc);\n  } else {\n    // If an insert fails due to a unique constraint, roll back all inserts before it\n    keys = _.uniq(key, projectForUnique);\n\n    for (i = 0; i < keys.length; i += 1) {\n      try {\n        this.tree.insert(keys[i], doc);\n      } catch (e) {\n        error = e;\n        failingI = i;\n        break;\n      }\n    }\n\n    if (error) {\n      for (i = 0; i < failingI; i += 1) {\n        this.tree.delete(keys[i], doc);\n      }\n\n      throw error;\n    }\n  }\n};\n\n\n/**\n * Insert an array of documents in the index\n * If a constraint is violated, the changes should be rolled back and an error thrown\n *\n * @API private\n */\nIndex.prototype.insertMultipleDocs = function (docs) {\n  var i, error, failingI;\n\n  for (i = 0; i < docs.length; i += 1) {\n    try {\n      this.insert(docs[i]);\n    } catch (e) {\n      error = e;\n      failingI = i;\n      break;\n    }\n  }\n\n  if (error) {\n    for (i = 0; i < failingI; i += 1) {\n      this.remove(docs[i]);\n    }\n\n    throw error;\n  }\n};\n\n\n/**\n * Remove a document from the index\n * If an array is passed, we remove all its elements\n * The remove operation is safe with regards to the 'unique' constraint\n * O(log(n))\n */\nIndex.prototype.remove = function (doc) {\n  var key, self = this;\n\n  if (util.isArray(doc)) { doc.forEach(function (d) { self.remove(d); }); return; }\n\n  key = model.getDotValue(doc, this.fieldName);\n\n  if (key === undefined && this.sparse) { return; }\n\n  if (!util.isArray(key)) {\n    this.tree.delete(key, doc);\n  } else {\n    _.uniq(key, projectForUnique).forEach(function (_key) {\n      self.tree.delete(_key, doc);\n    });\n  }\n};\n\n\n/**\n * Update a document in the index\n * If a constraint is violated, changes are rolled back and an error thrown\n * Naive implementation, still in O(log(n))\n */\nIndex.prototype.update = function (oldDoc, newDoc) {\n  if (util.isArray(oldDoc)) { this.updateMultipleDocs(oldDoc); return; }\n\n  this.remove(oldDoc);\n\n  try {\n    this.insert(newDoc);\n  } catch (e) {\n    this.insert(oldDoc);\n    throw e;\n  }\n};\n\n\n/**\n * Update multiple documents in the index\n * If a constraint is violated, the changes need to be rolled back\n * and an error thrown\n * @param {Array of oldDoc, newDoc pairs} pairs\n *\n * @API private\n */\nIndex.prototype.updateMultipleDocs = function (pairs) {\n  var i, failingI, error;\n\n  for (i = 0; i < pairs.length; i += 1) {\n    this.remove(pairs[i].oldDoc);\n  }\n\n  for (i = 0; i < pairs.length; i += 1) {\n    try {\n      this.insert(pairs[i].newDoc);\n    } catch (e) {\n      error = e;\n      failingI = i;\n      break;\n    }\n  }\n\n  // If an error was raised, roll back changes in the inverse order\n  if (error) {\n    for (i = 0; i < failingI; i += 1) {\n      this.remove(pairs[i].newDoc);\n    }\n\n    for (i = 0; i < pairs.length; i += 1) {\n      this.insert(pairs[i].oldDoc);\n    }\n\n    throw error;\n  }\n};\n\n\n/**\n * Revert an update\n */\nIndex.prototype.revertUpdate = function (oldDoc, newDoc) {\n  var revert = [];\n\n  if (!util.isArray(oldDoc)) {\n    this.update(newDoc, oldDoc);\n  } else {\n    oldDoc.forEach(function (pair) {\n      revert.push({ oldDoc: pair.newDoc, newDoc: pair.oldDoc });\n    });\n    this.update(revert);\n  }\n};\n\n\n/**\n * Get all documents in index whose key match value (if it is a Thing) or one of the elements of value (if it is an array of Things)\n * @param {Thing} value Value to match the key against\n * @return {Array of documents}\n */\nIndex.prototype.getMatching = function (value) {\n  var self = this;\n\n  if (!util.isArray(value)) {\n    return self.tree.search(value);\n  } else {\n    var _res = {}, res = [];\n\n    value.forEach(function (v) {\n      self.getMatching(v).forEach(function (doc) {\n        _res[doc._id] = doc;\n      });\n    });\n\n    Object.keys(_res).forEach(function (_id) {\n      res.push(_res[_id]);\n    });\n\n    return res;\n  }\n};\n\n\n/**\n * Get all documents in index whose key is between bounds are they are defined by query\n * Documents are sorted by key\n * @param {Query} query\n * @return {Array of documents}\n */\nIndex.prototype.getBetweenBounds = function (query) {\n  return this.tree.betweenBounds(query);\n};\n\n\n/**\n * Get all elements in the index\n * @return {Array of documents}\n */\nIndex.prototype.getAll = function () {\n  var res = [];\n\n  this.tree.executeOnEveryNode(function (node) {\n    var i;\n\n    for (i = 0; i < node.data.length; i += 1) {\n      res.push(node.data[i]);\n    }\n  });\n\n  return res;\n};\n\n\n\n\n// Interface\nmodule.exports = Index;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9uZWRiL2xpYi9pbmRleGVzLmpzP2NmODciXSwic291cmNlc0NvbnRlbnQiOlsidmFyIEJpbmFyeVNlYXJjaFRyZWUgPSByZXF1aXJlKCdiaW5hcnktc2VhcmNoLXRyZWUnKS5BVkxUcmVlXG4gICwgbW9kZWwgPSByZXF1aXJlKCcuL21vZGVsJylcbiAgLCBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpXG4gICwgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKVxuICA7XG5cbi8qKlxuICogVHdvIGluZGV4ZWQgcG9pbnRlcnMgYXJlIGVxdWFsIGlpZiB0aGV5IHBvaW50IHRvIHRoZSBzYW1lIHBsYWNlXG4gKi9cbmZ1bmN0aW9uIGNoZWNrVmFsdWVFcXVhbGl0eSAoYSwgYikge1xuICByZXR1cm4gYSA9PT0gYjtcbn1cblxuLyoqXG4gKiBUeXBlLWF3YXJlIHByb2plY3Rpb25cbiAqL1xuZnVuY3Rpb24gcHJvamVjdEZvclVuaXF1ZSAoZWx0KSB7XG4gIGlmIChlbHQgPT09IG51bGwpIHsgcmV0dXJuICckbnVsbCc7IH1cbiAgaWYgKHR5cGVvZiBlbHQgPT09ICdzdHJpbmcnKSB7IHJldHVybiAnJHN0cmluZycgKyBlbHQ7IH1cbiAgaWYgKHR5cGVvZiBlbHQgPT09ICdib29sZWFuJykgeyByZXR1cm4gJyRib29sZWFuJyArIGVsdDsgfVxuICBpZiAodHlwZW9mIGVsdCA9PT0gJ251bWJlcicpIHsgcmV0dXJuICckbnVtYmVyJyArIGVsdDsgfVxuICBpZiAodXRpbC5pc0FycmF5KGVsdCkpIHsgcmV0dXJuICckZGF0ZScgKyBlbHQuZ2V0VGltZSgpOyB9XG5cbiAgcmV0dXJuIGVsdDsgICAvLyBBcnJheXMgYW5kIG9iamVjdHMsIHdpbGwgY2hlY2sgZm9yIHBvaW50ZXIgZXF1YWxpdHlcbn1cblxuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBpbmRleFxuICogQWxsIG1ldGhvZHMgb24gYW4gaW5kZXggZ3VhcmFudGVlIHRoYXQgZWl0aGVyIHRoZSB3aG9sZSBvcGVyYXRpb24gd2FzIHN1Y2Nlc3NmdWwgYW5kIHRoZSBpbmRleCBjaGFuZ2VkXG4gKiBvciB0aGUgb3BlcmF0aW9uIHdhcyB1bnN1Y2Nlc3NmdWwgYW5kIGFuIGVycm9yIGlzIHRocm93biB3aGlsZSB0aGUgaW5kZXggaXMgdW5jaGFuZ2VkXG4gKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy5maWVsZE5hbWUgT24gd2hpY2ggZmllbGQgc2hvdWxkIHRoZSBpbmRleCBhcHBseSAoY2FuIHVzZSBkb3Qgbm90YXRpb24gdG8gaW5kZXggb24gc3ViIGZpZWxkcylcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gb3B0aW9ucy51bmlxdWUgT3B0aW9uYWwsIGVuZm9yY2UgYSB1bmlxdWUgY29uc3RyYWludCAoZGVmYXVsdDogZmFsc2UpXG4gKiBAcGFyYW0ge0Jvb2xlYW59IG9wdGlvbnMuc3BhcnNlIE9wdGlvbmFsLCBhbGxvdyBhIHNwYXJzZSBpbmRleCAod2UgY2FuIGhhdmUgZG9jdW1lbnRzIGZvciB3aGljaCBmaWVsZE5hbWUgaXMgdW5kZWZpbmVkKSAoZGVmYXVsdDogZmFsc2UpXG4gKi9cbmZ1bmN0aW9uIEluZGV4IChvcHRpb25zKSB7XG4gIHRoaXMuZmllbGROYW1lID0gb3B0aW9ucy5maWVsZE5hbWU7XG4gIHRoaXMudW5pcXVlID0gb3B0aW9ucy51bmlxdWUgfHwgZmFsc2U7XG4gIHRoaXMuc3BhcnNlID0gb3B0aW9ucy5zcGFyc2UgfHwgZmFsc2U7XG5cbiAgdGhpcy50cmVlT3B0aW9ucyA9IHsgdW5pcXVlOiB0aGlzLnVuaXF1ZSwgY29tcGFyZUtleXM6IG1vZGVsLmNvbXBhcmVUaGluZ3MsIGNoZWNrVmFsdWVFcXVhbGl0eTogY2hlY2tWYWx1ZUVxdWFsaXR5IH07XG5cbiAgdGhpcy5yZXNldCgpOyAgIC8vIE5vIGRhdGEgaW4gdGhlIGJlZ2lubmluZ1xufVxuXG5cbi8qKlxuICogUmVzZXQgYW4gaW5kZXhcbiAqIEBwYXJhbSB7RG9jdW1lbnQgb3IgQXJyYXkgb2YgZG9jdW1lbnRzfSBuZXdEYXRhIE9wdGlvbmFsLCBkYXRhIHRvIGluaXRpYWxpemUgdGhlIGluZGV4IHdpdGhcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElmIGFuIGVycm9yIGlzIHRocm93biBkdXJpbmcgaW5zZXJ0aW9uLCB0aGUgaW5kZXggaXMgbm90IG1vZGlmaWVkXG4gKi9cbkluZGV4LnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uIChuZXdEYXRhKSB7XG4gIHRoaXMudHJlZSA9IG5ldyBCaW5hcnlTZWFyY2hUcmVlKHRoaXMudHJlZU9wdGlvbnMpO1xuXG4gIGlmIChuZXdEYXRhKSB7IHRoaXMuaW5zZXJ0KG5ld0RhdGEpOyB9XG59O1xuXG5cbi8qKlxuICogSW5zZXJ0IGEgbmV3IGRvY3VtZW50IGluIHRoZSBpbmRleFxuICogSWYgYW4gYXJyYXkgaXMgcGFzc2VkLCB3ZSBpbnNlcnQgYWxsIGl0cyBlbGVtZW50cyAoaWYgb25lIGluc2VydGlvbiBmYWlscyB0aGUgaW5kZXggaXMgbm90IG1vZGlmaWVkKVxuICogTyhsb2cobikpXG4gKi9cbkluZGV4LnByb3RvdHlwZS5pbnNlcnQgPSBmdW5jdGlvbiAoZG9jKSB7XG4gIHZhciBrZXksIHNlbGYgPSB0aGlzXG4gICAgLCBrZXlzLCBpLCBmYWlsaW5nSSwgZXJyb3JcbiAgICA7XG5cbiAgaWYgKHV0aWwuaXNBcnJheShkb2MpKSB7IHRoaXMuaW5zZXJ0TXVsdGlwbGVEb2NzKGRvYyk7IHJldHVybjsgfVxuXG4gIGtleSA9IG1vZGVsLmdldERvdFZhbHVlKGRvYywgdGhpcy5maWVsZE5hbWUpO1xuXG4gIC8vIFdlIGRvbid0IGluZGV4IGRvY3VtZW50cyB0aGF0IGRvbid0IGNvbnRhaW4gdGhlIGZpZWxkIGlmIHRoZSBpbmRleCBpcyBzcGFyc2VcbiAgaWYgKGtleSA9PT0gdW5kZWZpbmVkICYmIHRoaXMuc3BhcnNlKSB7IHJldHVybjsgfVxuXG4gIGlmICghdXRpbC5pc0FycmF5KGtleSkpIHtcbiAgICB0aGlzLnRyZWUuaW5zZXJ0KGtleSwgZG9jKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBJZiBhbiBpbnNlcnQgZmFpbHMgZHVlIHRvIGEgdW5pcXVlIGNvbnN0cmFpbnQsIHJvbGwgYmFjayBhbGwgaW5zZXJ0cyBiZWZvcmUgaXRcbiAgICBrZXlzID0gXy51bmlxKGtleSwgcHJvamVjdEZvclVuaXF1ZSk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy50cmVlLmluc2VydChrZXlzW2ldLCBkb2MpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBlcnJvciA9IGU7XG4gICAgICAgIGZhaWxpbmdJID0gaTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGVycm9yKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgZmFpbGluZ0k7IGkgKz0gMSkge1xuICAgICAgICB0aGlzLnRyZWUuZGVsZXRlKGtleXNbaV0sIGRvYyk7XG4gICAgICB9XG5cbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxufTtcblxuXG4vKipcbiAqIEluc2VydCBhbiBhcnJheSBvZiBkb2N1bWVudHMgaW4gdGhlIGluZGV4XG4gKiBJZiBhIGNvbnN0cmFpbnQgaXMgdmlvbGF0ZWQsIHRoZSBjaGFuZ2VzIHNob3VsZCBiZSByb2xsZWQgYmFjayBhbmQgYW4gZXJyb3IgdGhyb3duXG4gKlxuICogQEFQSSBwcml2YXRlXG4gKi9cbkluZGV4LnByb3RvdHlwZS5pbnNlcnRNdWx0aXBsZURvY3MgPSBmdW5jdGlvbiAoZG9jcykge1xuICB2YXIgaSwgZXJyb3IsIGZhaWxpbmdJO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBkb2NzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuaW5zZXJ0KGRvY3NbaV0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGVycm9yID0gZTtcbiAgICAgIGZhaWxpbmdJID0gaTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGlmIChlcnJvcikge1xuICAgIGZvciAoaSA9IDA7IGkgPCBmYWlsaW5nSTsgaSArPSAxKSB7XG4gICAgICB0aGlzLnJlbW92ZShkb2NzW2ldKTtcbiAgICB9XG5cbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufTtcblxuXG4vKipcbiAqIFJlbW92ZSBhIGRvY3VtZW50IGZyb20gdGhlIGluZGV4XG4gKiBJZiBhbiBhcnJheSBpcyBwYXNzZWQsIHdlIHJlbW92ZSBhbGwgaXRzIGVsZW1lbnRzXG4gKiBUaGUgcmVtb3ZlIG9wZXJhdGlvbiBpcyBzYWZlIHdpdGggcmVnYXJkcyB0byB0aGUgJ3VuaXF1ZScgY29uc3RyYWludFxuICogTyhsb2cobikpXG4gKi9cbkluZGV4LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoZG9jKSB7XG4gIHZhciBrZXksIHNlbGYgPSB0aGlzO1xuXG4gIGlmICh1dGlsLmlzQXJyYXkoZG9jKSkgeyBkb2MuZm9yRWFjaChmdW5jdGlvbiAoZCkgeyBzZWxmLnJlbW92ZShkKTsgfSk7IHJldHVybjsgfVxuXG4gIGtleSA9IG1vZGVsLmdldERvdFZhbHVlKGRvYywgdGhpcy5maWVsZE5hbWUpO1xuXG4gIGlmIChrZXkgPT09IHVuZGVmaW5lZCAmJiB0aGlzLnNwYXJzZSkgeyByZXR1cm47IH1cblxuICBpZiAoIXV0aWwuaXNBcnJheShrZXkpKSB7XG4gICAgdGhpcy50cmVlLmRlbGV0ZShrZXksIGRvYyk7XG4gIH0gZWxzZSB7XG4gICAgXy51bmlxKGtleSwgcHJvamVjdEZvclVuaXF1ZSkuZm9yRWFjaChmdW5jdGlvbiAoX2tleSkge1xuICAgICAgc2VsZi50cmVlLmRlbGV0ZShfa2V5LCBkb2MpO1xuICAgIH0pO1xuICB9XG59O1xuXG5cbi8qKlxuICogVXBkYXRlIGEgZG9jdW1lbnQgaW4gdGhlIGluZGV4XG4gKiBJZiBhIGNvbnN0cmFpbnQgaXMgdmlvbGF0ZWQsIGNoYW5nZXMgYXJlIHJvbGxlZCBiYWNrIGFuZCBhbiBlcnJvciB0aHJvd25cbiAqIE5haXZlIGltcGxlbWVudGF0aW9uLCBzdGlsbCBpbiBPKGxvZyhuKSlcbiAqL1xuSW5kZXgucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChvbGREb2MsIG5ld0RvYykge1xuICBpZiAodXRpbC5pc0FycmF5KG9sZERvYykpIHsgdGhpcy51cGRhdGVNdWx0aXBsZURvY3Mob2xkRG9jKTsgcmV0dXJuOyB9XG5cbiAgdGhpcy5yZW1vdmUob2xkRG9jKTtcblxuICB0cnkge1xuICAgIHRoaXMuaW5zZXJ0KG5ld0RvYyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aGlzLmluc2VydChvbGREb2MpO1xuICAgIHRocm93IGU7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBVcGRhdGUgbXVsdGlwbGUgZG9jdW1lbnRzIGluIHRoZSBpbmRleFxuICogSWYgYSBjb25zdHJhaW50IGlzIHZpb2xhdGVkLCB0aGUgY2hhbmdlcyBuZWVkIHRvIGJlIHJvbGxlZCBiYWNrXG4gKiBhbmQgYW4gZXJyb3IgdGhyb3duXG4gKiBAcGFyYW0ge0FycmF5IG9mIG9sZERvYywgbmV3RG9jIHBhaXJzfSBwYWlyc1xuICpcbiAqIEBBUEkgcHJpdmF0ZVxuICovXG5JbmRleC5wcm90b3R5cGUudXBkYXRlTXVsdGlwbGVEb2NzID0gZnVuY3Rpb24gKHBhaXJzKSB7XG4gIHZhciBpLCBmYWlsaW5nSSwgZXJyb3I7XG5cbiAgZm9yIChpID0gMDsgaSA8IHBhaXJzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgdGhpcy5yZW1vdmUocGFpcnNbaV0ub2xkRG9jKTtcbiAgfVxuXG4gIGZvciAoaSA9IDA7IGkgPCBwYWlycy5sZW5ndGg7IGkgKz0gMSkge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLmluc2VydChwYWlyc1tpXS5uZXdEb2MpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGVycm9yID0gZTtcbiAgICAgIGZhaWxpbmdJID0gaTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIC8vIElmIGFuIGVycm9yIHdhcyByYWlzZWQsIHJvbGwgYmFjayBjaGFuZ2VzIGluIHRoZSBpbnZlcnNlIG9yZGVyXG4gIGlmIChlcnJvcikge1xuICAgIGZvciAoaSA9IDA7IGkgPCBmYWlsaW5nSTsgaSArPSAxKSB7XG4gICAgICB0aGlzLnJlbW92ZShwYWlyc1tpXS5uZXdEb2MpO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCBwYWlycy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgdGhpcy5pbnNlcnQocGFpcnNbaV0ub2xkRG9jKTtcbiAgICB9XG5cbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufTtcblxuXG4vKipcbiAqIFJldmVydCBhbiB1cGRhdGVcbiAqL1xuSW5kZXgucHJvdG90eXBlLnJldmVydFVwZGF0ZSA9IGZ1bmN0aW9uIChvbGREb2MsIG5ld0RvYykge1xuICB2YXIgcmV2ZXJ0ID0gW107XG5cbiAgaWYgKCF1dGlsLmlzQXJyYXkob2xkRG9jKSkge1xuICAgIHRoaXMudXBkYXRlKG5ld0RvYywgb2xkRG9jKTtcbiAgfSBlbHNlIHtcbiAgICBvbGREb2MuZm9yRWFjaChmdW5jdGlvbiAocGFpcikge1xuICAgICAgcmV2ZXJ0LnB1c2goeyBvbGREb2M6IHBhaXIubmV3RG9jLCBuZXdEb2M6IHBhaXIub2xkRG9jIH0pO1xuICAgIH0pO1xuICAgIHRoaXMudXBkYXRlKHJldmVydCk7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBHZXQgYWxsIGRvY3VtZW50cyBpbiBpbmRleCB3aG9zZSBrZXkgbWF0Y2ggdmFsdWUgKGlmIGl0IGlzIGEgVGhpbmcpIG9yIG9uZSBvZiB0aGUgZWxlbWVudHMgb2YgdmFsdWUgKGlmIGl0IGlzIGFuIGFycmF5IG9mIFRoaW5ncylcbiAqIEBwYXJhbSB7VGhpbmd9IHZhbHVlIFZhbHVlIHRvIG1hdGNoIHRoZSBrZXkgYWdhaW5zdFxuICogQHJldHVybiB7QXJyYXkgb2YgZG9jdW1lbnRzfVxuICovXG5JbmRleC5wcm90b3R5cGUuZ2V0TWF0Y2hpbmcgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIGlmICghdXRpbC5pc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiBzZWxmLnRyZWUuc2VhcmNoKHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgX3JlcyA9IHt9LCByZXMgPSBbXTtcblxuICAgIHZhbHVlLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcbiAgICAgIHNlbGYuZ2V0TWF0Y2hpbmcodikuZm9yRWFjaChmdW5jdGlvbiAoZG9jKSB7XG4gICAgICAgIF9yZXNbZG9jLl9pZF0gPSBkb2M7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIE9iamVjdC5rZXlzKF9yZXMpLmZvckVhY2goZnVuY3Rpb24gKF9pZCkge1xuICAgICAgcmVzLnB1c2goX3Jlc1tfaWRdKTtcbiAgICB9KTtcblxuICAgIHJldHVybiByZXM7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBHZXQgYWxsIGRvY3VtZW50cyBpbiBpbmRleCB3aG9zZSBrZXkgaXMgYmV0d2VlbiBib3VuZHMgYXJlIHRoZXkgYXJlIGRlZmluZWQgYnkgcXVlcnlcbiAqIERvY3VtZW50cyBhcmUgc29ydGVkIGJ5IGtleVxuICogQHBhcmFtIHtRdWVyeX0gcXVlcnlcbiAqIEByZXR1cm4ge0FycmF5IG9mIGRvY3VtZW50c31cbiAqL1xuSW5kZXgucHJvdG90eXBlLmdldEJldHdlZW5Cb3VuZHMgPSBmdW5jdGlvbiAocXVlcnkpIHtcbiAgcmV0dXJuIHRoaXMudHJlZS5iZXR3ZWVuQm91bmRzKHF1ZXJ5KTtcbn07XG5cblxuLyoqXG4gKiBHZXQgYWxsIGVsZW1lbnRzIGluIHRoZSBpbmRleFxuICogQHJldHVybiB7QXJyYXkgb2YgZG9jdW1lbnRzfVxuICovXG5JbmRleC5wcm90b3R5cGUuZ2V0QWxsID0gZnVuY3Rpb24gKCkge1xuICB2YXIgcmVzID0gW107XG5cbiAgdGhpcy50cmVlLmV4ZWN1dGVPbkV2ZXJ5Tm9kZShmdW5jdGlvbiAobm9kZSkge1xuICAgIHZhciBpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IG5vZGUuZGF0YS5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgcmVzLnB1c2gobm9kZS5kYXRhW2ldKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiByZXM7XG59O1xuXG5cblxuXG4vLyBJbnRlcmZhY2Vcbm1vZHVsZS5leHBvcnRzID0gSW5kZXg7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9uZWRiL2xpYi9pbmRleGVzLmpzXG4vLyBtb2R1bGUgaWQgPSA4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///8\n");

/***/ }),
/* 9 */
/*!****************************************************!*\
  !*** ./node_modules/binary-search-tree/lib/bst.js ***!
  \****************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * Simple binary search tree\n */\nvar customUtils = __webpack_require__(/*! ./customUtils */ 10);\n\n\n/**\n * Constructor\n * @param {Object} options Optional\n * @param {Boolean}  options.unique Whether to enforce a 'unique' constraint on the key or not\n * @param {Key}      options.key Initialize this BST's key with key\n * @param {Value}    options.value Initialize this BST's data with [value]\n * @param {Function} options.compareKeys Initialize this BST's compareKeys\n */\nfunction BinarySearchTree (options) {\n  options = options || {};\n\n  this.left = null;\n  this.right = null;\n  this.parent = options.parent !== undefined ? options.parent : null;\n  if (options.hasOwnProperty('key')) { this.key = options.key; }\n  this.data = options.hasOwnProperty('value') ? [options.value] : [];\n  this.unique = options.unique || false;\n\n  this.compareKeys = options.compareKeys || customUtils.defaultCompareKeysFunction;\n  this.checkValueEquality = options.checkValueEquality || customUtils.defaultCheckValueEquality;\n}\n\n\n// ================================\n// Methods used to test the tree\n// ================================\n\n\n/**\n * Get the descendant with max key\n */\nBinarySearchTree.prototype.getMaxKeyDescendant = function () {\n  if (this.right) {\n    return this.right.getMaxKeyDescendant();\n  } else {\n    return this;\n  }\n};\n\n\n/**\n * Get the maximum key\n */\nBinarySearchTree.prototype.getMaxKey = function () {\n  return this.getMaxKeyDescendant().key;\n};\n\n\n/**\n * Get the descendant with min key\n */\nBinarySearchTree.prototype.getMinKeyDescendant = function () {\n  if (this.left) {\n    return this.left.getMinKeyDescendant()\n  } else {\n    return this;\n  }\n};\n\n\n/**\n * Get the minimum key\n */\nBinarySearchTree.prototype.getMinKey = function () {\n  return this.getMinKeyDescendant().key;\n};\n\n\n/**\n * Check that all nodes (incl. leaves) fullfil condition given by fn\n * test is a function passed every (key, data) and which throws if the condition is not met\n */\nBinarySearchTree.prototype.checkAllNodesFullfillCondition = function (test) {\n  if (!this.hasOwnProperty('key')) { return; }\n\n  test(this.key, this.data);\n  if (this.left) { this.left.checkAllNodesFullfillCondition(test); }\n  if (this.right) { this.right.checkAllNodesFullfillCondition(test); }\n};\n\n\n/**\n * Check that the core BST properties on node ordering are verified\n * Throw if they aren't\n */\nBinarySearchTree.prototype.checkNodeOrdering = function () {\n  var self = this;\n\n  if (!this.hasOwnProperty('key')) { return; }\n\n  if (this.left) {\n    this.left.checkAllNodesFullfillCondition(function (k) {\n      if (self.compareKeys(k, self.key) >= 0) {\n        throw new Error('Tree with root ' + self.key + ' is not a binary search tree');\n      }\n    });\n    this.left.checkNodeOrdering();\n  }\n\n  if (this.right) {\n    this.right.checkAllNodesFullfillCondition(function (k) {\n      if (self.compareKeys(k, self.key) <= 0) {\n        throw new Error('Tree with root ' + self.key + ' is not a binary search tree');\n      }\n    });\n    this.right.checkNodeOrdering();\n  }\n};\n\n\n/**\n * Check that all pointers are coherent in this tree\n */\nBinarySearchTree.prototype.checkInternalPointers = function () {\n  if (this.left) {\n    if (this.left.parent !== this) { throw new Error('Parent pointer broken for key ' + this.key); }\n    this.left.checkInternalPointers();\n  }\n\n  if (this.right) {\n    if (this.right.parent !== this) { throw new Error('Parent pointer broken for key ' + this.key); }\n    this.right.checkInternalPointers();\n  }\n};\n\n\n/**\n * Check that a tree is a BST as defined here (node ordering and pointer references)\n */\nBinarySearchTree.prototype.checkIsBST = function () {\n  this.checkNodeOrdering();\n  this.checkInternalPointers();\n  if (this.parent) { throw new Error(\"The root shouldn't have a parent\"); }\n};\n\n\n/**\n * Get number of keys inserted\n */\nBinarySearchTree.prototype.getNumberOfKeys = function () {\n  var res;\n\n  if (!this.hasOwnProperty('key')) { return 0; }\n\n  res = 1;\n  if (this.left) { res += this.left.getNumberOfKeys(); }\n  if (this.right) { res += this.right.getNumberOfKeys(); }\n\n  return res;\n};\n\n\n\n// ============================================\n// Methods used to actually work on the tree\n// ============================================\n\n/**\n * Create a BST similar (i.e. same options except for key and value) to the current one\n * Use the same constructor (i.e. BinarySearchTree, AVLTree etc)\n * @param {Object} options see constructor\n */\nBinarySearchTree.prototype.createSimilar = function (options) {\n  options = options || {};\n  options.unique = this.unique;\n  options.compareKeys = this.compareKeys;\n  options.checkValueEquality = this.checkValueEquality;\n\n  return new this.constructor(options);\n};\n\n\n/**\n * Create the left child of this BST and return it\n */\nBinarySearchTree.prototype.createLeftChild = function (options) {\n  var leftChild = this.createSimilar(options);\n  leftChild.parent = this;\n  this.left = leftChild;\n\n  return leftChild;\n};\n\n\n/**\n * Create the right child of this BST and return it\n */\nBinarySearchTree.prototype.createRightChild = function (options) {\n  var rightChild = this.createSimilar(options);\n  rightChild.parent = this;\n  this.right = rightChild;\n\n  return rightChild;\n};\n\n\n/**\n * Insert a new element\n */\nBinarySearchTree.prototype.insert = function (key, value) {\n  // Empty tree, insert as root\n  if (!this.hasOwnProperty('key')) {\n    this.key = key;\n    this.data.push(value);\n    return;\n  }\n\n  // Same key as root\n  if (this.compareKeys(this.key, key) === 0) {\n    if (this.unique) {\n      var err = new Error(\"Can't insert key \" + key + \", it violates the unique constraint\");\n      err.key = key;\n      err.errorType = 'uniqueViolated';\n      throw err;\n    } else {\n      this.data.push(value);\n    }\n    return;\n  }\n\n  if (this.compareKeys(key, this.key) < 0) {\n    // Insert in left subtree\n    if (this.left) {\n      this.left.insert(key, value);\n    } else {\n      this.createLeftChild({ key: key, value: value });\n    }\n  } else {\n    // Insert in right subtree\n    if (this.right) {\n      this.right.insert(key, value);\n    } else {\n      this.createRightChild({ key: key, value: value });\n    }\n  }\n};\n\n\n/**\n * Search for all data corresponding to a key\n */\nBinarySearchTree.prototype.search = function (key) {\n  if (!this.hasOwnProperty('key')) { return []; }\n\n  if (this.compareKeys(this.key, key) === 0) { return this.data; }\n\n  if (this.compareKeys(key, this.key) < 0) {\n    if (this.left) {\n      return this.left.search(key);\n    } else {\n      return [];\n    }\n  } else {\n    if (this.right) {\n      return this.right.search(key);\n    } else {\n      return [];\n    }\n  }\n};\n\n\n/**\n * Return a function that tells whether a given key matches a lower bound\n */\nBinarySearchTree.prototype.getLowerBoundMatcher = function (query) {\n  var self = this;\n\n  // No lower bound\n  if (!query.hasOwnProperty('$gt') && !query.hasOwnProperty('$gte')) {\n    return function () { return true; };\n  }\n\n  if (query.hasOwnProperty('$gt') && query.hasOwnProperty('$gte')) {\n    if (self.compareKeys(query.$gte, query.$gt) === 0) {\n      return function (key) { return self.compareKeys(key, query.$gt) > 0; };\n    }\n\n    if (self.compareKeys(query.$gte, query.$gt) > 0) {\n      return function (key) { return self.compareKeys(key, query.$gte) >= 0; };\n    } else {\n      return function (key) { return self.compareKeys(key, query.$gt) > 0; };\n    }\n  }\n\n  if (query.hasOwnProperty('$gt')) {\n    return function (key) { return self.compareKeys(key, query.$gt) > 0; };\n  } else {\n    return function (key) { return self.compareKeys(key, query.$gte) >= 0; };\n  }\n};\n\n\n/**\n * Return a function that tells whether a given key matches an upper bound\n */\nBinarySearchTree.prototype.getUpperBoundMatcher = function (query) {\n  var self = this;\n\n  // No lower bound\n  if (!query.hasOwnProperty('$lt') && !query.hasOwnProperty('$lte')) {\n    return function () { return true; };\n  }\n\n  if (query.hasOwnProperty('$lt') && query.hasOwnProperty('$lte')) {\n    if (self.compareKeys(query.$lte, query.$lt) === 0) {\n      return function (key) { return self.compareKeys(key, query.$lt) < 0; };\n    }\n\n    if (self.compareKeys(query.$lte, query.$lt) < 0) {\n      return function (key) { return self.compareKeys(key, query.$lte) <= 0; };\n    } else {\n      return function (key) { return self.compareKeys(key, query.$lt) < 0; };\n    }\n  }\n\n  if (query.hasOwnProperty('$lt')) {\n    return function (key) { return self.compareKeys(key, query.$lt) < 0; };\n  } else {\n    return function (key) { return self.compareKeys(key, query.$lte) <= 0; };\n  }\n};\n\n\n// Append all elements in toAppend to array\nfunction append (array, toAppend) {\n  var i;\n\n  for (i = 0; i < toAppend.length; i += 1) {\n    array.push(toAppend[i]);\n  }\n}\n\n\n/**\n * Get all data for a key between bounds\n * Return it in key order\n * @param {Object} query Mongo-style query where keys are $lt, $lte, $gt or $gte (other keys are not considered)\n * @param {Functions} lbm/ubm matching functions calculated at the first recursive step\n */\nBinarySearchTree.prototype.betweenBounds = function (query, lbm, ubm) {\n  var res = [];\n\n  if (!this.hasOwnProperty('key')) { return []; }   // Empty tree\n\n  lbm = lbm || this.getLowerBoundMatcher(query);\n  ubm = ubm || this.getUpperBoundMatcher(query);\n\n  if (lbm(this.key) && this.left) { append(res, this.left.betweenBounds(query, lbm, ubm)); }\n  if (lbm(this.key) && ubm(this.key)) { append(res, this.data); }\n  if (ubm(this.key) && this.right) { append(res, this.right.betweenBounds(query, lbm, ubm)); }\n\n  return res;\n};\n\n\n/**\n * Delete the current node if it is a leaf\n * Return true if it was deleted\n */\nBinarySearchTree.prototype.deleteIfLeaf = function () {\n  if (this.left || this.right) { return false; }\n\n  // The leaf is itself a root\n  if (!this.parent) {\n    delete this.key;\n    this.data = [];\n    return true;\n  }\n\n  if (this.parent.left === this) {\n    this.parent.left = null;\n  } else {\n    this.parent.right = null;\n  }\n\n  return true;\n};\n\n\n/**\n * Delete the current node if it has only one child\n * Return true if it was deleted\n */\nBinarySearchTree.prototype.deleteIfOnlyOneChild = function () {\n  var child;\n\n  if (this.left && !this.right) { child = this.left; }\n  if (!this.left && this.right) { child = this.right; }\n  if (!child) { return false; }\n\n  // Root\n  if (!this.parent) {\n    this.key = child.key;\n    this.data = child.data;\n\n    this.left = null;\n    if (child.left) {\n      this.left = child.left;\n      child.left.parent = this;\n    }\n\n    this.right = null;\n    if (child.right) {\n      this.right = child.right;\n      child.right.parent = this;\n    }\n\n    return true;\n  }\n\n  if (this.parent.left === this) {\n    this.parent.left = child;\n    child.parent = this.parent;\n  } else {\n    this.parent.right = child;\n    child.parent = this.parent;\n  }\n\n  return true;\n};\n\n\n/**\n * Delete a key or just a value\n * @param {Key} key\n * @param {Value} value Optional. If not set, the whole key is deleted. If set, only this value is deleted\n */\nBinarySearchTree.prototype.delete = function (key, value) {\n  var newData = [], replaceWith\n    , self = this\n    ;\n\n  if (!this.hasOwnProperty('key')) { return; }\n\n  if (this.compareKeys(key, this.key) < 0) {\n    if (this.left) { this.left.delete(key, value); }\n    return;\n  }\n\n  if (this.compareKeys(key, this.key) > 0) {\n    if (this.right) { this.right.delete(key, value); }\n    return;\n  }\n\n  if (!this.compareKeys(key, this.key) === 0) { return; }\n\n  // Delete only a value\n  if (this.data.length > 1 && value !== undefined) {\n    this.data.forEach(function (d) {\n      if (!self.checkValueEquality(d, value)) { newData.push(d); }\n    });\n    self.data = newData;\n    return;\n  }\n\n  // Delete the whole node\n  if (this.deleteIfLeaf()) {\n    return;\n  }\n  if (this.deleteIfOnlyOneChild()) {\n    return;\n  }\n\n  // We are in the case where the node to delete has two children\n  if (Math.random() >= 0.5) {   // Randomize replacement to avoid unbalancing the tree too much\n    // Use the in-order predecessor\n    replaceWith = this.left.getMaxKeyDescendant();\n\n    this.key = replaceWith.key;\n    this.data = replaceWith.data;\n\n    if (this === replaceWith.parent) {   // Special case\n      this.left = replaceWith.left;\n      if (replaceWith.left) { replaceWith.left.parent = replaceWith.parent; }\n    } else {\n      replaceWith.parent.right = replaceWith.left;\n      if (replaceWith.left) { replaceWith.left.parent = replaceWith.parent; }\n    }\n  } else {\n    // Use the in-order successor\n    replaceWith = this.right.getMinKeyDescendant();\n\n    this.key = replaceWith.key;\n    this.data = replaceWith.data;\n\n    if (this === replaceWith.parent) {   // Special case\n      this.right = replaceWith.right;\n      if (replaceWith.right) { replaceWith.right.parent = replaceWith.parent; }\n    } else {\n      replaceWith.parent.left = replaceWith.right;\n      if (replaceWith.right) { replaceWith.right.parent = replaceWith.parent; }\n    }\n  }\n};\n\n\n/**\n * Execute a function on every node of the tree, in key order\n * @param {Function} fn Signature: node. Most useful will probably be node.key and node.data\n */\nBinarySearchTree.prototype.executeOnEveryNode = function (fn) {\n  if (this.left) { this.left.executeOnEveryNode(fn); }\n  fn(this);\n  if (this.right) { this.right.executeOnEveryNode(fn); }\n};\n\n\n/**\n * Pretty print a tree\n * @param {Boolean} printData To print the nodes' data along with the key\n */\nBinarySearchTree.prototype.prettyPrint = function (printData, spacing) {\n  spacing = spacing || \"\";\n\n  console.log(spacing + \"* \" + this.key);\n  if (printData) { console.log(spacing + \"* \" + this.data); }\n\n  if (!this.left && !this.right) { return; }\n\n  if (this.left) {\n    this.left.prettyPrint(printData, spacing + \"  \");\n  } else {\n    console.log(spacing + \"  *\");\n  }\n  if (this.right) {\n    this.right.prettyPrint(printData, spacing + \"  \");\n  } else {\n    console.log(spacing + \"  *\");\n  }\n};\n\n\n\n\n// Interface\nmodule.exports = BinarySearchTree;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9iaW5hcnktc2VhcmNoLXRyZWUvbGliL2JzdC5qcz81ZmFhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogU2ltcGxlIGJpbmFyeSBzZWFyY2ggdHJlZVxuICovXG52YXIgY3VzdG9tVXRpbHMgPSByZXF1aXJlKCcuL2N1c3RvbVV0aWxzJyk7XG5cblxuLyoqXG4gKiBDb25zdHJ1Y3RvclxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgT3B0aW9uYWxcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gIG9wdGlvbnMudW5pcXVlIFdoZXRoZXIgdG8gZW5mb3JjZSBhICd1bmlxdWUnIGNvbnN0cmFpbnQgb24gdGhlIGtleSBvciBub3RcbiAqIEBwYXJhbSB7S2V5fSAgICAgIG9wdGlvbnMua2V5IEluaXRpYWxpemUgdGhpcyBCU1QncyBrZXkgd2l0aCBrZXlcbiAqIEBwYXJhbSB7VmFsdWV9ICAgIG9wdGlvbnMudmFsdWUgSW5pdGlhbGl6ZSB0aGlzIEJTVCdzIGRhdGEgd2l0aCBbdmFsdWVdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcHRpb25zLmNvbXBhcmVLZXlzIEluaXRpYWxpemUgdGhpcyBCU1QncyBjb21wYXJlS2V5c1xuICovXG5mdW5jdGlvbiBCaW5hcnlTZWFyY2hUcmVlIChvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIHRoaXMubGVmdCA9IG51bGw7XG4gIHRoaXMucmlnaHQgPSBudWxsO1xuICB0aGlzLnBhcmVudCA9IG9wdGlvbnMucGFyZW50ICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnBhcmVudCA6IG51bGw7XG4gIGlmIChvcHRpb25zLmhhc093blByb3BlcnR5KCdrZXknKSkgeyB0aGlzLmtleSA9IG9wdGlvbnMua2V5OyB9XG4gIHRoaXMuZGF0YSA9IG9wdGlvbnMuaGFzT3duUHJvcGVydHkoJ3ZhbHVlJykgPyBbb3B0aW9ucy52YWx1ZV0gOiBbXTtcbiAgdGhpcy51bmlxdWUgPSBvcHRpb25zLnVuaXF1ZSB8fCBmYWxzZTtcblxuICB0aGlzLmNvbXBhcmVLZXlzID0gb3B0aW9ucy5jb21wYXJlS2V5cyB8fCBjdXN0b21VdGlscy5kZWZhdWx0Q29tcGFyZUtleXNGdW5jdGlvbjtcbiAgdGhpcy5jaGVja1ZhbHVlRXF1YWxpdHkgPSBvcHRpb25zLmNoZWNrVmFsdWVFcXVhbGl0eSB8fCBjdXN0b21VdGlscy5kZWZhdWx0Q2hlY2tWYWx1ZUVxdWFsaXR5O1xufVxuXG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBNZXRob2RzIHVzZWQgdG8gdGVzdCB0aGUgdHJlZVxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuXG4vKipcbiAqIEdldCB0aGUgZGVzY2VuZGFudCB3aXRoIG1heCBrZXlcbiAqL1xuQmluYXJ5U2VhcmNoVHJlZS5wcm90b3R5cGUuZ2V0TWF4S2V5RGVzY2VuZGFudCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMucmlnaHQpIHtcbiAgICByZXR1cm4gdGhpcy5yaWdodC5nZXRNYXhLZXlEZXNjZW5kYW50KCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBHZXQgdGhlIG1heGltdW0ga2V5XG4gKi9cbkJpbmFyeVNlYXJjaFRyZWUucHJvdG90eXBlLmdldE1heEtleSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuZ2V0TWF4S2V5RGVzY2VuZGFudCgpLmtleTtcbn07XG5cblxuLyoqXG4gKiBHZXQgdGhlIGRlc2NlbmRhbnQgd2l0aCBtaW4ga2V5XG4gKi9cbkJpbmFyeVNlYXJjaFRyZWUucHJvdG90eXBlLmdldE1pbktleURlc2NlbmRhbnQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmxlZnQpIHtcbiAgICByZXR1cm4gdGhpcy5sZWZ0LmdldE1pbktleURlc2NlbmRhbnQoKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG59O1xuXG5cbi8qKlxuICogR2V0IHRoZSBtaW5pbXVtIGtleVxuICovXG5CaW5hcnlTZWFyY2hUcmVlLnByb3RvdHlwZS5nZXRNaW5LZXkgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmdldE1pbktleURlc2NlbmRhbnQoKS5rZXk7XG59O1xuXG5cbi8qKlxuICogQ2hlY2sgdGhhdCBhbGwgbm9kZXMgKGluY2wuIGxlYXZlcykgZnVsbGZpbCBjb25kaXRpb24gZ2l2ZW4gYnkgZm5cbiAqIHRlc3QgaXMgYSBmdW5jdGlvbiBwYXNzZWQgZXZlcnkgKGtleSwgZGF0YSkgYW5kIHdoaWNoIHRocm93cyBpZiB0aGUgY29uZGl0aW9uIGlzIG5vdCBtZXRcbiAqL1xuQmluYXJ5U2VhcmNoVHJlZS5wcm90b3R5cGUuY2hlY2tBbGxOb2Rlc0Z1bGxmaWxsQ29uZGl0aW9uID0gZnVuY3Rpb24gKHRlc3QpIHtcbiAgaWYgKCF0aGlzLmhhc093blByb3BlcnR5KCdrZXknKSkgeyByZXR1cm47IH1cblxuICB0ZXN0KHRoaXMua2V5LCB0aGlzLmRhdGEpO1xuICBpZiAodGhpcy5sZWZ0KSB7IHRoaXMubGVmdC5jaGVja0FsbE5vZGVzRnVsbGZpbGxDb25kaXRpb24odGVzdCk7IH1cbiAgaWYgKHRoaXMucmlnaHQpIHsgdGhpcy5yaWdodC5jaGVja0FsbE5vZGVzRnVsbGZpbGxDb25kaXRpb24odGVzdCk7IH1cbn07XG5cblxuLyoqXG4gKiBDaGVjayB0aGF0IHRoZSBjb3JlIEJTVCBwcm9wZXJ0aWVzIG9uIG5vZGUgb3JkZXJpbmcgYXJlIHZlcmlmaWVkXG4gKiBUaHJvdyBpZiB0aGV5IGFyZW4ndFxuICovXG5CaW5hcnlTZWFyY2hUcmVlLnByb3RvdHlwZS5jaGVja05vZGVPcmRlcmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIGlmICghdGhpcy5oYXNPd25Qcm9wZXJ0eSgna2V5JykpIHsgcmV0dXJuOyB9XG5cbiAgaWYgKHRoaXMubGVmdCkge1xuICAgIHRoaXMubGVmdC5jaGVja0FsbE5vZGVzRnVsbGZpbGxDb25kaXRpb24oZnVuY3Rpb24gKGspIHtcbiAgICAgIGlmIChzZWxmLmNvbXBhcmVLZXlzKGssIHNlbGYua2V5KSA+PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVHJlZSB3aXRoIHJvb3QgJyArIHNlbGYua2V5ICsgJyBpcyBub3QgYSBiaW5hcnkgc2VhcmNoIHRyZWUnKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmxlZnQuY2hlY2tOb2RlT3JkZXJpbmcoKTtcbiAgfVxuXG4gIGlmICh0aGlzLnJpZ2h0KSB7XG4gICAgdGhpcy5yaWdodC5jaGVja0FsbE5vZGVzRnVsbGZpbGxDb25kaXRpb24oZnVuY3Rpb24gKGspIHtcbiAgICAgIGlmIChzZWxmLmNvbXBhcmVLZXlzKGssIHNlbGYua2V5KSA8PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVHJlZSB3aXRoIHJvb3QgJyArIHNlbGYua2V5ICsgJyBpcyBub3QgYSBiaW5hcnkgc2VhcmNoIHRyZWUnKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLnJpZ2h0LmNoZWNrTm9kZU9yZGVyaW5nKCk7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBDaGVjayB0aGF0IGFsbCBwb2ludGVycyBhcmUgY29oZXJlbnQgaW4gdGhpcyB0cmVlXG4gKi9cbkJpbmFyeVNlYXJjaFRyZWUucHJvdG90eXBlLmNoZWNrSW50ZXJuYWxQb2ludGVycyA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMubGVmdCkge1xuICAgIGlmICh0aGlzLmxlZnQucGFyZW50ICE9PSB0aGlzKSB7IHRocm93IG5ldyBFcnJvcignUGFyZW50IHBvaW50ZXIgYnJva2VuIGZvciBrZXkgJyArIHRoaXMua2V5KTsgfVxuICAgIHRoaXMubGVmdC5jaGVja0ludGVybmFsUG9pbnRlcnMoKTtcbiAgfVxuXG4gIGlmICh0aGlzLnJpZ2h0KSB7XG4gICAgaWYgKHRoaXMucmlnaHQucGFyZW50ICE9PSB0aGlzKSB7IHRocm93IG5ldyBFcnJvcignUGFyZW50IHBvaW50ZXIgYnJva2VuIGZvciBrZXkgJyArIHRoaXMua2V5KTsgfVxuICAgIHRoaXMucmlnaHQuY2hlY2tJbnRlcm5hbFBvaW50ZXJzKCk7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBDaGVjayB0aGF0IGEgdHJlZSBpcyBhIEJTVCBhcyBkZWZpbmVkIGhlcmUgKG5vZGUgb3JkZXJpbmcgYW5kIHBvaW50ZXIgcmVmZXJlbmNlcylcbiAqL1xuQmluYXJ5U2VhcmNoVHJlZS5wcm90b3R5cGUuY2hlY2tJc0JTVCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5jaGVja05vZGVPcmRlcmluZygpO1xuICB0aGlzLmNoZWNrSW50ZXJuYWxQb2ludGVycygpO1xuICBpZiAodGhpcy5wYXJlbnQpIHsgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHJvb3Qgc2hvdWxkbid0IGhhdmUgYSBwYXJlbnRcIik7IH1cbn07XG5cblxuLyoqXG4gKiBHZXQgbnVtYmVyIG9mIGtleXMgaW5zZXJ0ZWRcbiAqL1xuQmluYXJ5U2VhcmNoVHJlZS5wcm90b3R5cGUuZ2V0TnVtYmVyT2ZLZXlzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgcmVzO1xuXG4gIGlmICghdGhpcy5oYXNPd25Qcm9wZXJ0eSgna2V5JykpIHsgcmV0dXJuIDA7IH1cblxuICByZXMgPSAxO1xuICBpZiAodGhpcy5sZWZ0KSB7IHJlcyArPSB0aGlzLmxlZnQuZ2V0TnVtYmVyT2ZLZXlzKCk7IH1cbiAgaWYgKHRoaXMucmlnaHQpIHsgcmVzICs9IHRoaXMucmlnaHQuZ2V0TnVtYmVyT2ZLZXlzKCk7IH1cblxuICByZXR1cm4gcmVzO1xufTtcblxuXG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBNZXRob2RzIHVzZWQgdG8gYWN0dWFsbHkgd29yayBvbiB0aGUgdHJlZVxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuLyoqXG4gKiBDcmVhdGUgYSBCU1Qgc2ltaWxhciAoaS5lLiBzYW1lIG9wdGlvbnMgZXhjZXB0IGZvciBrZXkgYW5kIHZhbHVlKSB0byB0aGUgY3VycmVudCBvbmVcbiAqIFVzZSB0aGUgc2FtZSBjb25zdHJ1Y3RvciAoaS5lLiBCaW5hcnlTZWFyY2hUcmVlLCBBVkxUcmVlIGV0YylcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIHNlZSBjb25zdHJ1Y3RvclxuICovXG5CaW5hcnlTZWFyY2hUcmVlLnByb3RvdHlwZS5jcmVhdGVTaW1pbGFyID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIG9wdGlvbnMudW5pcXVlID0gdGhpcy51bmlxdWU7XG4gIG9wdGlvbnMuY29tcGFyZUtleXMgPSB0aGlzLmNvbXBhcmVLZXlzO1xuICBvcHRpb25zLmNoZWNrVmFsdWVFcXVhbGl0eSA9IHRoaXMuY2hlY2tWYWx1ZUVxdWFsaXR5O1xuXG4gIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcihvcHRpb25zKTtcbn07XG5cblxuLyoqXG4gKiBDcmVhdGUgdGhlIGxlZnQgY2hpbGQgb2YgdGhpcyBCU1QgYW5kIHJldHVybiBpdFxuICovXG5CaW5hcnlTZWFyY2hUcmVlLnByb3RvdHlwZS5jcmVhdGVMZWZ0Q2hpbGQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICB2YXIgbGVmdENoaWxkID0gdGhpcy5jcmVhdGVTaW1pbGFyKG9wdGlvbnMpO1xuICBsZWZ0Q2hpbGQucGFyZW50ID0gdGhpcztcbiAgdGhpcy5sZWZ0ID0gbGVmdENoaWxkO1xuXG4gIHJldHVybiBsZWZ0Q2hpbGQ7XG59O1xuXG5cbi8qKlxuICogQ3JlYXRlIHRoZSByaWdodCBjaGlsZCBvZiB0aGlzIEJTVCBhbmQgcmV0dXJuIGl0XG4gKi9cbkJpbmFyeVNlYXJjaFRyZWUucHJvdG90eXBlLmNyZWF0ZVJpZ2h0Q2hpbGQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICB2YXIgcmlnaHRDaGlsZCA9IHRoaXMuY3JlYXRlU2ltaWxhcihvcHRpb25zKTtcbiAgcmlnaHRDaGlsZC5wYXJlbnQgPSB0aGlzO1xuICB0aGlzLnJpZ2h0ID0gcmlnaHRDaGlsZDtcblxuICByZXR1cm4gcmlnaHRDaGlsZDtcbn07XG5cblxuLyoqXG4gKiBJbnNlcnQgYSBuZXcgZWxlbWVudFxuICovXG5CaW5hcnlTZWFyY2hUcmVlLnByb3RvdHlwZS5pbnNlcnQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAvLyBFbXB0eSB0cmVlLCBpbnNlcnQgYXMgcm9vdFxuICBpZiAoIXRoaXMuaGFzT3duUHJvcGVydHkoJ2tleScpKSB7XG4gICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgdGhpcy5kYXRhLnB1c2godmFsdWUpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIFNhbWUga2V5IGFzIHJvb3RcbiAgaWYgKHRoaXMuY29tcGFyZUtleXModGhpcy5rZXksIGtleSkgPT09IDApIHtcbiAgICBpZiAodGhpcy51bmlxdWUpIHtcbiAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoXCJDYW4ndCBpbnNlcnQga2V5IFwiICsga2V5ICsgXCIsIGl0IHZpb2xhdGVzIHRoZSB1bmlxdWUgY29uc3RyYWludFwiKTtcbiAgICAgIGVyci5rZXkgPSBrZXk7XG4gICAgICBlcnIuZXJyb3JUeXBlID0gJ3VuaXF1ZVZpb2xhdGVkJztcbiAgICAgIHRocm93IGVycjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kYXRhLnB1c2godmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAodGhpcy5jb21wYXJlS2V5cyhrZXksIHRoaXMua2V5KSA8IDApIHtcbiAgICAvLyBJbnNlcnQgaW4gbGVmdCBzdWJ0cmVlXG4gICAgaWYgKHRoaXMubGVmdCkge1xuICAgICAgdGhpcy5sZWZ0Lmluc2VydChrZXksIHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jcmVhdGVMZWZ0Q2hpbGQoeyBrZXk6IGtleSwgdmFsdWU6IHZhbHVlIH0pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBJbnNlcnQgaW4gcmlnaHQgc3VidHJlZVxuICAgIGlmICh0aGlzLnJpZ2h0KSB7XG4gICAgICB0aGlzLnJpZ2h0Lmluc2VydChrZXksIHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jcmVhdGVSaWdodENoaWxkKHsga2V5OiBrZXksIHZhbHVlOiB2YWx1ZSB9KTtcbiAgICB9XG4gIH1cbn07XG5cblxuLyoqXG4gKiBTZWFyY2ggZm9yIGFsbCBkYXRhIGNvcnJlc3BvbmRpbmcgdG8gYSBrZXlcbiAqL1xuQmluYXJ5U2VhcmNoVHJlZS5wcm90b3R5cGUuc2VhcmNoID0gZnVuY3Rpb24gKGtleSkge1xuICBpZiAoIXRoaXMuaGFzT3duUHJvcGVydHkoJ2tleScpKSB7IHJldHVybiBbXTsgfVxuXG4gIGlmICh0aGlzLmNvbXBhcmVLZXlzKHRoaXMua2V5LCBrZXkpID09PSAwKSB7IHJldHVybiB0aGlzLmRhdGE7IH1cblxuICBpZiAodGhpcy5jb21wYXJlS2V5cyhrZXksIHRoaXMua2V5KSA8IDApIHtcbiAgICBpZiAodGhpcy5sZWZ0KSB7XG4gICAgICByZXR1cm4gdGhpcy5sZWZ0LnNlYXJjaChrZXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICh0aGlzLnJpZ2h0KSB7XG4gICAgICByZXR1cm4gdGhpcy5yaWdodC5zZWFyY2goa2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfVxufTtcblxuXG4vKipcbiAqIFJldHVybiBhIGZ1bmN0aW9uIHRoYXQgdGVsbHMgd2hldGhlciBhIGdpdmVuIGtleSBtYXRjaGVzIGEgbG93ZXIgYm91bmRcbiAqL1xuQmluYXJ5U2VhcmNoVHJlZS5wcm90b3R5cGUuZ2V0TG93ZXJCb3VuZE1hdGNoZXIgPSBmdW5jdGlvbiAocXVlcnkpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIC8vIE5vIGxvd2VyIGJvdW5kXG4gIGlmICghcXVlcnkuaGFzT3duUHJvcGVydHkoJyRndCcpICYmICFxdWVyeS5oYXNPd25Qcm9wZXJ0eSgnJGd0ZScpKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRydWU7IH07XG4gIH1cblxuICBpZiAocXVlcnkuaGFzT3duUHJvcGVydHkoJyRndCcpICYmIHF1ZXJ5Lmhhc093blByb3BlcnR5KCckZ3RlJykpIHtcbiAgICBpZiAoc2VsZi5jb21wYXJlS2V5cyhxdWVyeS4kZ3RlLCBxdWVyeS4kZ3QpID09PSAwKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gc2VsZi5jb21wYXJlS2V5cyhrZXksIHF1ZXJ5LiRndCkgPiAwOyB9O1xuICAgIH1cblxuICAgIGlmIChzZWxmLmNvbXBhcmVLZXlzKHF1ZXJ5LiRndGUsIHF1ZXJ5LiRndCkgPiAwKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gc2VsZi5jb21wYXJlS2V5cyhrZXksIHF1ZXJ5LiRndGUpID49IDA7IH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBzZWxmLmNvbXBhcmVLZXlzKGtleSwgcXVlcnkuJGd0KSA+IDA7IH07XG4gICAgfVxuICB9XG5cbiAgaWYgKHF1ZXJ5Lmhhc093blByb3BlcnR5KCckZ3QnKSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBzZWxmLmNvbXBhcmVLZXlzKGtleSwgcXVlcnkuJGd0KSA+IDA7IH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIHNlbGYuY29tcGFyZUtleXMoa2V5LCBxdWVyeS4kZ3RlKSA+PSAwOyB9O1xuICB9XG59O1xuXG5cbi8qKlxuICogUmV0dXJuIGEgZnVuY3Rpb24gdGhhdCB0ZWxscyB3aGV0aGVyIGEgZ2l2ZW4ga2V5IG1hdGNoZXMgYW4gdXBwZXIgYm91bmRcbiAqL1xuQmluYXJ5U2VhcmNoVHJlZS5wcm90b3R5cGUuZ2V0VXBwZXJCb3VuZE1hdGNoZXIgPSBmdW5jdGlvbiAocXVlcnkpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIC8vIE5vIGxvd2VyIGJvdW5kXG4gIGlmICghcXVlcnkuaGFzT3duUHJvcGVydHkoJyRsdCcpICYmICFxdWVyeS5oYXNPd25Qcm9wZXJ0eSgnJGx0ZScpKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRydWU7IH07XG4gIH1cblxuICBpZiAocXVlcnkuaGFzT3duUHJvcGVydHkoJyRsdCcpICYmIHF1ZXJ5Lmhhc093blByb3BlcnR5KCckbHRlJykpIHtcbiAgICBpZiAoc2VsZi5jb21wYXJlS2V5cyhxdWVyeS4kbHRlLCBxdWVyeS4kbHQpID09PSAwKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gc2VsZi5jb21wYXJlS2V5cyhrZXksIHF1ZXJ5LiRsdCkgPCAwOyB9O1xuICAgIH1cblxuICAgIGlmIChzZWxmLmNvbXBhcmVLZXlzKHF1ZXJ5LiRsdGUsIHF1ZXJ5LiRsdCkgPCAwKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gc2VsZi5jb21wYXJlS2V5cyhrZXksIHF1ZXJ5LiRsdGUpIDw9IDA7IH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBzZWxmLmNvbXBhcmVLZXlzKGtleSwgcXVlcnkuJGx0KSA8IDA7IH07XG4gICAgfVxuICB9XG5cbiAgaWYgKHF1ZXJ5Lmhhc093blByb3BlcnR5KCckbHQnKSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBzZWxmLmNvbXBhcmVLZXlzKGtleSwgcXVlcnkuJGx0KSA8IDA7IH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIHNlbGYuY29tcGFyZUtleXMoa2V5LCBxdWVyeS4kbHRlKSA8PSAwOyB9O1xuICB9XG59O1xuXG5cbi8vIEFwcGVuZCBhbGwgZWxlbWVudHMgaW4gdG9BcHBlbmQgdG8gYXJyYXlcbmZ1bmN0aW9uIGFwcGVuZCAoYXJyYXksIHRvQXBwZW5kKSB7XG4gIHZhciBpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCB0b0FwcGVuZC5sZW5ndGg7IGkgKz0gMSkge1xuICAgIGFycmF5LnB1c2godG9BcHBlbmRbaV0pO1xuICB9XG59XG5cblxuLyoqXG4gKiBHZXQgYWxsIGRhdGEgZm9yIGEga2V5IGJldHdlZW4gYm91bmRzXG4gKiBSZXR1cm4gaXQgaW4ga2V5IG9yZGVyXG4gKiBAcGFyYW0ge09iamVjdH0gcXVlcnkgTW9uZ28tc3R5bGUgcXVlcnkgd2hlcmUga2V5cyBhcmUgJGx0LCAkbHRlLCAkZ3Qgb3IgJGd0ZSAob3RoZXIga2V5cyBhcmUgbm90IGNvbnNpZGVyZWQpXG4gKiBAcGFyYW0ge0Z1bmN0aW9uc30gbGJtL3VibSBtYXRjaGluZyBmdW5jdGlvbnMgY2FsY3VsYXRlZCBhdCB0aGUgZmlyc3QgcmVjdXJzaXZlIHN0ZXBcbiAqL1xuQmluYXJ5U2VhcmNoVHJlZS5wcm90b3R5cGUuYmV0d2VlbkJvdW5kcyA9IGZ1bmN0aW9uIChxdWVyeSwgbGJtLCB1Ym0pIHtcbiAgdmFyIHJlcyA9IFtdO1xuXG4gIGlmICghdGhpcy5oYXNPd25Qcm9wZXJ0eSgna2V5JykpIHsgcmV0dXJuIFtdOyB9ICAgLy8gRW1wdHkgdHJlZVxuXG4gIGxibSA9IGxibSB8fCB0aGlzLmdldExvd2VyQm91bmRNYXRjaGVyKHF1ZXJ5KTtcbiAgdWJtID0gdWJtIHx8IHRoaXMuZ2V0VXBwZXJCb3VuZE1hdGNoZXIocXVlcnkpO1xuXG4gIGlmIChsYm0odGhpcy5rZXkpICYmIHRoaXMubGVmdCkgeyBhcHBlbmQocmVzLCB0aGlzLmxlZnQuYmV0d2VlbkJvdW5kcyhxdWVyeSwgbGJtLCB1Ym0pKTsgfVxuICBpZiAobGJtKHRoaXMua2V5KSAmJiB1Ym0odGhpcy5rZXkpKSB7IGFwcGVuZChyZXMsIHRoaXMuZGF0YSk7IH1cbiAgaWYgKHVibSh0aGlzLmtleSkgJiYgdGhpcy5yaWdodCkgeyBhcHBlbmQocmVzLCB0aGlzLnJpZ2h0LmJldHdlZW5Cb3VuZHMocXVlcnksIGxibSwgdWJtKSk7IH1cblxuICByZXR1cm4gcmVzO1xufTtcblxuXG4vKipcbiAqIERlbGV0ZSB0aGUgY3VycmVudCBub2RlIGlmIGl0IGlzIGEgbGVhZlxuICogUmV0dXJuIHRydWUgaWYgaXQgd2FzIGRlbGV0ZWRcbiAqL1xuQmluYXJ5U2VhcmNoVHJlZS5wcm90b3R5cGUuZGVsZXRlSWZMZWFmID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5sZWZ0IHx8IHRoaXMucmlnaHQpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgLy8gVGhlIGxlYWYgaXMgaXRzZWxmIGEgcm9vdFxuICBpZiAoIXRoaXMucGFyZW50KSB7XG4gICAgZGVsZXRlIHRoaXMua2V5O1xuICAgIHRoaXMuZGF0YSA9IFtdO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHRoaXMucGFyZW50LmxlZnQgPT09IHRoaXMpIHtcbiAgICB0aGlzLnBhcmVudC5sZWZ0ID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnBhcmVudC5yaWdodCA9IG51bGw7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuLyoqXG4gKiBEZWxldGUgdGhlIGN1cnJlbnQgbm9kZSBpZiBpdCBoYXMgb25seSBvbmUgY2hpbGRcbiAqIFJldHVybiB0cnVlIGlmIGl0IHdhcyBkZWxldGVkXG4gKi9cbkJpbmFyeVNlYXJjaFRyZWUucHJvdG90eXBlLmRlbGV0ZUlmT25seU9uZUNoaWxkID0gZnVuY3Rpb24gKCkge1xuICB2YXIgY2hpbGQ7XG5cbiAgaWYgKHRoaXMubGVmdCAmJiAhdGhpcy5yaWdodCkgeyBjaGlsZCA9IHRoaXMubGVmdDsgfVxuICBpZiAoIXRoaXMubGVmdCAmJiB0aGlzLnJpZ2h0KSB7IGNoaWxkID0gdGhpcy5yaWdodDsgfVxuICBpZiAoIWNoaWxkKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIC8vIFJvb3RcbiAgaWYgKCF0aGlzLnBhcmVudCkge1xuICAgIHRoaXMua2V5ID0gY2hpbGQua2V5O1xuICAgIHRoaXMuZGF0YSA9IGNoaWxkLmRhdGE7XG5cbiAgICB0aGlzLmxlZnQgPSBudWxsO1xuICAgIGlmIChjaGlsZC5sZWZ0KSB7XG4gICAgICB0aGlzLmxlZnQgPSBjaGlsZC5sZWZ0O1xuICAgICAgY2hpbGQubGVmdC5wYXJlbnQgPSB0aGlzO1xuICAgIH1cblxuICAgIHRoaXMucmlnaHQgPSBudWxsO1xuICAgIGlmIChjaGlsZC5yaWdodCkge1xuICAgICAgdGhpcy5yaWdodCA9IGNoaWxkLnJpZ2h0O1xuICAgICAgY2hpbGQucmlnaHQucGFyZW50ID0gdGhpcztcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICh0aGlzLnBhcmVudC5sZWZ0ID09PSB0aGlzKSB7XG4gICAgdGhpcy5wYXJlbnQubGVmdCA9IGNoaWxkO1xuICAgIGNoaWxkLnBhcmVudCA9IHRoaXMucGFyZW50O1xuICB9IGVsc2Uge1xuICAgIHRoaXMucGFyZW50LnJpZ2h0ID0gY2hpbGQ7XG4gICAgY2hpbGQucGFyZW50ID0gdGhpcy5wYXJlbnQ7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuLyoqXG4gKiBEZWxldGUgYSBrZXkgb3IganVzdCBhIHZhbHVlXG4gKiBAcGFyYW0ge0tleX0ga2V5XG4gKiBAcGFyYW0ge1ZhbHVlfSB2YWx1ZSBPcHRpb25hbC4gSWYgbm90IHNldCwgdGhlIHdob2xlIGtleSBpcyBkZWxldGVkLiBJZiBzZXQsIG9ubHkgdGhpcyB2YWx1ZSBpcyBkZWxldGVkXG4gKi9cbkJpbmFyeVNlYXJjaFRyZWUucHJvdG90eXBlLmRlbGV0ZSA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gIHZhciBuZXdEYXRhID0gW10sIHJlcGxhY2VXaXRoXG4gICAgLCBzZWxmID0gdGhpc1xuICAgIDtcblxuICBpZiAoIXRoaXMuaGFzT3duUHJvcGVydHkoJ2tleScpKSB7IHJldHVybjsgfVxuXG4gIGlmICh0aGlzLmNvbXBhcmVLZXlzKGtleSwgdGhpcy5rZXkpIDwgMCkge1xuICAgIGlmICh0aGlzLmxlZnQpIHsgdGhpcy5sZWZ0LmRlbGV0ZShrZXksIHZhbHVlKTsgfVxuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICh0aGlzLmNvbXBhcmVLZXlzKGtleSwgdGhpcy5rZXkpID4gMCkge1xuICAgIGlmICh0aGlzLnJpZ2h0KSB7IHRoaXMucmlnaHQuZGVsZXRlKGtleSwgdmFsdWUpOyB9XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKCF0aGlzLmNvbXBhcmVLZXlzKGtleSwgdGhpcy5rZXkpID09PSAwKSB7IHJldHVybjsgfVxuXG4gIC8vIERlbGV0ZSBvbmx5IGEgdmFsdWVcbiAgaWYgKHRoaXMuZGF0YS5sZW5ndGggPiAxICYmIHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzLmRhdGEuZm9yRWFjaChmdW5jdGlvbiAoZCkge1xuICAgICAgaWYgKCFzZWxmLmNoZWNrVmFsdWVFcXVhbGl0eShkLCB2YWx1ZSkpIHsgbmV3RGF0YS5wdXNoKGQpOyB9XG4gICAgfSk7XG4gICAgc2VsZi5kYXRhID0gbmV3RGF0YTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBEZWxldGUgdGhlIHdob2xlIG5vZGVcbiAgaWYgKHRoaXMuZGVsZXRlSWZMZWFmKCkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHRoaXMuZGVsZXRlSWZPbmx5T25lQ2hpbGQoKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIFdlIGFyZSBpbiB0aGUgY2FzZSB3aGVyZSB0aGUgbm9kZSB0byBkZWxldGUgaGFzIHR3byBjaGlsZHJlblxuICBpZiAoTWF0aC5yYW5kb20oKSA+PSAwLjUpIHsgICAvLyBSYW5kb21pemUgcmVwbGFjZW1lbnQgdG8gYXZvaWQgdW5iYWxhbmNpbmcgdGhlIHRyZWUgdG9vIG11Y2hcbiAgICAvLyBVc2UgdGhlIGluLW9yZGVyIHByZWRlY2Vzc29yXG4gICAgcmVwbGFjZVdpdGggPSB0aGlzLmxlZnQuZ2V0TWF4S2V5RGVzY2VuZGFudCgpO1xuXG4gICAgdGhpcy5rZXkgPSByZXBsYWNlV2l0aC5rZXk7XG4gICAgdGhpcy5kYXRhID0gcmVwbGFjZVdpdGguZGF0YTtcblxuICAgIGlmICh0aGlzID09PSByZXBsYWNlV2l0aC5wYXJlbnQpIHsgICAvLyBTcGVjaWFsIGNhc2VcbiAgICAgIHRoaXMubGVmdCA9IHJlcGxhY2VXaXRoLmxlZnQ7XG4gICAgICBpZiAocmVwbGFjZVdpdGgubGVmdCkgeyByZXBsYWNlV2l0aC5sZWZ0LnBhcmVudCA9IHJlcGxhY2VXaXRoLnBhcmVudDsgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXBsYWNlV2l0aC5wYXJlbnQucmlnaHQgPSByZXBsYWNlV2l0aC5sZWZ0O1xuICAgICAgaWYgKHJlcGxhY2VXaXRoLmxlZnQpIHsgcmVwbGFjZVdpdGgubGVmdC5wYXJlbnQgPSByZXBsYWNlV2l0aC5wYXJlbnQ7IH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gVXNlIHRoZSBpbi1vcmRlciBzdWNjZXNzb3JcbiAgICByZXBsYWNlV2l0aCA9IHRoaXMucmlnaHQuZ2V0TWluS2V5RGVzY2VuZGFudCgpO1xuXG4gICAgdGhpcy5rZXkgPSByZXBsYWNlV2l0aC5rZXk7XG4gICAgdGhpcy5kYXRhID0gcmVwbGFjZVdpdGguZGF0YTtcblxuICAgIGlmICh0aGlzID09PSByZXBsYWNlV2l0aC5wYXJlbnQpIHsgICAvLyBTcGVjaWFsIGNhc2VcbiAgICAgIHRoaXMucmlnaHQgPSByZXBsYWNlV2l0aC5yaWdodDtcbiAgICAgIGlmIChyZXBsYWNlV2l0aC5yaWdodCkgeyByZXBsYWNlV2l0aC5yaWdodC5wYXJlbnQgPSByZXBsYWNlV2l0aC5wYXJlbnQ7IH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmVwbGFjZVdpdGgucGFyZW50LmxlZnQgPSByZXBsYWNlV2l0aC5yaWdodDtcbiAgICAgIGlmIChyZXBsYWNlV2l0aC5yaWdodCkgeyByZXBsYWNlV2l0aC5yaWdodC5wYXJlbnQgPSByZXBsYWNlV2l0aC5wYXJlbnQ7IH1cbiAgICB9XG4gIH1cbn07XG5cblxuLyoqXG4gKiBFeGVjdXRlIGEgZnVuY3Rpb24gb24gZXZlcnkgbm9kZSBvZiB0aGUgdHJlZSwgaW4ga2V5IG9yZGVyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBTaWduYXR1cmU6IG5vZGUuIE1vc3QgdXNlZnVsIHdpbGwgcHJvYmFibHkgYmUgbm9kZS5rZXkgYW5kIG5vZGUuZGF0YVxuICovXG5CaW5hcnlTZWFyY2hUcmVlLnByb3RvdHlwZS5leGVjdXRlT25FdmVyeU5vZGUgPSBmdW5jdGlvbiAoZm4pIHtcbiAgaWYgKHRoaXMubGVmdCkgeyB0aGlzLmxlZnQuZXhlY3V0ZU9uRXZlcnlOb2RlKGZuKTsgfVxuICBmbih0aGlzKTtcbiAgaWYgKHRoaXMucmlnaHQpIHsgdGhpcy5yaWdodC5leGVjdXRlT25FdmVyeU5vZGUoZm4pOyB9XG59O1xuXG5cbi8qKlxuICogUHJldHR5IHByaW50IGEgdHJlZVxuICogQHBhcmFtIHtCb29sZWFufSBwcmludERhdGEgVG8gcHJpbnQgdGhlIG5vZGVzJyBkYXRhIGFsb25nIHdpdGggdGhlIGtleVxuICovXG5CaW5hcnlTZWFyY2hUcmVlLnByb3RvdHlwZS5wcmV0dHlQcmludCA9IGZ1bmN0aW9uIChwcmludERhdGEsIHNwYWNpbmcpIHtcbiAgc3BhY2luZyA9IHNwYWNpbmcgfHwgXCJcIjtcblxuICBjb25zb2xlLmxvZyhzcGFjaW5nICsgXCIqIFwiICsgdGhpcy5rZXkpO1xuICBpZiAocHJpbnREYXRhKSB7IGNvbnNvbGUubG9nKHNwYWNpbmcgKyBcIiogXCIgKyB0aGlzLmRhdGEpOyB9XG5cbiAgaWYgKCF0aGlzLmxlZnQgJiYgIXRoaXMucmlnaHQpIHsgcmV0dXJuOyB9XG5cbiAgaWYgKHRoaXMubGVmdCkge1xuICAgIHRoaXMubGVmdC5wcmV0dHlQcmludChwcmludERhdGEsIHNwYWNpbmcgKyBcIiAgXCIpO1xuICB9IGVsc2Uge1xuICAgIGNvbnNvbGUubG9nKHNwYWNpbmcgKyBcIiAgKlwiKTtcbiAgfVxuICBpZiAodGhpcy5yaWdodCkge1xuICAgIHRoaXMucmlnaHQucHJldHR5UHJpbnQocHJpbnREYXRhLCBzcGFjaW5nICsgXCIgIFwiKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zb2xlLmxvZyhzcGFjaW5nICsgXCIgICpcIik7XG4gIH1cbn07XG5cblxuXG5cbi8vIEludGVyZmFjZVxubW9kdWxlLmV4cG9ydHMgPSBCaW5hcnlTZWFyY2hUcmVlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYmluYXJ5LXNlYXJjaC10cmVlL2xpYi9ic3QuanNcbi8vIG1vZHVsZSBpZCA9IDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///9\n");

/***/ }),
/* 10 */
/*!************************************************************!*\
  !*** ./node_modules/binary-search-tree/lib/customUtils.js ***!
  \************************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports) {

eval("/**\n * Return an array with the numbers from 0 to n-1, in a random order\n */\nfunction getRandomArray (n) {\n  var res, next;\n\n  if (n === 0) { return []; }\n  if (n === 1) { return [0]; }\n\n  res = getRandomArray(n - 1);\n  next = Math.floor(Math.random() * n);\n  res.splice(next, 0, n - 1);   // Add n-1 at a random position in the array\n\n  return res;\n};\nmodule.exports.getRandomArray = getRandomArray;\n\n\n/*\n * Default compareKeys function will work for numbers, strings and dates\n */\nfunction defaultCompareKeysFunction (a, b) {\n  if (a < b) { return -1; }\n  if (a > b) { return 1; }\n  if (a === b) { return 0; }\n\n  var err = new Error(\"Couldn't compare elements\");\n  err.a = a;\n  err.b = b;\n  throw err;\n}\nmodule.exports.defaultCompareKeysFunction = defaultCompareKeysFunction;\n\n\n/**\n * Check whether two values are equal (used in non-unique deletion)\n */\nfunction defaultCheckValueEquality (a, b) {\n  return a === b;\n}\nmodule.exports.defaultCheckValueEquality = defaultCheckValueEquality;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmluYXJ5LXNlYXJjaC10cmVlL2xpYi9jdXN0b21VdGlscy5qcz9mYWJhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogUmV0dXJuIGFuIGFycmF5IHdpdGggdGhlIG51bWJlcnMgZnJvbSAwIHRvIG4tMSwgaW4gYSByYW5kb20gb3JkZXJcbiAqL1xuZnVuY3Rpb24gZ2V0UmFuZG9tQXJyYXkgKG4pIHtcbiAgdmFyIHJlcywgbmV4dDtcblxuICBpZiAobiA9PT0gMCkgeyByZXR1cm4gW107IH1cbiAgaWYgKG4gPT09IDEpIHsgcmV0dXJuIFswXTsgfVxuXG4gIHJlcyA9IGdldFJhbmRvbUFycmF5KG4gLSAxKTtcbiAgbmV4dCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIG4pO1xuICByZXMuc3BsaWNlKG5leHQsIDAsIG4gLSAxKTsgICAvLyBBZGQgbi0xIGF0IGEgcmFuZG9tIHBvc2l0aW9uIGluIHRoZSBhcnJheVxuXG4gIHJldHVybiByZXM7XG59O1xubW9kdWxlLmV4cG9ydHMuZ2V0UmFuZG9tQXJyYXkgPSBnZXRSYW5kb21BcnJheTtcblxuXG4vKlxuICogRGVmYXVsdCBjb21wYXJlS2V5cyBmdW5jdGlvbiB3aWxsIHdvcmsgZm9yIG51bWJlcnMsIHN0cmluZ3MgYW5kIGRhdGVzXG4gKi9cbmZ1bmN0aW9uIGRlZmF1bHRDb21wYXJlS2V5c0Z1bmN0aW9uIChhLCBiKSB7XG4gIGlmIChhIDwgYikgeyByZXR1cm4gLTE7IH1cbiAgaWYgKGEgPiBiKSB7IHJldHVybiAxOyB9XG4gIGlmIChhID09PSBiKSB7IHJldHVybiAwOyB9XG5cbiAgdmFyIGVyciA9IG5ldyBFcnJvcihcIkNvdWxkbid0IGNvbXBhcmUgZWxlbWVudHNcIik7XG4gIGVyci5hID0gYTtcbiAgZXJyLmIgPSBiO1xuICB0aHJvdyBlcnI7XG59XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0Q29tcGFyZUtleXNGdW5jdGlvbiA9IGRlZmF1bHRDb21wYXJlS2V5c0Z1bmN0aW9uO1xuXG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciB0d28gdmFsdWVzIGFyZSBlcXVhbCAodXNlZCBpbiBub24tdW5pcXVlIGRlbGV0aW9uKVxuICovXG5mdW5jdGlvbiBkZWZhdWx0Q2hlY2tWYWx1ZUVxdWFsaXR5IChhLCBiKSB7XG4gIHJldHVybiBhID09PSBiO1xufVxubW9kdWxlLmV4cG9ydHMuZGVmYXVsdENoZWNrVmFsdWVFcXVhbGl0eSA9IGRlZmF1bHRDaGVja1ZhbHVlRXF1YWxpdHk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9iaW5hcnktc2VhcmNoLXRyZWUvbGliL2N1c3RvbVV0aWxzLmpzXG4vLyBtb2R1bGUgaWQgPSAxMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///10\n");

/***/ }),
/* 11 */
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports) {

eval("module.exports = require(\"fs\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJmc1wiPzJlMDkiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiZnNcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJmc1wiXG4vLyBtb2R1bGUgaWQgPSAxMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///11\n");

/***/ }),
/* 12 */
/*!***********************!*\
  !*** ./src/server.js ***!
  \***********************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.stripResultsMetadata = stripResultsMetadata;\n\nvar _path = __webpack_require__(/*! path */ 2);\n\nvar _path2 = _interopRequireDefault(_path);\n\nvar _http = __webpack_require__(/*! http */ 13);\n\nvar _express = __webpack_require__(/*! express */ 14);\n\nvar _express2 = _interopRequireDefault(_express);\n\nvar _react = __webpack_require__(/*! react */ 0);\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _server = __webpack_require__(/*! react-dom/server */ 15);\n\nvar _reactRouterDom = __webpack_require__(/*! react-router-dom */ 3);\n\nvar _App = __webpack_require__(/*! ./components/App */ 16);\n\nvar _ws = __webpack_require__(/*! ws */ 20);\n\nvar _ws2 = _interopRequireDefault(_ws);\n\nvar _url = __webpack_require__(/*! url */ 21);\n\nvar _url2 = _interopRequireDefault(_url);\n\nvar _nedb = __webpack_require__(/*! nedb */ 22);\n\nvar _nedb2 = _interopRequireDefault(_nedb);\n\nvar _lokijs = __webpack_require__(/*! lokijs */ 33);\n\nvar _lokijs2 = _interopRequireDefault(_lokijs);\n\nvar _lokiFsStructuredAdapter = __webpack_require__(/*! lokijs/src/loki-fs-structured-adapter */ 34);\n\nvar _lokiFsStructuredAdapter2 = _interopRequireDefault(_lokiFsStructuredAdapter);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/* eslint no-console: \"off\" */\n\nvar app = new _express2.default();\nvar server = new _http.Server(app);\nvar wss = new _ws2.default.Server({ server: server });\n\n// use ejs templates\napp.set('view engine', 'ejs');\napp.set('views', _path2.default.join(__dirname, 'views'));\n\n// define the folder that will be used for static assets\napp.use(_express2.default.static(_path2.default.join(__dirname, 'static')));\n\nvar adapter = new _lokiFsStructuredAdapter2.default();\nvar db = new _lokijs2.default('/data/palju.db', {\n  autoload: true,\n  autoloadCallback: loadHandler,\n  autosave: true,\n  autosaveInterval: 10000, // 10 seconds\n  adapter: adapter,\n  verbose: true\n});\n\nfunction loadHandler() {\n  console.log(\"Load handler\");\n  // if database did not exist it will be empty so I will intitialize here\n  var coll = db.getCollection('palju');\n  if (coll === null) {\n    coll = db.addCollection('palju');\n  }\n}\n\napp.get('*', function (req, res) {\n  var markup = '';\n  var status = 200;\n\n  return res.status(status).render('index', { markup: markup });\n});\n\n// start the server\nvar port = process.env.PORT || 3000;\nvar env = process.env.NODE_ENV || 'production';\nserver.listen(port, function (err) {\n  if (err) {\n    return console.error(err);\n  }\n\n  return console.info('\\n      Server running on http://localhost:' + port + ' [' + env + ']\\n    ');\n});\n\nwss.on('connection', function (ws, req) {\n\n  console.log(\"Get paljuData\");\n  var paljuData = db.getCollection(\"palju\");\n\n  console.log(\"Connected with: \" + req.headers['sec-websocket-protocol']);\n  ws.clientType = req.headers['sec-websocket-protocol'];\n\n  ws.isAlive = true;\n  ws.on('pong', function () {\n    this.isAlive = true;\n  });\n\n  var location = _url2.default.parse(req.url, true);\n\n  // Send the latest record on connection\n  var timeHourAgo = Math.floor(new Date() / 1000) - 60 * 60; // Unix timestamp\n  var records = paljuData.chain().find({ 'timestamp': { '$gt': timeHourAgo } }).simplesort('timestamp').data();\n  var latestRecord = records.length > 0 ? records.pop() : {};\n  ws.send(JSON.stringify(stripResultsMetadata(latestRecord)));\n\n  ws.on('message', function incoming(message) {\n    console.log('received: %s', message);\n\n    // Parse data\n    var data = JSON.parse(message);\n    console.log(data.temp_low != null);\n    if (data.temp_low != null) {\n      var timeNow = Math.floor(new Date() / 1000); // Unix timestamp\n\n      var values = {\n        temp_low: parseFloat(data.temp_low),\n        temp_high: parseFloat(data.temp_high),\n        temp_ambient: parseFloat(data.temp_ambient),\n        warming_phase: data.warming_phase,\n        target: parseFloat(data.target),\n        low_limit: parseFloat(data.low_limit),\n        timestamp: timeNow,\n        estimation: (parseFloat(data.target) - parseFloat(data.temp_high)) / 10 * 60 * 60 + timeNow // 10 degrees in a hour\n      };\n\n      if (ws.clientType != 'mobile') {\n        paljuData.insert(values);\n      }\n\n      console.log(\"Sending to all clients\");\n      wss.clients.forEach(function each(client) {\n        console.log(\"Should we send to client:\" + client.clientType);\n\n        if (client.readyState === _ws2.default.OPEN && client !== ws /* to exclude the sender*/) {\n            console.log(\"Not self & is open\");\n            // Sender is mobile-app, or receiver is mobile app\n            if (ws.clientType == 'mobile' || client.clientType == 'mobile') {\n              console.log(\"Client is mobile or receiver is mobile\");\n              console.log(\"Sending to:\" + client.clientType);\n\n              client.send(JSON.stringify(stripResultsMetadata(values)));\n            }\n          }\n      });\n    } else if (data.from != null) {\n      // Send the latest 50\n      //data.find({}).sort({timestamp: 1}).limit(50).exec( (err, docs) => {\n      //    ws.send(JSON.stringify(docs))\n      //  })\n    }\n  });\n});\n\n// Ping connections every 30 seconds to keep them alive\nsetInterval(function () {\n  wss.clients.forEach(function (ws) {\n\n    if (ws.isAlive == false) {\n      console.log(\"KILLING WEBSOCKET CONNECTION\");\n      return ws.terminate();\n    }\n\n    ws.isAlive = false;\n    ws.ping(function () {});\n  });\n}, 10000);\n\nfunction stripResultsMetadata(results) {\n\n  var isArray = Array.isArray(results);\n\n  if (!isArray) results = [results];\n\n  var records = [];\n\n  for (var idx = 0; idx < results.length; idx++) {\n    var loki_rec = results[idx];\n    var clean_rec = Object.assign({}, loki_rec);\n    delete clean_rec['meta'];\n    delete clean_rec['$loki'];\n    records.push(clean_rec);\n  }\n  return isArray ? records : records.pop();\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL3NlcnZlci5qcz9lNmE1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludCBuby1jb25zb2xlOiBcIm9mZlwiICovXG5cbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IHsgU2VydmVyIH0gZnJvbSAnaHR0cCc7XG5pbXBvcnQgRXhwcmVzcyBmcm9tICdleHByZXNzJztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyByZW5kZXJUb1N0cmluZyB9IGZyb20gJ3JlYWN0LWRvbS9zZXJ2ZXInO1xuaW1wb3J0IHsgU3RhdGljUm91dGVyIGFzIFJvdXRlciB9IGZyb20gJ3JlYWN0LXJvdXRlci1kb20nO1xuaW1wb3J0IHsgQXBwIH0gZnJvbSAnLi9jb21wb25lbnRzL0FwcCc7XG5cbmltcG9ydCBXZWJTb2NrZXQgZnJvbSAnd3MnO1xuaW1wb3J0IHVybCBmcm9tICd1cmwnO1xuXG5pbXBvcnQgRGF0YXN0b3JlIGZyb20gJ25lZGInO1xuaW1wb3J0IGxva2kgZnJvbSAnbG9raWpzJ1xuaW1wb3J0IGxmc2EgIGZyb20gJ2xva2lqcy9zcmMvbG9raS1mcy1zdHJ1Y3R1cmVkLWFkYXB0ZXInXG5cbmNvbnN0IGFwcCA9IG5ldyBFeHByZXNzKCk7XG5jb25zdCBzZXJ2ZXIgPSBuZXcgU2VydmVyKGFwcCk7XG5jb25zdCB3c3MgPSBuZXcgV2ViU29ja2V0LlNlcnZlcih7IHNlcnZlciB9KTtcblxuLy8gdXNlIGVqcyB0ZW1wbGF0ZXNcbmFwcC5zZXQoJ3ZpZXcgZW5naW5lJywgJ2VqcycpO1xuYXBwLnNldCgndmlld3MnLCBwYXRoLmpvaW4oX19kaXJuYW1lLCAndmlld3MnKSk7XG5cbi8vIGRlZmluZSB0aGUgZm9sZGVyIHRoYXQgd2lsbCBiZSB1c2VkIGZvciBzdGF0aWMgYXNzZXRzXG5hcHAudXNlKEV4cHJlc3Muc3RhdGljKHBhdGguam9pbihfX2Rpcm5hbWUsICdzdGF0aWMnKSkpO1xuXG5cbnZhciBhZGFwdGVyID0gbmV3IGxmc2EoKTtcbnZhciBkYiA9IG5ldyBsb2tpKCcvZGF0YS9wYWxqdS5kYicsIFxuICB7XG4gICAgYXV0b2xvYWQ6IHRydWUsXG4gICAgYXV0b2xvYWRDYWxsYmFjayA6IGxvYWRIYW5kbGVyLFxuICAgIGF1dG9zYXZlOiB0cnVlLCBcbiAgICBhdXRvc2F2ZUludGVydmFsOiAxMDAwMCwgLy8gMTAgc2Vjb25kc1xuICAgIGFkYXB0ZXI6IGFkYXB0ZXIsXG4gICAgdmVyYm9zZTogdHJ1ZVxuICB9KTsgXG5cbmZ1bmN0aW9uIGxvYWRIYW5kbGVyKCkge1xuICBjb25zb2xlLmxvZyhcIkxvYWQgaGFuZGxlclwiKVxuICAvLyBpZiBkYXRhYmFzZSBkaWQgbm90IGV4aXN0IGl0IHdpbGwgYmUgZW1wdHkgc28gSSB3aWxsIGludGl0aWFsaXplIGhlcmVcbiAgdmFyIGNvbGwgPSBkYi5nZXRDb2xsZWN0aW9uKCdwYWxqdScpO1xuICBpZiAoY29sbCA9PT0gbnVsbCkge1xuICAgIGNvbGwgPSBkYi5hZGRDb2xsZWN0aW9uKCdwYWxqdScpO1xuICB9XG59XG5cblxuXG5hcHAuZ2V0KCcqJywgKHJlcSwgcmVzKSA9PiB7XG4gIGxldCBtYXJrdXAgPSAnJztcbiAgbGV0IHN0YXR1cyA9IDIwMDtcblxuICByZXR1cm4gcmVzLnN0YXR1cyhzdGF0dXMpLnJlbmRlcignaW5kZXgnLCB7IG1hcmt1cCB9KTtcbn0pO1xuXG5cbi8vIHN0YXJ0IHRoZSBzZXJ2ZXJcbmNvbnN0IHBvcnQgPSBwcm9jZXNzLmVudi5QT1JUIHx8IDMwMDA7XG5jb25zdCBlbnYgPSBwcm9jZXNzLmVudi5OT0RFX0VOViB8fCAncHJvZHVjdGlvbic7XG5zZXJ2ZXIubGlzdGVuKHBvcnQsIChlcnIpID0+IHtcbiAgaWYgKGVycikge1xuICAgIHJldHVybiBjb25zb2xlLmVycm9yKGVycik7XG4gIH1cblxuICBcblxuICByZXR1cm4gY29uc29sZS5pbmZvKFxuICAgIGBcbiAgICAgIFNlcnZlciBydW5uaW5nIG9uIGh0dHA6Ly9sb2NhbGhvc3Q6JHtwb3J0fSBbJHtlbnZ9XVxuICAgIGApO1xufSk7XG5cblxuXG5cblxuXG53c3Mub24oJ2Nvbm5lY3Rpb24nLCAod3MsIHJlcSkgPT4ge1xuXG4gIGNvbnNvbGUubG9nKFwiR2V0IHBhbGp1RGF0YVwiKVxuICBsZXQgcGFsanVEYXRhID0gZGIuZ2V0Q29sbGVjdGlvbihcInBhbGp1XCIpO1xuXG4gIGNvbnNvbGUubG9nKFwiQ29ubmVjdGVkIHdpdGg6IFwiICsgcmVxLmhlYWRlcnNbJ3NlYy13ZWJzb2NrZXQtcHJvdG9jb2wnXSlcbiAgd3MuY2xpZW50VHlwZSA9IHJlcS5oZWFkZXJzWydzZWMtd2Vic29ja2V0LXByb3RvY29sJ107XG5cbiAgd3MuaXNBbGl2ZSA9IHRydWU7XG4gIHdzLm9uKCdwb25nJywgZnVuY3Rpb24oKXtcbiAgICB0aGlzLmlzQWxpdmUgPSB0cnVlO1xuICB9KTtcblxuICBjb25zdCBsb2NhdGlvbiA9IHVybC5wYXJzZShyZXEudXJsLCB0cnVlKTtcblxuICAvLyBTZW5kIHRoZSBsYXRlc3QgcmVjb3JkIG9uIGNvbm5lY3Rpb25cbiAgbGV0IHRpbWVIb3VyQWdvID0gTWF0aC5mbG9vcihuZXcgRGF0ZSgpIC8gMTAwMCkgLSAoNjAgKiA2MCk7IC8vIFVuaXggdGltZXN0YW1wXG4gIGxldCByZWNvcmRzID0gcGFsanVEYXRhLmNoYWluKCkuZmluZCh7J3RpbWVzdGFtcCc6IHsnJGd0JzogdGltZUhvdXJBZ299fSkuc2ltcGxlc29ydCgndGltZXN0YW1wJykuZGF0YSgpO1xuICBsZXQgbGF0ZXN0UmVjb3JkID0gcmVjb3Jkcy5sZW5ndGggPiAwID8gcmVjb3Jkcy5wb3AoKSA6IHt9XG4gIHdzLnNlbmQoSlNPTi5zdHJpbmdpZnkoc3RyaXBSZXN1bHRzTWV0YWRhdGEobGF0ZXN0UmVjb3JkKSkpO1xuXG4gIHdzLm9uKCdtZXNzYWdlJywgZnVuY3Rpb24gaW5jb21pbmcobWVzc2FnZSkge1xuICAgIGNvbnNvbGUubG9nKCdyZWNlaXZlZDogJXMnLCBtZXNzYWdlKTtcblxuICAgIC8vIFBhcnNlIGRhdGFcbiAgICBsZXQgZGF0YSA9IEpTT04ucGFyc2UobWVzc2FnZSlcbiAgICBjb25zb2xlLmxvZyhkYXRhLnRlbXBfbG93ICE9IG51bGwpXG4gICAgaWYgKGRhdGEudGVtcF9sb3cgIT0gbnVsbCkge1xuICAgICAgbGV0IHRpbWVOb3cgPSBNYXRoLmZsb29yKG5ldyBEYXRlKCkgLyAxMDAwKTsgLy8gVW5peCB0aW1lc3RhbXBcblxuICAgICAgY29uc3QgdmFsdWVzID0ge1xuICAgICAgICB0ZW1wX2xvdzogcGFyc2VGbG9hdChkYXRhLnRlbXBfbG93KSwgXG4gICAgICAgIHRlbXBfaGlnaDogcGFyc2VGbG9hdChkYXRhLnRlbXBfaGlnaCksXG4gICAgICAgIHRlbXBfYW1iaWVudDogcGFyc2VGbG9hdChkYXRhLnRlbXBfYW1iaWVudCksXG4gICAgICAgIHdhcm1pbmdfcGhhc2U6IGRhdGEud2FybWluZ19waGFzZSxcbiAgICAgICAgdGFyZ2V0OiBwYXJzZUZsb2F0KGRhdGEudGFyZ2V0KSxcbiAgICAgICAgbG93X2xpbWl0OiBwYXJzZUZsb2F0KGRhdGEubG93X2xpbWl0KSxcbiAgICAgICAgdGltZXN0YW1wOiB0aW1lTm93LCBcbiAgICAgICAgZXN0aW1hdGlvbjogKChwYXJzZUZsb2F0KGRhdGEudGFyZ2V0KSAtIHBhcnNlRmxvYXQoZGF0YS50ZW1wX2hpZ2gpKSAvIDEwICogNjAgKiA2MCkgKyB0aW1lTm93IC8vIDEwIGRlZ3JlZXMgaW4gYSBob3VyXG4gICAgICB9XG5cbiAgICAgIGlmICh3cy5jbGllbnRUeXBlICE9ICdtb2JpbGUnKXtcbiAgICAgICAgcGFsanVEYXRhLmluc2VydCh2YWx1ZXMpO1xuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zb2xlLmxvZyhcIlNlbmRpbmcgdG8gYWxsIGNsaWVudHNcIilcbiAgICAgIHdzcy5jbGllbnRzLmZvckVhY2goZnVuY3Rpb24gZWFjaChjbGllbnQpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJTaG91bGQgd2Ugc2VuZCB0byBjbGllbnQ6XCIgKyBjbGllbnQuY2xpZW50VHlwZSlcbiAgICAgICAgXG4gICAgICAgIGlmICggY2xpZW50LnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5PUEVOICYmIGNsaWVudCAhPT0gd3MgLyogdG8gZXhjbHVkZSB0aGUgc2VuZGVyKi8gKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJOb3Qgc2VsZiAmIGlzIG9wZW5cIilcbiAgICAgICAgICAvLyBTZW5kZXIgaXMgbW9iaWxlLWFwcCwgb3IgcmVjZWl2ZXIgaXMgbW9iaWxlIGFwcFxuICAgICAgICAgIGlmICh3cy5jbGllbnRUeXBlID09ICdtb2JpbGUnIHx8IGNsaWVudC5jbGllbnRUeXBlID09ICdtb2JpbGUnICkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJDbGllbnQgaXMgbW9iaWxlIG9yIHJlY2VpdmVyIGlzIG1vYmlsZVwiKVxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJTZW5kaW5nIHRvOlwiICsgY2xpZW50LmNsaWVudFR5cGUpXG5cbiAgICAgICAgICAgIGNsaWVudC5zZW5kKEpTT04uc3RyaW5naWZ5KHN0cmlwUmVzdWx0c01ldGFkYXRhKHZhbHVlcykpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoZGF0YS5mcm9tICE9IG51bGwpIHtcbiAgICAgIC8vIFNlbmQgdGhlIGxhdGVzdCA1MFxuICAgIC8vZGF0YS5maW5kKHt9KS5zb3J0KHt0aW1lc3RhbXA6IDF9KS5saW1pdCg1MCkuZXhlYyggKGVyciwgZG9jcykgPT4ge1xuICAgIC8vICAgIHdzLnNlbmQoSlNPTi5zdHJpbmdpZnkoZG9jcykpXG4gICAgLy8gIH0pXG4gICAgfVxuICB9KTtcblxufSk7XG5cblxuLy8gUGluZyBjb25uZWN0aW9ucyBldmVyeSAzMCBzZWNvbmRzIHRvIGtlZXAgdGhlbSBhbGl2ZVxuc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgIHdzcy5jbGllbnRzLmZvckVhY2goKHdzOiBFeHRXZWJTb2NrZXQpID0+IHtcbiAgICAgICAgXG4gICAgICAgIGlmICh3cy5pc0FsaXZlID09IGZhbHNlKXtcbiAgICAgICAgIGNvbnNvbGUubG9nKFwiS0lMTElORyBXRUJTT0NLRVQgQ09OTkVDVElPTlwiKVxuICAgICAgICAgcmV0dXJuIHdzLnRlcm1pbmF0ZSgpO1xuICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHdzLmlzQWxpdmUgPSBmYWxzZTtcbiAgICAgICAgd3MucGluZygoKSA9PiB7fSk7XG4gICAgfSk7XG59LCAxMDAwMCk7XG5cblxuZXhwb3J0IGZ1bmN0aW9uIHN0cmlwUmVzdWx0c01ldGFkYXRhKCByZXN1bHRzICkge1xuXG4gIGNvbnN0IGlzQXJyYXkgPSBBcnJheS5pc0FycmF5KHJlc3VsdHMpO1xuICBcbiAgaWYoIWlzQXJyYXkpIHJlc3VsdHMgPSBbcmVzdWx0c107XG5cbiAgY29uc3QgcmVjb3JkcyA9IFtdO1xuICBcblx0Zm9yICh2YXIgaWR4ID0gMDsgaWR4IDwgcmVzdWx0cy5sZW5ndGg7IGlkeCsrKSB7XG5cdFx0Y29uc3QgbG9raV9yZWMgPSByZXN1bHRzWyBpZHggXVxuXHRcdGNvbnN0IGNsZWFuX3JlYyA9IE9iamVjdC5hc3NpZ24oe30sIGxva2lfcmVjKVxuXHRcdGRlbGV0ZSBjbGVhbl9yZWNbJ21ldGEnXVxuXHRcdGRlbGV0ZSBjbGVhbl9yZWNbJyRsb2tpJ11cblx0XHRyZWNvcmRzLnB1c2goIGNsZWFuX3JlYyApXG5cdH1cblx0cmV0dXJuIGlzQXJyYXkgPyByZWNvcmRzIDogcmVjb3Jkcy5wb3AoKTtcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3NlcnZlci5qcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFzS0E7QUFDQTtBQXJLQTtBQUNBOzs7QUFBQTtBQUNBO0FBQUE7QUFDQTs7O0FBQUE7QUFDQTs7O0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQUE7QUFDQTs7O0FBQ0E7QUFDQTs7O0FBQUE7QUFDQTs7O0FBQUE7QUFDQTs7Ozs7QUFoQkE7QUFDQTtBQWdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUlBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFSQTtBQUNBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///12\n");

/***/ }),
/* 13 */
/*!***********************!*\
  !*** external "http" ***!
  \***********************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports) {

eval("module.exports = require(\"http\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJodHRwXCI/OGU0NCJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJodHRwXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwiaHR0cFwiXG4vLyBtb2R1bGUgaWQgPSAxM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///13\n");

/***/ }),
/* 14 */
/*!**************************!*\
  !*** external "express" ***!
  \**************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports) {

eval("module.exports = require(\"express\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJleHByZXNzXCI/ZDJkMiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJleHByZXNzXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwiZXhwcmVzc1wiXG4vLyBtb2R1bGUgaWQgPSAxNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///14\n");

/***/ }),
/* 15 */
/*!***********************************!*\
  !*** external "react-dom/server" ***!
  \***********************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports) {

eval("module.exports = require(\"react-dom/server\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJyZWFjdC1kb20vc2VydmVyXCI/NDFiZCJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJyZWFjdC1kb20vc2VydmVyXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwicmVhY3QtZG9tL3NlcnZlclwiXG4vLyBtb2R1bGUgaWQgPSAxNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///15\n");

/***/ }),
/* 16 */
/*!*******************************!*\
  !*** ./src/components/App.js ***!
  \*******************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.App = undefined;\n\nvar _react = __webpack_require__(/*! react */ 0);\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _reactRouterDom = __webpack_require__(/*! react-router-dom */ 3);\n\nvar _Layout = __webpack_require__(/*! ./Layout */ 17);\n\nvar _IndexPage = __webpack_require__(/*! ./IndexPage */ 18);\n\nvar _NotFoundPage = __webpack_require__(/*! ./NotFoundPage */ 19);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar renderIndex = function renderIndex() {\n  return _react2.default.createElement(_IndexPage.IndexPage, null);\n};\n\nvar App = exports.App = function App() {\n  return _react2.default.createElement(\n    _Layout.Layout,\n    null,\n    _react2.default.createElement(\n      _reactRouterDom.Switch,\n      null,\n      _react2.default.createElement(_reactRouterDom.Route, { exact: true, path: '/', render: renderIndex }),\n      _react2.default.createElement(_reactRouterDom.Route, { component: _NotFoundPage.NotFoundPage })\n    )\n  );\n};\n\nexports.default = App;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL2NvbXBvbmVudHMvQXBwLmpzPzU3YWEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IFJvdXRlLCBTd2l0Y2ggfSBmcm9tICdyZWFjdC1yb3V0ZXItZG9tJztcbmltcG9ydCB7IExheW91dCB9IGZyb20gJy4vTGF5b3V0JztcbmltcG9ydCB7IEluZGV4UGFnZSB9IGZyb20gJy4vSW5kZXhQYWdlJztcbmltcG9ydCB7IE5vdEZvdW5kUGFnZSB9IGZyb20gJy4vTm90Rm91bmRQYWdlJztcblxuY29uc3QgcmVuZGVySW5kZXggPSAoKSA9PiA8SW5kZXhQYWdlIC8+O1xuXG5leHBvcnQgY29uc3QgQXBwID0gKCkgPT4gKFxuICA8TGF5b3V0PlxuICAgIDxTd2l0Y2g+XG4gICAgICA8Um91dGUgZXhhY3QgcGF0aD1cIi9cIiByZW5kZXI9e3JlbmRlckluZGV4fSAvPlxuICAgICAgPFJvdXRlIGNvbXBvbmVudD17Tm90Rm91bmRQYWdlfSAvPlxuICAgIDwvU3dpdGNoPlxuICA8L0xheW91dD5cbik7XG5cbmV4cG9ydCBkZWZhdWx0IEFwcDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvY29tcG9uZW50cy9BcHAuanMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBOzs7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBOzs7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUZBO0FBREE7QUFEQTtBQUNBO0FBUUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///16\n");

/***/ }),
/* 17 */
/*!**********************************!*\
  !*** ./src/components/Layout.js ***!
  \**********************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Layout = undefined;\n\nvar _react = __webpack_require__(/*! react */ 0);\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _reactRouterDom = __webpack_require__(/*! react-router-dom */ 3);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar Layout = exports.Layout = function Layout(props) {\n  return _react2.default.createElement(\n    'div',\n    { className: 'app-container' },\n    _react2.default.createElement(\n      'div',\n      { className: 'app-content' },\n      props.children\n    )\n  );\n};\n\nexports.default = Layout;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL2NvbXBvbmVudHMvTGF5b3V0LmpzPzdmMGMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IExpbmsgfSBmcm9tICdyZWFjdC1yb3V0ZXItZG9tJztcblxuZXhwb3J0IGNvbnN0IExheW91dCA9IHByb3BzID0+IChcbiAgPGRpdiBjbGFzc05hbWU9XCJhcHAtY29udGFpbmVyXCI+XG4gICAgPGRpdiBjbGFzc05hbWU9XCJhcHAtY29udGVudFwiPntwcm9wcy5jaGlsZHJlbn08L2Rpdj5cbiAgPC9kaXY+XG4pO1xuXG5leHBvcnQgZGVmYXVsdCBMYXlvdXQ7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2NvbXBvbmVudHMvTGF5b3V0LmpzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTs7O0FBQUE7QUFDQTs7O0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBREE7QUFEQTtBQUNBO0FBS0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///17\n");

/***/ }),
/* 18 */
/*!*************************************!*\
  !*** ./src/components/IndexPage.js ***!
  \*************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.IndexPage = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _react = __webpack_require__(/*! react */ 0);\n\nvar _react2 = _interopRequireDefault(_react);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar IndexPage = exports.IndexPage = function (_React$Component) {\n  _inherits(IndexPage, _React$Component);\n\n  function IndexPage(props) {\n    _classCallCheck(this, IndexPage);\n\n    var _this = _possibleConstructorReturn(this, (IndexPage.__proto__ || Object.getPrototypeOf(IndexPage)).call(this, props));\n\n    _this.state = {\n      data: [],\n      burner_on: false,\n      current_temp: 0,\n      timestamp: 0,\n      protocol: null\n    };\n    _this.sendTestData = _this.sendTestData.bind(_this);\n    return _this;\n  }\n\n  _createClass(IndexPage, [{\n    key: 'componentWillMount',\n    value: function componentWillMount() {\n      console.log(\"componentWillMount\");\n\n      this.connection = new WebSocket('ws://192.168.10.42:3000', this.state.protocol);\n\n      this.connection.onopen = function () {\n        // connection is opened and ready to use\n        console.log(\"Connection open\");\n      };\n\n      this.connection.onerror = function (error) {\n        // an error occurred when sending/receiving data\n        console.log(error);\n      };\n\n      this.connection.onclose = function () {\n        console.log(\"CLOSE\");\n      };\n\n      this.connection.onmessage = function (message) {\n        console.log('Received: ', message.data);\n      };\n    }\n  }, {\n    key: 'componentDidUpdate',\n    value: function componentDidUpdate() {\n      console.log(\"Component did update\");\n      this.connection.close();\n      this.connection = new WebSocket('ws://192.168.10.42:3000', this.state.protocol);\n\n      this.connection.onopen = function () {\n        // connection is opened and ready to use\n        console.log(\"Connection open\");\n      };\n\n      this.connection.onerror = function (error) {\n        // an error occurred when sending/receiving data\n        console.log(error);\n      };\n\n      this.connection.onclose = function () {\n        console.log(\"CLOSE\");\n      };\n\n      this.connection.onmessage = function (message) {\n        console.log('Received: ', message.data);\n      };\n    }\n  }, {\n    key: 'componentWillUnmount',\n    value: function componentWillUnmount() {\n      console.log(\"componentWillUnMount\");\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      var _this2 = this;\n\n      console.log(\"render\");\n      console.log(this.state);\n\n      var date = new Date(this.state.timestamp);\n\n      return _react2.default.createElement(\n        'div',\n        { className: 'home' },\n        _react2.default.createElement(\n          'div',\n          { className: 'server-test' },\n          _react2.default.createElement(\n            'p',\n            null,\n            ' Send test data: '\n          ),\n          _react2.default.createElement('input', { type: 'text', onChange: function onChange(event) {\n              console.log(event.target.value);_this2.setState({ protocol: event.target.value });\n            }, placeholder: 'protocol' }),\n          _react2.default.createElement('input', { type: 'text', ref: function ref(input) {\n              _this2.temp1 = input;\n            }, name: 'temp1', placeholder: 'temp1' }),\n          _react2.default.createElement('input', { type: 'text', ref: function ref(input) {\n              _this2.temp2 = input;\n            }, name: 'temp2', placeholder: 'temp2' }),\n          _react2.default.createElement(\n            'button',\n            { onClick: this.sendTestData },\n            'Send'\n          )\n        )\n      );\n    }\n  }, {\n    key: 'sendTestData',\n    value: function sendTestData() {\n      console.log(\"sendtestdata\");\n      this.connection.send(JSON.stringify({\n        temp_low: this.temp1.value,\n        temp_high: this.temp2.value,\n        temp_ambient: 10.0,\n        warming_phase: 'ON',\n        target: 37.8,\n        low_limit: 36.5\n      }));\n    }\n  }]);\n\n  return IndexPage;\n}(_react2.default.Component);\n\nexports.default = IndexPage;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTguanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL2NvbXBvbmVudHMvSW5kZXhQYWdlLmpzPzZkM2MiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuXG5leHBvcnQgY2xhc3MgSW5kZXhQYWdlIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcblxuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgc3VwZXIocHJvcHMpO1xuICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgZGF0YTogW10sXG4gICAgICAgIGJ1cm5lcl9vbjogZmFsc2UsXG4gICAgICAgIGN1cnJlbnRfdGVtcDogMCxcbiAgICAgICAgdGltZXN0YW1wOiAwLFxuICAgICAgICBwcm90b2NvbDogbnVsbCxcbiAgICAgIH1cbiAgICAgIHRoaXMuc2VuZFRlc3REYXRhID0gdGhpcy5zZW5kVGVzdERhdGEuYmluZCh0aGlzKTtcbiAgfVxuXG4gIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcbiAgICBjb25zb2xlLmxvZyhcImNvbXBvbmVudFdpbGxNb3VudFwiKTtcblxuICAgIHRoaXMuY29ubmVjdGlvbiA9IG5ldyBXZWJTb2NrZXQoJ3dzOi8vMTkyLjE2OC4xMC40MjozMDAwJywgdGhpcy5zdGF0ZS5wcm90b2NvbCk7XG5cbiAgICB0aGlzLmNvbm5lY3Rpb24ub25vcGVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgLy8gY29ubmVjdGlvbiBpcyBvcGVuZWQgYW5kIHJlYWR5IHRvIHVzZVxuICAgICAgY29uc29sZS5sb2coXCJDb25uZWN0aW9uIG9wZW5cIilcbiAgICB9O1xuXG4gICAgdGhpcy5jb25uZWN0aW9uLm9uZXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgIC8vIGFuIGVycm9yIG9jY3VycmVkIHdoZW4gc2VuZGluZy9yZWNlaXZpbmcgZGF0YVxuICAgICAgICAgICAgY29uc29sZS5sb2coZXJyb3IpXG5cbiAgICB9O1xuXG4gICAgdGhpcy5jb25uZWN0aW9uLm9uY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiQ0xPU0VcIilcbiAgICB9XG5cbiAgICB0aGlzLmNvbm5lY3Rpb24ub25tZXNzYWdlID0gKG1lc3NhZ2UpID0+IHtcbiAgICAgIGNvbnNvbGUubG9nKCdSZWNlaXZlZDogJywgbWVzc2FnZS5kYXRhKTtcbiAgICB9O1xuICB9XG5cbiAgY29tcG9uZW50RGlkVXBkYXRlKCkge1xuICAgIGNvbnNvbGUubG9nKFwiQ29tcG9uZW50IGRpZCB1cGRhdGVcIilcbiAgICB0aGlzLmNvbm5lY3Rpb24uY2xvc2UoKTtcbiAgICB0aGlzLmNvbm5lY3Rpb24gPSBuZXcgV2ViU29ja2V0KCd3czovLzE5Mi4xNjguMTAuNDI6MzAwMCcsIHRoaXMuc3RhdGUucHJvdG9jb2wpO1xuXG4gICAgdGhpcy5jb25uZWN0aW9uLm9ub3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIGNvbm5lY3Rpb24gaXMgb3BlbmVkIGFuZCByZWFkeSB0byB1c2VcbiAgICAgIGNvbnNvbGUubG9nKFwiQ29ubmVjdGlvbiBvcGVuXCIpXG4gICAgfTtcblxuICAgIHRoaXMuY29ubmVjdGlvbi5vbmVycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAvLyBhbiBlcnJvciBvY2N1cnJlZCB3aGVuIHNlbmRpbmcvcmVjZWl2aW5nIGRhdGFcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGVycm9yKVxuXG4gICAgfTtcblxuICAgIHRoaXMuY29ubmVjdGlvbi5vbmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIkNMT1NFXCIpXG4gICAgfVxuXG4gICAgdGhpcy5jb25uZWN0aW9uLm9ubWVzc2FnZSA9IChtZXNzYWdlKSA9PiB7XG4gICAgICBjb25zb2xlLmxvZygnUmVjZWl2ZWQ6ICcsIG1lc3NhZ2UuZGF0YSk7XG4gICAgfTtcblxuICB9XG5cbiAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgY29uc29sZS5sb2coXCJjb21wb25lbnRXaWxsVW5Nb3VudFwiKVxuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnNvbGUubG9nKFwicmVuZGVyXCIpXG4gICAgY29uc29sZS5sb2codGhpcy5zdGF0ZSlcbiAgICBcbiAgICBsZXQgZGF0ZSA9IG5ldyBEYXRlKHRoaXMuc3RhdGUudGltZXN0YW1wKVxuXG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiaG9tZVwiPlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInNlcnZlci10ZXN0XCI+XG4gICAgICAgICAgPHA+IFNlbmQgdGVzdCBkYXRhOiA8L3A+XG4gICAgICAgICAgPGlucHV0IHR5cGU9J3RleHQnIG9uQ2hhbmdlPXsoZXZlbnQpID0+IHtjb25zb2xlLmxvZyhldmVudC50YXJnZXQudmFsdWUpOyB0aGlzLnNldFN0YXRlKHtwcm90b2NvbDogZXZlbnQudGFyZ2V0LnZhbHVlfSl9fSBwbGFjZWhvbGRlcj0ncHJvdG9jb2wnLz5cbiAgICAgICAgICA8aW5wdXQgdHlwZT0ndGV4dCcgcmVmPXsoaW5wdXQpID0+IHsgdGhpcy50ZW1wMSA9IGlucHV0OyB9fSBuYW1lPSd0ZW1wMScgcGxhY2Vob2xkZXI9J3RlbXAxJy8+XG4gICAgICAgICAgPGlucHV0IHR5cGU9J3RleHQnIHJlZj17KGlucHV0KSA9PiB7IHRoaXMudGVtcDIgPSBpbnB1dDsgfX0gbmFtZT0ndGVtcDInIHBsYWNlaG9sZGVyPSd0ZW1wMicvPlxuICAgICAgICAgIDxidXR0b24gb25DbGljaz17dGhpcy5zZW5kVGVzdERhdGF9PlNlbmQ8L2J1dHRvbj5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICApXG4gIH1cblxuICBzZW5kVGVzdERhdGEoKSB7XG4gICAgY29uc29sZS5sb2coXCJzZW5kdGVzdGRhdGFcIilcbiAgICB0aGlzLmNvbm5lY3Rpb24uc2VuZChKU09OLnN0cmluZ2lmeSh7XG4gICAgICB0ZW1wX2xvdzogdGhpcy50ZW1wMS52YWx1ZSxcbiAgICAgIHRlbXBfaGlnaDogdGhpcy50ZW1wMi52YWx1ZSxcbiAgICAgIHRlbXBfYW1iaWVudDogMTAuMCxcbiAgICAgIHdhcm1pbmdfcGhhc2U6ICdPTicsXG4gICAgICB0YXJnZXQ6IDM3LjgsXG4gICAgICBsb3dfbGltaXQ6IDM2LjVcbiAgICB9KSlcbiAgfVxuXG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgSW5kZXhQYWdlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9jb21wb25lbnRzL0luZGV4UGFnZS5qcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTs7Ozs7Ozs7Ozs7QUFFQTs7O0FBRUE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBT0E7QUFUQTtBQVVBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUVBO0FBQ0E7QUFDQTs7O0FBRUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBTEE7QUFEQTtBQVVBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVFBOzs7O0FBbEdBO0FBQ0E7QUFzR0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///18\n");

/***/ }),
/* 19 */
/*!****************************************!*\
  !*** ./src/components/NotFoundPage.js ***!
  \****************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.NotFoundPage = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _react = __webpack_require__(/*! react */ 0);\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _reactRouterDom = __webpack_require__(/*! react-router-dom */ 3);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* eslint react/forbid-prop-types: \"off\" */\n\nvar NotFoundPage = exports.NotFoundPage = function (_React$Component) {\n  _inherits(NotFoundPage, _React$Component);\n\n  function NotFoundPage() {\n    _classCallCheck(this, NotFoundPage);\n\n    return _possibleConstructorReturn(this, (NotFoundPage.__proto__ || Object.getPrototypeOf(NotFoundPage)).apply(this, arguments));\n  }\n\n  _createClass(NotFoundPage, [{\n    key: 'componentWillMount',\n    value: function componentWillMount() {\n      var staticContext = this.props.staticContext;\n\n      if (staticContext) {\n        staticContext.is404 = true;\n      }\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      return _react2.default.createElement(\n        'div',\n        { className: 'not-found' },\n        _react2.default.createElement(\n          'h1',\n          null,\n          '404'\n        ),\n        _react2.default.createElement(\n          'h2',\n          null,\n          'Page not found!'\n        ),\n        _react2.default.createElement(\n          'p',\n          null,\n          _react2.default.createElement(\n            _reactRouterDom.Link,\n            { to: '/' },\n            'Go back to the main page'\n          )\n        )\n      );\n    }\n  }]);\n\n  return NotFoundPage;\n}(_react2.default.Component);\n\nexports.default = NotFoundPage;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTkuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL2NvbXBvbmVudHMvTm90Rm91bmRQYWdlLmpzPzRiMDIiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50IHJlYWN0L2ZvcmJpZC1wcm9wLXR5cGVzOiBcIm9mZlwiICovXG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBMaW5rIH0gZnJvbSAncmVhY3Qtcm91dGVyLWRvbSc7XG5cbmV4cG9ydCBjbGFzcyBOb3RGb3VuZFBhZ2UgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICBjb21wb25lbnRXaWxsTW91bnQoKSB7XG4gICAgY29uc3QgeyBzdGF0aWNDb250ZXh0IH0gPSB0aGlzLnByb3BzO1xuICAgIGlmIChzdGF0aWNDb250ZXh0KSB7XG4gICAgICBzdGF0aWNDb250ZXh0LmlzNDA0ID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgcmV0dXJuICg8ZGl2IGNsYXNzTmFtZT1cIm5vdC1mb3VuZFwiPlxuICAgICAgPGgxPjQwNDwvaDE+XG4gICAgICA8aDI+UGFnZSBub3QgZm91bmQhPC9oMj5cbiAgICAgIDxwPlxuICAgICAgICA8TGluayB0bz1cIi9cIj5HbyBiYWNrIHRvIHRoZSBtYWluIHBhZ2U8L0xpbms+XG4gICAgICA8L3A+XG4gICAgPC9kaXY+XG4gICAgKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOb3RGb3VuZFBhZ2U7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2NvbXBvbmVudHMvTm90Rm91bmRQYWdlLmpzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFFQTtBQUNBOzs7QUFBQTtBQUNBOzs7Ozs7O0FBSkE7QUFDQTtBQUlBOzs7Ozs7Ozs7OztBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQURBO0FBSEE7QUFRQTs7OztBQWpCQTtBQUNBO0FBbUJBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///19\n");

/***/ }),
/* 20 */
/*!*********************!*\
  !*** external "ws" ***!
  \*********************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports) {

eval("module.exports = require(\"ws\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJ3c1wiPzc4MDYiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwid3NcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJ3c1wiXG4vLyBtb2R1bGUgaWQgPSAyMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///20\n");

/***/ }),
/* 21 */
/*!**********************!*\
  !*** external "url" ***!
  \**********************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports) {

eval("module.exports = require(\"url\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJ1cmxcIj9jYWVjIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInVybFwiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcInVybFwiXG4vLyBtb2R1bGUgaWQgPSAyMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///21\n");

/***/ }),
/* 22 */
/*!************************************!*\
  !*** ./node_modules/nedb/index.js ***!
  \************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

eval("var Datastore = __webpack_require__(/*! ./lib/datastore */ 23);\n\nmodule.exports = Datastore;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbmVkYi9pbmRleC5qcz9iNGZhIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBEYXRhc3RvcmUgPSByZXF1aXJlKCcuL2xpYi9kYXRhc3RvcmUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBEYXRhc3RvcmU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9uZWRiL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAyMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///22\n");

/***/ }),
/* 23 */
/*!********************************************!*\
  !*** ./node_modules/nedb/lib/datastore.js ***!
  \********************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

eval("var customUtils = __webpack_require__(/*! ./customUtils */ 7)\n  , model = __webpack_require__(/*! ./model */ 4)\n  , async = __webpack_require__(/*! async */ 6)\n  , Executor = __webpack_require__(/*! ./executor */ 25)\n  , Index = __webpack_require__(/*! ./indexes */ 8)\n  , util = __webpack_require__(/*! util */ 5)\n  , _ = __webpack_require__(/*! underscore */ 1)\n  , Persistence = __webpack_require__(/*! ./persistence */ 28)\n  , Cursor = __webpack_require__(/*! ./cursor */ 31)\n  ;\n\n\n/**\n * Create a new collection\n * @param {String} options.filename Optional, datastore will be in-memory only if not provided\n * @param {Boolean} options.timestampData Optional, defaults to false. If set to true, createdAt and updatedAt will be created and populated automatically (if not specified by user)\n * @param {Boolean} options.inMemoryOnly Optional, defaults to false\n * @param {String} options.nodeWebkitAppName Optional, specify the name of your NW app if you want options.filename to be relative to the directory where\n *                                            Node Webkit stores application data such as cookies and local storage (the best place to store data in my opinion)\n * @param {Boolean} options.autoload Optional, defaults to false\n * @param {Function} options.onload Optional, if autoload is used this will be called after the load database with the error object as parameter. If you don't pass it the error will be thrown\n * @param {Function} options.afterSerialization/options.beforeDeserialization Optional, serialization hooks\n * @param {Number} options.corruptAlertThreshold Optional, threshold after which an alert is thrown if too much data is corrupt\n * @param {Function} options.compareStrings Optional, string comparison function that overrides default for sorting\n *\n * Event Emitter - Events\n * * compaction.done - Fired whenever a compaction operation was finished\n */\nfunction Datastore (options) {\n  var filename;\n\n  // Retrocompatibility with v0.6 and before\n  if (typeof options === 'string') {\n    filename = options;\n    this.inMemoryOnly = false;   // Default\n  } else {\n    options = options || {};\n    filename = options.filename;\n    this.inMemoryOnly = options.inMemoryOnly || false;\n    this.autoload = options.autoload || false;\n    this.timestampData = options.timestampData || false;\n  }\n\n  // Determine whether in memory or persistent\n  if (!filename || typeof filename !== 'string' || filename.length === 0) {\n    this.filename = null;\n    this.inMemoryOnly = true;\n  } else {\n    this.filename = filename;\n  }\n\n  // String comparison function\n  this.compareStrings = options.compareStrings;\n\n  // Persistence handling\n  this.persistence = new Persistence({ db: this, nodeWebkitAppName: options.nodeWebkitAppName\n                                      , afterSerialization: options.afterSerialization\n                                      , beforeDeserialization: options.beforeDeserialization\n                                      , corruptAlertThreshold: options.corruptAlertThreshold\n                                      });\n\n  // This new executor is ready if we don't use persistence\n  // If we do, it will only be ready once loadDatabase is called\n  this.executor = new Executor();\n  if (this.inMemoryOnly) { this.executor.ready = true; }\n\n  // Indexed by field name, dot notation can be used\n  // _id is always indexed and since _ids are generated randomly the underlying\n  // binary is always well-balanced\n  this.indexes = {};\n  this.indexes._id = new Index({ fieldName: '_id', unique: true });\n  this.ttlIndexes = {};\n\n  // Queue a load of the database right away and call the onload handler\n  // By default (no onload handler), if there is an error there, no operation will be possible so warn the user by throwing an exception\n  if (this.autoload) { this.loadDatabase(options.onload || function (err) {\n    if (err) { throw err; }\n  }); }\n}\n\nutil.inherits(Datastore, __webpack_require__(/*! events */ 32).EventEmitter);\n\n\n/**\n * Load the database from the datafile, and trigger the execution of buffered commands if any\n */\nDatastore.prototype.loadDatabase = function () {\n  this.executor.push({ this: this.persistence, fn: this.persistence.loadDatabase, arguments: arguments }, true);\n};\n\n\n/**\n * Get an array of all the data in the database\n */\nDatastore.prototype.getAllData = function () {\n  return this.indexes._id.getAll();\n};\n\n\n/**\n * Reset all currently defined indexes\n */\nDatastore.prototype.resetIndexes = function (newData) {\n  var self = this;\n\n  Object.keys(this.indexes).forEach(function (i) {\n    self.indexes[i].reset(newData);\n  });\n};\n\n\n/**\n * Ensure an index is kept for this field. Same parameters as lib/indexes\n * For now this function is synchronous, we need to test how much time it takes\n * We use an async API for consistency with the rest of the code\n * @param {String} options.fieldName\n * @param {Boolean} options.unique\n * @param {Boolean} options.sparse\n * @param {Number} options.expireAfterSeconds - Optional, if set this index becomes a TTL index (only works on Date fields, not arrays of Date)\n * @param {Function} cb Optional callback, signature: err\n */\nDatastore.prototype.ensureIndex = function (options, cb) {\n  var err\n    , callback = cb || function () {};\n\n  options = options || {};\n\n  if (!options.fieldName) {\n    err = new Error(\"Cannot create an index without a fieldName\");\n    err.missingFieldName = true;\n    return callback(err);\n  }\n  if (this.indexes[options.fieldName]) { return callback(null); }\n\n  this.indexes[options.fieldName] = new Index(options);\n  if (options.expireAfterSeconds !== undefined) { this.ttlIndexes[options.fieldName] = options.expireAfterSeconds; }   // With this implementation index creation is not necessary to ensure TTL but we stick with MongoDB's API here\n\n  try {\n    this.indexes[options.fieldName].insert(this.getAllData());\n  } catch (e) {\n    delete this.indexes[options.fieldName];\n    return callback(e);\n  }\n\n  // We may want to force all options to be persisted including defaults, not just the ones passed the index creation function\n  this.persistence.persistNewState([{ $$indexCreated: options }], function (err) {\n    if (err) { return callback(err); }\n    return callback(null);\n  });\n};\n\n\n/**\n * Remove an index\n * @param {String} fieldName\n * @param {Function} cb Optional callback, signature: err\n */\nDatastore.prototype.removeIndex = function (fieldName, cb) {\n  var callback = cb || function () {};\n\n  delete this.indexes[fieldName];\n\n  this.persistence.persistNewState([{ $$indexRemoved: fieldName }], function (err) {\n    if (err) { return callback(err); }\n    return callback(null);\n  });\n};\n\n\n/**\n * Add one or several document(s) to all indexes\n */\nDatastore.prototype.addToIndexes = function (doc) {\n  var i, failingIndex, error\n    , keys = Object.keys(this.indexes)\n    ;\n\n  for (i = 0; i < keys.length; i += 1) {\n    try {\n      this.indexes[keys[i]].insert(doc);\n    } catch (e) {\n      failingIndex = i;\n      error = e;\n      break;\n    }\n  }\n\n  // If an error happened, we need to rollback the insert on all other indexes\n  if (error) {\n    for (i = 0; i < failingIndex; i += 1) {\n      this.indexes[keys[i]].remove(doc);\n    }\n\n    throw error;\n  }\n};\n\n\n/**\n * Remove one or several document(s) from all indexes\n */\nDatastore.prototype.removeFromIndexes = function (doc) {\n  var self = this;\n\n  Object.keys(this.indexes).forEach(function (i) {\n    self.indexes[i].remove(doc);\n  });\n};\n\n\n/**\n * Update one or several documents in all indexes\n * To update multiple documents, oldDoc must be an array of { oldDoc, newDoc } pairs\n * If one update violates a constraint, all changes are rolled back\n */\nDatastore.prototype.updateIndexes = function (oldDoc, newDoc) {\n  var i, failingIndex, error\n    , keys = Object.keys(this.indexes)\n    ;\n\n  for (i = 0; i < keys.length; i += 1) {\n    try {\n      this.indexes[keys[i]].update(oldDoc, newDoc);\n    } catch (e) {\n      failingIndex = i;\n      error = e;\n      break;\n    }\n  }\n\n  // If an error happened, we need to rollback the update on all other indexes\n  if (error) {\n    for (i = 0; i < failingIndex; i += 1) {\n      this.indexes[keys[i]].revertUpdate(oldDoc, newDoc);\n    }\n\n    throw error;\n  }\n};\n\n\n/**\n * Return the list of candidates for a given query\n * Crude implementation for now, we return the candidates given by the first usable index if any\n * We try the following query types, in this order: basic match, $in match, comparison match\n * One way to make it better would be to enable the use of multiple indexes if the first usable index\n * returns too much data. I may do it in the future.\n *\n * Returned candidates will be scanned to find and remove all expired documents\n *\n * @param {Query} query\n * @param {Boolean} dontExpireStaleDocs Optional, defaults to false, if true don't remove stale docs. Useful for the remove function which shouldn't be impacted by expirations\n * @param {Function} callback Signature err, docs\n */\nDatastore.prototype.getCandidates = function (query, dontExpireStaleDocs, callback) {\n  var indexNames = Object.keys(this.indexes)\n    , self = this\n    , usableQueryKeys;\n\n  if (typeof dontExpireStaleDocs === 'function') {\n    callback = dontExpireStaleDocs;\n    dontExpireStaleDocs = false;\n  }\n\n  async.waterfall([\n  // STEP 1: get candidates list by checking indexes from most to least frequent usecase\n  function (cb) {\n    // For a basic match\n    usableQueryKeys = [];\n    Object.keys(query).forEach(function (k) {\n      if (typeof query[k] === 'string' || typeof query[k] === 'number' || typeof query[k] === 'boolean' || util.isDate(query[k]) || query[k] === null) {\n        usableQueryKeys.push(k);\n      }\n    });\n    usableQueryKeys = _.intersection(usableQueryKeys, indexNames);\n    if (usableQueryKeys.length > 0) {\n      return cb(null, self.indexes[usableQueryKeys[0]].getMatching(query[usableQueryKeys[0]]));\n    }\n\n    // For a $in match\n    usableQueryKeys = [];\n    Object.keys(query).forEach(function (k) {\n      if (query[k] && query[k].hasOwnProperty('$in')) {\n        usableQueryKeys.push(k);\n      }\n    });\n    usableQueryKeys = _.intersection(usableQueryKeys, indexNames);\n    if (usableQueryKeys.length > 0) {\n      return cb(null, self.indexes[usableQueryKeys[0]].getMatching(query[usableQueryKeys[0]].$in));\n    }\n\n    // For a comparison match\n    usableQueryKeys = [];\n    Object.keys(query).forEach(function (k) {\n      if (query[k] && (query[k].hasOwnProperty('$lt') || query[k].hasOwnProperty('$lte') || query[k].hasOwnProperty('$gt') || query[k].hasOwnProperty('$gte'))) {\n        usableQueryKeys.push(k);\n      }\n    });\n    usableQueryKeys = _.intersection(usableQueryKeys, indexNames);\n    if (usableQueryKeys.length > 0) {\n      return cb(null, self.indexes[usableQueryKeys[0]].getBetweenBounds(query[usableQueryKeys[0]]));\n    }\n\n    // By default, return all the DB data\n    return cb(null, self.getAllData());\n  }\n  // STEP 2: remove all expired documents\n  , function (docs) {\n    if (dontExpireStaleDocs) { return callback(null, docs); }\n\n    var expiredDocsIds = [], validDocs = [], ttlIndexesFieldNames = Object.keys(self.ttlIndexes);\n\n    docs.forEach(function (doc) {\n      var valid = true;\n      ttlIndexesFieldNames.forEach(function (i) {\n        if (doc[i] !== undefined && util.isDate(doc[i]) && Date.now() > doc[i].getTime() + self.ttlIndexes[i] * 1000) {\n          valid = false;\n        }\n      });\n      if (valid) { validDocs.push(doc); } else { expiredDocsIds.push(doc._id); }\n    });\n\n    async.eachSeries(expiredDocsIds, function (_id, cb) {\n      self._remove({ _id: _id }, {}, function (err) {\n        if (err) { return callback(err); }\n        return cb();\n      });\n    }, function (err) {\n      return callback(null, validDocs);\n    });\n  }]);\n};\n\n\n/**\n * Insert a new document\n * @param {Function} cb Optional callback, signature: err, insertedDoc\n *\n * @api private Use Datastore.insert which has the same signature\n */\nDatastore.prototype._insert = function (newDoc, cb) {\n  var callback = cb || function () {}\n    , preparedDoc\n    ;\n\n  try {\n    preparedDoc = this.prepareDocumentForInsertion(newDoc)\n    this._insertInCache(preparedDoc);\n  } catch (e) {\n    return callback(e);\n  }\n\n  this.persistence.persistNewState(util.isArray(preparedDoc) ? preparedDoc : [preparedDoc], function (err) {\n    if (err) { return callback(err); }\n    return callback(null, model.deepCopy(preparedDoc));\n  });\n};\n\n/**\n * Create a new _id that's not already in use\n */\nDatastore.prototype.createNewId = function () {\n  var tentativeId = customUtils.uid(16);\n  // Try as many times as needed to get an unused _id. As explained in customUtils, the probability of this ever happening is extremely small, so this is O(1)\n  if (this.indexes._id.getMatching(tentativeId).length > 0) {\n    tentativeId = this.createNewId();\n  }\n  return tentativeId;\n};\n\n/**\n * Prepare a document (or array of documents) to be inserted in a database\n * Meaning adds _id and timestamps if necessary on a copy of newDoc to avoid any side effect on user input\n * @api private\n */\nDatastore.prototype.prepareDocumentForInsertion = function (newDoc) {\n  var preparedDoc, self = this;\n\n  if (util.isArray(newDoc)) {\n    preparedDoc = [];\n    newDoc.forEach(function (doc) { preparedDoc.push(self.prepareDocumentForInsertion(doc)); });\n  } else {\n    preparedDoc = model.deepCopy(newDoc);\n    if (preparedDoc._id === undefined) { preparedDoc._id = this.createNewId(); }\n    var now = new Date();\n    if (this.timestampData && preparedDoc.createdAt === undefined) { preparedDoc.createdAt = now; }\n    if (this.timestampData && preparedDoc.updatedAt === undefined) { preparedDoc.updatedAt = now; }\n    model.checkObject(preparedDoc);\n  }\n\n  return preparedDoc;\n};\n\n/**\n * If newDoc is an array of documents, this will insert all documents in the cache\n * @api private\n */\nDatastore.prototype._insertInCache = function (preparedDoc) {\n  if (util.isArray(preparedDoc)) {\n    this._insertMultipleDocsInCache(preparedDoc);\n  } else {\n    this.addToIndexes(preparedDoc);\n  }\n};\n\n/**\n * If one insertion fails (e.g. because of a unique constraint), roll back all previous\n * inserts and throws the error\n * @api private\n */\nDatastore.prototype._insertMultipleDocsInCache = function (preparedDocs) {\n  var i, failingI, error;\n\n  for (i = 0; i < preparedDocs.length; i += 1) {\n    try {\n      this.addToIndexes(preparedDocs[i]);\n    } catch (e) {\n      error = e;\n      failingI = i;\n      break;\n    }\n  }\n\n  if (error) {\n    for (i = 0; i < failingI; i += 1) {\n      this.removeFromIndexes(preparedDocs[i]);\n    }\n\n    throw error;\n  }\n};\n\nDatastore.prototype.insert = function () {\n  this.executor.push({ this: this, fn: this._insert, arguments: arguments });\n};\n\n\n/**\n * Count all documents matching the query\n * @param {Object} query MongoDB-style query\n */\nDatastore.prototype.count = function(query, callback) {\n  var cursor = new Cursor(this, query, function(err, docs, callback) {\n    if (err) { return callback(err); }\n    return callback(null, docs.length);\n  });\n\n  if (typeof callback === 'function') {\n    cursor.exec(callback);\n  } else {\n    return cursor;\n  }\n};\n\n\n/**\n * Find all documents matching the query\n * If no callback is passed, we return the cursor so that user can limit, skip and finally exec\n * @param {Object} query MongoDB-style query\n * @param {Object} projection MongoDB-style projection\n */\nDatastore.prototype.find = function (query, projection, callback) {\n  switch (arguments.length) {\n    case 1:\n      projection = {};\n      // callback is undefined, will return a cursor\n      break;\n    case 2:\n      if (typeof projection === 'function') {\n        callback = projection;\n        projection = {};\n      }   // If not assume projection is an object and callback undefined\n      break;\n  }\n\n  var cursor = new Cursor(this, query, function(err, docs, callback) {\n    var res = [], i;\n\n    if (err) { return callback(err); }\n\n    for (i = 0; i < docs.length; i += 1) {\n      res.push(model.deepCopy(docs[i]));\n    }\n    return callback(null, res);\n  });\n\n  cursor.projection(projection);\n  if (typeof callback === 'function') {\n    cursor.exec(callback);\n  } else {\n    return cursor;\n  }\n};\n\n\n/**\n * Find one document matching the query\n * @param {Object} query MongoDB-style query\n * @param {Object} projection MongoDB-style projection\n */\nDatastore.prototype.findOne = function (query, projection, callback) {\n  switch (arguments.length) {\n    case 1:\n      projection = {};\n      // callback is undefined, will return a cursor\n      break;\n    case 2:\n      if (typeof projection === 'function') {\n        callback = projection;\n        projection = {};\n      }   // If not assume projection is an object and callback undefined\n      break;\n  }\n\n  var cursor = new Cursor(this, query, function(err, docs, callback) {\n    if (err) { return callback(err); }\n    if (docs.length === 1) {\n      return callback(null, model.deepCopy(docs[0]));\n    } else {\n      return callback(null, null);\n    }\n  });\n\n  cursor.projection(projection).limit(1);\n  if (typeof callback === 'function') {\n    cursor.exec(callback);\n  } else {\n    return cursor;\n  }\n};\n\n\n/**\n * Update all docs matching query\n * @param {Object} query\n * @param {Object} updateQuery\n * @param {Object} options Optional options\n *                 options.multi If true, can update multiple documents (defaults to false)\n *                 options.upsert If true, document is inserted if the query doesn't match anything\n *                 options.returnUpdatedDocs Defaults to false, if true return as third argument the array of updated matched documents (even if no change actually took place)\n * @param {Function} cb Optional callback, signature: (err, numAffected, affectedDocuments, upsert)\n *                      If update was an upsert, upsert flag is set to true\n *                      affectedDocuments can be one of the following:\n *                        * For an upsert, the upserted document\n *                        * For an update with returnUpdatedDocs option false, null\n *                        * For an update with returnUpdatedDocs true and multi false, the updated document\n *                        * For an update with returnUpdatedDocs true and multi true, the array of updated documents\n *\n * WARNING: The API was changed between v1.7.4 and v1.8, for consistency and readability reasons. Prior and including to v1.7.4,\n *          the callback signature was (err, numAffected, updated) where updated was the updated document in case of an upsert\n *          or the array of updated documents for an update if the returnUpdatedDocs option was true. That meant that the type of\n *          affectedDocuments in a non multi update depended on whether there was an upsert or not, leaving only two ways for the\n *          user to check whether an upsert had occured: checking the type of affectedDocuments or running another find query on\n *          the whole dataset to check its size. Both options being ugly, the breaking change was necessary.\n *\n * @api private Use Datastore.update which has the same signature\n */\nDatastore.prototype._update = function (query, updateQuery, options, cb) {\n  var callback\n    , self = this\n    , numReplaced = 0\n    , multi, upsert\n    , i\n    ;\n\n  if (typeof options === 'function') { cb = options; options = {}; }\n  callback = cb || function () {};\n  multi = options.multi !== undefined ? options.multi : false;\n  upsert = options.upsert !== undefined ? options.upsert : false;\n\n  async.waterfall([\n  function (cb) {   // If upsert option is set, check whether we need to insert the doc\n    if (!upsert) { return cb(); }\n\n    // Need to use an internal function not tied to the executor to avoid deadlock\n    var cursor = new Cursor(self, query);\n    cursor.limit(1)._exec(function (err, docs) {\n      if (err) { return callback(err); }\n      if (docs.length === 1) {\n        return cb();\n      } else {\n        var toBeInserted;\n\n        try {\n          model.checkObject(updateQuery);\n          // updateQuery is a simple object with no modifier, use it as the document to insert\n          toBeInserted = updateQuery;\n        } catch (e) {\n          // updateQuery contains modifiers, use the find query as the base,\n          // strip it from all operators and update it according to updateQuery\n          try {\n            toBeInserted = model.modify(model.deepCopy(query, true), updateQuery);\n          } catch (err) {\n            return callback(err);\n          }\n        }\n\n        return self._insert(toBeInserted, function (err, newDoc) {\n          if (err) { return callback(err); }\n          return callback(null, 1, newDoc, true);\n        });\n      }\n    });\n  }\n  , function () {   // Perform the update\n    var modifiedDoc , modifications = [], createdAt;\n\n    self.getCandidates(query, function (err, candidates) {\n      if (err) { return callback(err); }\n\n      // Preparing update (if an error is thrown here neither the datafile nor\n      // the in-memory indexes are affected)\n      try {\n        for (i = 0; i < candidates.length; i += 1) {\n          if (model.match(candidates[i], query) && (multi || numReplaced === 0)) {\n            numReplaced += 1;\n            if (self.timestampData) { createdAt = candidates[i].createdAt; }\n            modifiedDoc = model.modify(candidates[i], updateQuery);\n            if (self.timestampData) {\n              modifiedDoc.createdAt = createdAt;\n              modifiedDoc.updatedAt = new Date();\n            }\n            modifications.push({ oldDoc: candidates[i], newDoc: modifiedDoc });\n          }\n        }\n      } catch (err) {\n        return callback(err);\n      }\n\n      // Change the docs in memory\n      try {\n        self.updateIndexes(modifications);\n      } catch (err) {\n        return callback(err);\n      }\n\n      // Update the datafile\n      var updatedDocs = _.pluck(modifications, 'newDoc');\n      self.persistence.persistNewState(updatedDocs, function (err) {\n        if (err) { return callback(err); }\n        if (!options.returnUpdatedDocs) {\n          return callback(null, numReplaced);\n        } else {\n          var updatedDocsDC = [];\n          updatedDocs.forEach(function (doc) { updatedDocsDC.push(model.deepCopy(doc)); });\n          if (! multi) { updatedDocsDC = updatedDocsDC[0]; }\n          return callback(null, numReplaced, updatedDocsDC);\n        }\n      });\n    });\n  }]);\n};\n\nDatastore.prototype.update = function () {\n  this.executor.push({ this: this, fn: this._update, arguments: arguments });\n};\n\n\n/**\n * Remove all docs matching the query\n * For now very naive implementation (similar to update)\n * @param {Object} query\n * @param {Object} options Optional options\n *                 options.multi If true, can update multiple documents (defaults to false)\n * @param {Function} cb Optional callback, signature: err, numRemoved\n *\n * @api private Use Datastore.remove which has the same signature\n */\nDatastore.prototype._remove = function (query, options, cb) {\n  var callback\n    , self = this, numRemoved = 0, removedDocs = [], multi\n    ;\n\n  if (typeof options === 'function') { cb = options; options = {}; }\n  callback = cb || function () {};\n  multi = options.multi !== undefined ? options.multi : false;\n\n  this.getCandidates(query, true, function (err, candidates) {\n    if (err) { return callback(err); }\n\n    try {\n      candidates.forEach(function (d) {\n        if (model.match(d, query) && (multi || numRemoved === 0)) {\n          numRemoved += 1;\n          removedDocs.push({ $$deleted: true, _id: d._id });\n          self.removeFromIndexes(d);\n        }\n      });\n    } catch (err) { return callback(err); }\n\n    self.persistence.persistNewState(removedDocs, function (err) {\n      if (err) { return callback(err); }\n      return callback(null, numRemoved);\n    });\n  });\n};\n\nDatastore.prototype.remove = function () {\n  this.executor.push({ this: this, fn: this._remove, arguments: arguments });\n};\n\n\n\nmodule.exports = Datastore;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbmVkYi9saWIvZGF0YXN0b3JlLmpzP2IyN2EiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGN1c3RvbVV0aWxzID0gcmVxdWlyZSgnLi9jdXN0b21VdGlscycpXG4gICwgbW9kZWwgPSByZXF1aXJlKCcuL21vZGVsJylcbiAgLCBhc3luYyA9IHJlcXVpcmUoJ2FzeW5jJylcbiAgLCBFeGVjdXRvciA9IHJlcXVpcmUoJy4vZXhlY3V0b3InKVxuICAsIEluZGV4ID0gcmVxdWlyZSgnLi9pbmRleGVzJylcbiAgLCB1dGlsID0gcmVxdWlyZSgndXRpbCcpXG4gICwgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKVxuICAsIFBlcnNpc3RlbmNlID0gcmVxdWlyZSgnLi9wZXJzaXN0ZW5jZScpXG4gICwgQ3Vyc29yID0gcmVxdWlyZSgnLi9jdXJzb3InKVxuICA7XG5cblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgY29sbGVjdGlvblxuICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMuZmlsZW5hbWUgT3B0aW9uYWwsIGRhdGFzdG9yZSB3aWxsIGJlIGluLW1lbW9yeSBvbmx5IGlmIG5vdCBwcm92aWRlZFxuICogQHBhcmFtIHtCb29sZWFufSBvcHRpb25zLnRpbWVzdGFtcERhdGEgT3B0aW9uYWwsIGRlZmF1bHRzIHRvIGZhbHNlLiBJZiBzZXQgdG8gdHJ1ZSwgY3JlYXRlZEF0IGFuZCB1cGRhdGVkQXQgd2lsbCBiZSBjcmVhdGVkIGFuZCBwb3B1bGF0ZWQgYXV0b21hdGljYWxseSAoaWYgbm90IHNwZWNpZmllZCBieSB1c2VyKVxuICogQHBhcmFtIHtCb29sZWFufSBvcHRpb25zLmluTWVtb3J5T25seSBPcHRpb25hbCwgZGVmYXVsdHMgdG8gZmFsc2VcbiAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLm5vZGVXZWJraXRBcHBOYW1lIE9wdGlvbmFsLCBzcGVjaWZ5IHRoZSBuYW1lIG9mIHlvdXIgTlcgYXBwIGlmIHlvdSB3YW50IG9wdGlvbnMuZmlsZW5hbWUgdG8gYmUgcmVsYXRpdmUgdG8gdGhlIGRpcmVjdG9yeSB3aGVyZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE5vZGUgV2Via2l0IHN0b3JlcyBhcHBsaWNhdGlvbiBkYXRhIHN1Y2ggYXMgY29va2llcyBhbmQgbG9jYWwgc3RvcmFnZSAodGhlIGJlc3QgcGxhY2UgdG8gc3RvcmUgZGF0YSBpbiBteSBvcGluaW9uKVxuICogQHBhcmFtIHtCb29sZWFufSBvcHRpb25zLmF1dG9sb2FkIE9wdGlvbmFsLCBkZWZhdWx0cyB0byBmYWxzZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gb3B0aW9ucy5vbmxvYWQgT3B0aW9uYWwsIGlmIGF1dG9sb2FkIGlzIHVzZWQgdGhpcyB3aWxsIGJlIGNhbGxlZCBhZnRlciB0aGUgbG9hZCBkYXRhYmFzZSB3aXRoIHRoZSBlcnJvciBvYmplY3QgYXMgcGFyYW1ldGVyLiBJZiB5b3UgZG9uJ3QgcGFzcyBpdCB0aGUgZXJyb3Igd2lsbCBiZSB0aHJvd25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IG9wdGlvbnMuYWZ0ZXJTZXJpYWxpemF0aW9uL29wdGlvbnMuYmVmb3JlRGVzZXJpYWxpemF0aW9uIE9wdGlvbmFsLCBzZXJpYWxpemF0aW9uIGhvb2tzXG4gKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5jb3JydXB0QWxlcnRUaHJlc2hvbGQgT3B0aW9uYWwsIHRocmVzaG9sZCBhZnRlciB3aGljaCBhbiBhbGVydCBpcyB0aHJvd24gaWYgdG9vIG11Y2ggZGF0YSBpcyBjb3JydXB0XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcHRpb25zLmNvbXBhcmVTdHJpbmdzIE9wdGlvbmFsLCBzdHJpbmcgY29tcGFyaXNvbiBmdW5jdGlvbiB0aGF0IG92ZXJyaWRlcyBkZWZhdWx0IGZvciBzb3J0aW5nXG4gKlxuICogRXZlbnQgRW1pdHRlciAtIEV2ZW50c1xuICogKiBjb21wYWN0aW9uLmRvbmUgLSBGaXJlZCB3aGVuZXZlciBhIGNvbXBhY3Rpb24gb3BlcmF0aW9uIHdhcyBmaW5pc2hlZFxuICovXG5mdW5jdGlvbiBEYXRhc3RvcmUgKG9wdGlvbnMpIHtcbiAgdmFyIGZpbGVuYW1lO1xuXG4gIC8vIFJldHJvY29tcGF0aWJpbGl0eSB3aXRoIHYwLjYgYW5kIGJlZm9yZVxuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgZmlsZW5hbWUgPSBvcHRpb25zO1xuICAgIHRoaXMuaW5NZW1vcnlPbmx5ID0gZmFsc2U7ICAgLy8gRGVmYXVsdFxuICB9IGVsc2Uge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGZpbGVuYW1lID0gb3B0aW9ucy5maWxlbmFtZTtcbiAgICB0aGlzLmluTWVtb3J5T25seSA9IG9wdGlvbnMuaW5NZW1vcnlPbmx5IHx8IGZhbHNlO1xuICAgIHRoaXMuYXV0b2xvYWQgPSBvcHRpb25zLmF1dG9sb2FkIHx8IGZhbHNlO1xuICAgIHRoaXMudGltZXN0YW1wRGF0YSA9IG9wdGlvbnMudGltZXN0YW1wRGF0YSB8fCBmYWxzZTtcbiAgfVxuXG4gIC8vIERldGVybWluZSB3aGV0aGVyIGluIG1lbW9yeSBvciBwZXJzaXN0ZW50XG4gIGlmICghZmlsZW5hbWUgfHwgdHlwZW9mIGZpbGVuYW1lICE9PSAnc3RyaW5nJyB8fCBmaWxlbmFtZS5sZW5ndGggPT09IDApIHtcbiAgICB0aGlzLmZpbGVuYW1lID0gbnVsbDtcbiAgICB0aGlzLmluTWVtb3J5T25seSA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5maWxlbmFtZSA9IGZpbGVuYW1lO1xuICB9XG5cbiAgLy8gU3RyaW5nIGNvbXBhcmlzb24gZnVuY3Rpb25cbiAgdGhpcy5jb21wYXJlU3RyaW5ncyA9IG9wdGlvbnMuY29tcGFyZVN0cmluZ3M7XG5cbiAgLy8gUGVyc2lzdGVuY2UgaGFuZGxpbmdcbiAgdGhpcy5wZXJzaXN0ZW5jZSA9IG5ldyBQZXJzaXN0ZW5jZSh7IGRiOiB0aGlzLCBub2RlV2Via2l0QXBwTmFtZTogb3B0aW9ucy5ub2RlV2Via2l0QXBwTmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAsIGFmdGVyU2VyaWFsaXphdGlvbjogb3B0aW9ucy5hZnRlclNlcmlhbGl6YXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLCBiZWZvcmVEZXNlcmlhbGl6YXRpb246IG9wdGlvbnMuYmVmb3JlRGVzZXJpYWxpemF0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICwgY29ycnVwdEFsZXJ0VGhyZXNob2xkOiBvcHRpb25zLmNvcnJ1cHRBbGVydFRocmVzaG9sZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAvLyBUaGlzIG5ldyBleGVjdXRvciBpcyByZWFkeSBpZiB3ZSBkb24ndCB1c2UgcGVyc2lzdGVuY2VcbiAgLy8gSWYgd2UgZG8sIGl0IHdpbGwgb25seSBiZSByZWFkeSBvbmNlIGxvYWREYXRhYmFzZSBpcyBjYWxsZWRcbiAgdGhpcy5leGVjdXRvciA9IG5ldyBFeGVjdXRvcigpO1xuICBpZiAodGhpcy5pbk1lbW9yeU9ubHkpIHsgdGhpcy5leGVjdXRvci5yZWFkeSA9IHRydWU7IH1cblxuICAvLyBJbmRleGVkIGJ5IGZpZWxkIG5hbWUsIGRvdCBub3RhdGlvbiBjYW4gYmUgdXNlZFxuICAvLyBfaWQgaXMgYWx3YXlzIGluZGV4ZWQgYW5kIHNpbmNlIF9pZHMgYXJlIGdlbmVyYXRlZCByYW5kb21seSB0aGUgdW5kZXJseWluZ1xuICAvLyBiaW5hcnkgaXMgYWx3YXlzIHdlbGwtYmFsYW5jZWRcbiAgdGhpcy5pbmRleGVzID0ge307XG4gIHRoaXMuaW5kZXhlcy5faWQgPSBuZXcgSW5kZXgoeyBmaWVsZE5hbWU6ICdfaWQnLCB1bmlxdWU6IHRydWUgfSk7XG4gIHRoaXMudHRsSW5kZXhlcyA9IHt9O1xuXG4gIC8vIFF1ZXVlIGEgbG9hZCBvZiB0aGUgZGF0YWJhc2UgcmlnaHQgYXdheSBhbmQgY2FsbCB0aGUgb25sb2FkIGhhbmRsZXJcbiAgLy8gQnkgZGVmYXVsdCAobm8gb25sb2FkIGhhbmRsZXIpLCBpZiB0aGVyZSBpcyBhbiBlcnJvciB0aGVyZSwgbm8gb3BlcmF0aW9uIHdpbGwgYmUgcG9zc2libGUgc28gd2FybiB0aGUgdXNlciBieSB0aHJvd2luZyBhbiBleGNlcHRpb25cbiAgaWYgKHRoaXMuYXV0b2xvYWQpIHsgdGhpcy5sb2FkRGF0YWJhc2Uob3B0aW9ucy5vbmxvYWQgfHwgZnVuY3Rpb24gKGVycikge1xuICAgIGlmIChlcnIpIHsgdGhyb3cgZXJyOyB9XG4gIH0pOyB9XG59XG5cbnV0aWwuaW5oZXJpdHMoRGF0YXN0b3JlLCByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXIpO1xuXG5cbi8qKlxuICogTG9hZCB0aGUgZGF0YWJhc2UgZnJvbSB0aGUgZGF0YWZpbGUsIGFuZCB0cmlnZ2VyIHRoZSBleGVjdXRpb24gb2YgYnVmZmVyZWQgY29tbWFuZHMgaWYgYW55XG4gKi9cbkRhdGFzdG9yZS5wcm90b3R5cGUubG9hZERhdGFiYXNlID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmV4ZWN1dG9yLnB1c2goeyB0aGlzOiB0aGlzLnBlcnNpc3RlbmNlLCBmbjogdGhpcy5wZXJzaXN0ZW5jZS5sb2FkRGF0YWJhc2UsIGFyZ3VtZW50czogYXJndW1lbnRzIH0sIHRydWUpO1xufTtcblxuXG4vKipcbiAqIEdldCBhbiBhcnJheSBvZiBhbGwgdGhlIGRhdGEgaW4gdGhlIGRhdGFiYXNlXG4gKi9cbkRhdGFzdG9yZS5wcm90b3R5cGUuZ2V0QWxsRGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuaW5kZXhlcy5faWQuZ2V0QWxsKCk7XG59O1xuXG5cbi8qKlxuICogUmVzZXQgYWxsIGN1cnJlbnRseSBkZWZpbmVkIGluZGV4ZXNcbiAqL1xuRGF0YXN0b3JlLnByb3RvdHlwZS5yZXNldEluZGV4ZXMgPSBmdW5jdGlvbiAobmV3RGF0YSkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgT2JqZWN0LmtleXModGhpcy5pbmRleGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChpKSB7XG4gICAgc2VsZi5pbmRleGVzW2ldLnJlc2V0KG5ld0RhdGEpO1xuICB9KTtcbn07XG5cblxuLyoqXG4gKiBFbnN1cmUgYW4gaW5kZXggaXMga2VwdCBmb3IgdGhpcyBmaWVsZC4gU2FtZSBwYXJhbWV0ZXJzIGFzIGxpYi9pbmRleGVzXG4gKiBGb3Igbm93IHRoaXMgZnVuY3Rpb24gaXMgc3luY2hyb25vdXMsIHdlIG5lZWQgdG8gdGVzdCBob3cgbXVjaCB0aW1lIGl0IHRha2VzXG4gKiBXZSB1c2UgYW4gYXN5bmMgQVBJIGZvciBjb25zaXN0ZW5jeSB3aXRoIHRoZSByZXN0IG9mIHRoZSBjb2RlXG4gKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy5maWVsZE5hbWVcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gb3B0aW9ucy51bmlxdWVcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gb3B0aW9ucy5zcGFyc2VcbiAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLmV4cGlyZUFmdGVyU2Vjb25kcyAtIE9wdGlvbmFsLCBpZiBzZXQgdGhpcyBpbmRleCBiZWNvbWVzIGEgVFRMIGluZGV4IChvbmx5IHdvcmtzIG9uIERhdGUgZmllbGRzLCBub3QgYXJyYXlzIG9mIERhdGUpXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBPcHRpb25hbCBjYWxsYmFjaywgc2lnbmF0dXJlOiBlcnJcbiAqL1xuRGF0YXN0b3JlLnByb3RvdHlwZS5lbnN1cmVJbmRleCA9IGZ1bmN0aW9uIChvcHRpb25zLCBjYikge1xuICB2YXIgZXJyXG4gICAgLCBjYWxsYmFjayA9IGNiIHx8IGZ1bmN0aW9uICgpIHt9O1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIGlmICghb3B0aW9ucy5maWVsZE5hbWUpIHtcbiAgICBlcnIgPSBuZXcgRXJyb3IoXCJDYW5ub3QgY3JlYXRlIGFuIGluZGV4IHdpdGhvdXQgYSBmaWVsZE5hbWVcIik7XG4gICAgZXJyLm1pc3NpbmdGaWVsZE5hbWUgPSB0cnVlO1xuICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICB9XG4gIGlmICh0aGlzLmluZGV4ZXNbb3B0aW9ucy5maWVsZE5hbWVdKSB7IHJldHVybiBjYWxsYmFjayhudWxsKTsgfVxuXG4gIHRoaXMuaW5kZXhlc1tvcHRpb25zLmZpZWxkTmFtZV0gPSBuZXcgSW5kZXgob3B0aW9ucyk7XG4gIGlmIChvcHRpb25zLmV4cGlyZUFmdGVyU2Vjb25kcyAhPT0gdW5kZWZpbmVkKSB7IHRoaXMudHRsSW5kZXhlc1tvcHRpb25zLmZpZWxkTmFtZV0gPSBvcHRpb25zLmV4cGlyZUFmdGVyU2Vjb25kczsgfSAgIC8vIFdpdGggdGhpcyBpbXBsZW1lbnRhdGlvbiBpbmRleCBjcmVhdGlvbiBpcyBub3QgbmVjZXNzYXJ5IHRvIGVuc3VyZSBUVEwgYnV0IHdlIHN0aWNrIHdpdGggTW9uZ29EQidzIEFQSSBoZXJlXG5cbiAgdHJ5IHtcbiAgICB0aGlzLmluZGV4ZXNbb3B0aW9ucy5maWVsZE5hbWVdLmluc2VydCh0aGlzLmdldEFsbERhdGEoKSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBkZWxldGUgdGhpcy5pbmRleGVzW29wdGlvbnMuZmllbGROYW1lXTtcbiAgICByZXR1cm4gY2FsbGJhY2soZSk7XG4gIH1cblxuICAvLyBXZSBtYXkgd2FudCB0byBmb3JjZSBhbGwgb3B0aW9ucyB0byBiZSBwZXJzaXN0ZWQgaW5jbHVkaW5nIGRlZmF1bHRzLCBub3QganVzdCB0aGUgb25lcyBwYXNzZWQgdGhlIGluZGV4IGNyZWF0aW9uIGZ1bmN0aW9uXG4gIHRoaXMucGVyc2lzdGVuY2UucGVyc2lzdE5ld1N0YXRlKFt7ICQkaW5kZXhDcmVhdGVkOiBvcHRpb25zIH1dLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYgKGVycikgeyByZXR1cm4gY2FsbGJhY2soZXJyKTsgfVxuICAgIHJldHVybiBjYWxsYmFjayhudWxsKTtcbiAgfSk7XG59O1xuXG5cbi8qKlxuICogUmVtb3ZlIGFuIGluZGV4XG4gKiBAcGFyYW0ge1N0cmluZ30gZmllbGROYW1lXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBPcHRpb25hbCBjYWxsYmFjaywgc2lnbmF0dXJlOiBlcnJcbiAqL1xuRGF0YXN0b3JlLnByb3RvdHlwZS5yZW1vdmVJbmRleCA9IGZ1bmN0aW9uIChmaWVsZE5hbWUsIGNiKSB7XG4gIHZhciBjYWxsYmFjayA9IGNiIHx8IGZ1bmN0aW9uICgpIHt9O1xuXG4gIGRlbGV0ZSB0aGlzLmluZGV4ZXNbZmllbGROYW1lXTtcblxuICB0aGlzLnBlcnNpc3RlbmNlLnBlcnNpc3ROZXdTdGF0ZShbeyAkJGluZGV4UmVtb3ZlZDogZmllbGROYW1lIH1dLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYgKGVycikgeyByZXR1cm4gY2FsbGJhY2soZXJyKTsgfVxuICAgIHJldHVybiBjYWxsYmFjayhudWxsKTtcbiAgfSk7XG59O1xuXG5cbi8qKlxuICogQWRkIG9uZSBvciBzZXZlcmFsIGRvY3VtZW50KHMpIHRvIGFsbCBpbmRleGVzXG4gKi9cbkRhdGFzdG9yZS5wcm90b3R5cGUuYWRkVG9JbmRleGVzID0gZnVuY3Rpb24gKGRvYykge1xuICB2YXIgaSwgZmFpbGluZ0luZGV4LCBlcnJvclxuICAgICwga2V5cyA9IE9iamVjdC5rZXlzKHRoaXMuaW5kZXhlcylcbiAgICA7XG5cbiAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICB0cnkge1xuICAgICAgdGhpcy5pbmRleGVzW2tleXNbaV1dLmluc2VydChkb2MpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGZhaWxpbmdJbmRleCA9IGk7XG4gICAgICBlcnJvciA9IGU7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICAvLyBJZiBhbiBlcnJvciBoYXBwZW5lZCwgd2UgbmVlZCB0byByb2xsYmFjayB0aGUgaW5zZXJ0IG9uIGFsbCBvdGhlciBpbmRleGVzXG4gIGlmIChlcnJvcikge1xuICAgIGZvciAoaSA9IDA7IGkgPCBmYWlsaW5nSW5kZXg7IGkgKz0gMSkge1xuICAgICAgdGhpcy5pbmRleGVzW2tleXNbaV1dLnJlbW92ZShkb2MpO1xuICAgIH1cblxuICAgIHRocm93IGVycm9yO1xuICB9XG59O1xuXG5cbi8qKlxuICogUmVtb3ZlIG9uZSBvciBzZXZlcmFsIGRvY3VtZW50KHMpIGZyb20gYWxsIGluZGV4ZXNcbiAqL1xuRGF0YXN0b3JlLnByb3RvdHlwZS5yZW1vdmVGcm9tSW5kZXhlcyA9IGZ1bmN0aW9uIChkb2MpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIE9iamVjdC5rZXlzKHRoaXMuaW5kZXhlcykuZm9yRWFjaChmdW5jdGlvbiAoaSkge1xuICAgIHNlbGYuaW5kZXhlc1tpXS5yZW1vdmUoZG9jKTtcbiAgfSk7XG59O1xuXG5cbi8qKlxuICogVXBkYXRlIG9uZSBvciBzZXZlcmFsIGRvY3VtZW50cyBpbiBhbGwgaW5kZXhlc1xuICogVG8gdXBkYXRlIG11bHRpcGxlIGRvY3VtZW50cywgb2xkRG9jIG11c3QgYmUgYW4gYXJyYXkgb2YgeyBvbGREb2MsIG5ld0RvYyB9IHBhaXJzXG4gKiBJZiBvbmUgdXBkYXRlIHZpb2xhdGVzIGEgY29uc3RyYWludCwgYWxsIGNoYW5nZXMgYXJlIHJvbGxlZCBiYWNrXG4gKi9cbkRhdGFzdG9yZS5wcm90b3R5cGUudXBkYXRlSW5kZXhlcyA9IGZ1bmN0aW9uIChvbGREb2MsIG5ld0RvYykge1xuICB2YXIgaSwgZmFpbGluZ0luZGV4LCBlcnJvclxuICAgICwga2V5cyA9IE9iamVjdC5rZXlzKHRoaXMuaW5kZXhlcylcbiAgICA7XG5cbiAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICB0cnkge1xuICAgICAgdGhpcy5pbmRleGVzW2tleXNbaV1dLnVwZGF0ZShvbGREb2MsIG5ld0RvYyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZmFpbGluZ0luZGV4ID0gaTtcbiAgICAgIGVycm9yID0gZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIC8vIElmIGFuIGVycm9yIGhhcHBlbmVkLCB3ZSBuZWVkIHRvIHJvbGxiYWNrIHRoZSB1cGRhdGUgb24gYWxsIG90aGVyIGluZGV4ZXNcbiAgaWYgKGVycm9yKSB7XG4gICAgZm9yIChpID0gMDsgaSA8IGZhaWxpbmdJbmRleDsgaSArPSAxKSB7XG4gICAgICB0aGlzLmluZGV4ZXNba2V5c1tpXV0ucmV2ZXJ0VXBkYXRlKG9sZERvYywgbmV3RG9jKTtcbiAgICB9XG5cbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufTtcblxuXG4vKipcbiAqIFJldHVybiB0aGUgbGlzdCBvZiBjYW5kaWRhdGVzIGZvciBhIGdpdmVuIHF1ZXJ5XG4gKiBDcnVkZSBpbXBsZW1lbnRhdGlvbiBmb3Igbm93LCB3ZSByZXR1cm4gdGhlIGNhbmRpZGF0ZXMgZ2l2ZW4gYnkgdGhlIGZpcnN0IHVzYWJsZSBpbmRleCBpZiBhbnlcbiAqIFdlIHRyeSB0aGUgZm9sbG93aW5nIHF1ZXJ5IHR5cGVzLCBpbiB0aGlzIG9yZGVyOiBiYXNpYyBtYXRjaCwgJGluIG1hdGNoLCBjb21wYXJpc29uIG1hdGNoXG4gKiBPbmUgd2F5IHRvIG1ha2UgaXQgYmV0dGVyIHdvdWxkIGJlIHRvIGVuYWJsZSB0aGUgdXNlIG9mIG11bHRpcGxlIGluZGV4ZXMgaWYgdGhlIGZpcnN0IHVzYWJsZSBpbmRleFxuICogcmV0dXJucyB0b28gbXVjaCBkYXRhLiBJIG1heSBkbyBpdCBpbiB0aGUgZnV0dXJlLlxuICpcbiAqIFJldHVybmVkIGNhbmRpZGF0ZXMgd2lsbCBiZSBzY2FubmVkIHRvIGZpbmQgYW5kIHJlbW92ZSBhbGwgZXhwaXJlZCBkb2N1bWVudHNcbiAqXG4gKiBAcGFyYW0ge1F1ZXJ5fSBxdWVyeVxuICogQHBhcmFtIHtCb29sZWFufSBkb250RXhwaXJlU3RhbGVEb2NzIE9wdGlvbmFsLCBkZWZhdWx0cyB0byBmYWxzZSwgaWYgdHJ1ZSBkb24ndCByZW1vdmUgc3RhbGUgZG9jcy4gVXNlZnVsIGZvciB0aGUgcmVtb3ZlIGZ1bmN0aW9uIHdoaWNoIHNob3VsZG4ndCBiZSBpbXBhY3RlZCBieSBleHBpcmF0aW9uc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgU2lnbmF0dXJlIGVyciwgZG9jc1xuICovXG5EYXRhc3RvcmUucHJvdG90eXBlLmdldENhbmRpZGF0ZXMgPSBmdW5jdGlvbiAocXVlcnksIGRvbnRFeHBpcmVTdGFsZURvY3MsIGNhbGxiYWNrKSB7XG4gIHZhciBpbmRleE5hbWVzID0gT2JqZWN0LmtleXModGhpcy5pbmRleGVzKVxuICAgICwgc2VsZiA9IHRoaXNcbiAgICAsIHVzYWJsZVF1ZXJ5S2V5cztcblxuICBpZiAodHlwZW9mIGRvbnRFeHBpcmVTdGFsZURvY3MgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IGRvbnRFeHBpcmVTdGFsZURvY3M7XG4gICAgZG9udEV4cGlyZVN0YWxlRG9jcyA9IGZhbHNlO1xuICB9XG5cbiAgYXN5bmMud2F0ZXJmYWxsKFtcbiAgLy8gU1RFUCAxOiBnZXQgY2FuZGlkYXRlcyBsaXN0IGJ5IGNoZWNraW5nIGluZGV4ZXMgZnJvbSBtb3N0IHRvIGxlYXN0IGZyZXF1ZW50IHVzZWNhc2VcbiAgZnVuY3Rpb24gKGNiKSB7XG4gICAgLy8gRm9yIGEgYmFzaWMgbWF0Y2hcbiAgICB1c2FibGVRdWVyeUtleXMgPSBbXTtcbiAgICBPYmplY3Qua2V5cyhxdWVyeSkuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgICAgaWYgKHR5cGVvZiBxdWVyeVtrXSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHF1ZXJ5W2tdID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgcXVlcnlba10gPT09ICdib29sZWFuJyB8fCB1dGlsLmlzRGF0ZShxdWVyeVtrXSkgfHwgcXVlcnlba10gPT09IG51bGwpIHtcbiAgICAgICAgdXNhYmxlUXVlcnlLZXlzLnB1c2goayk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdXNhYmxlUXVlcnlLZXlzID0gXy5pbnRlcnNlY3Rpb24odXNhYmxlUXVlcnlLZXlzLCBpbmRleE5hbWVzKTtcbiAgICBpZiAodXNhYmxlUXVlcnlLZXlzLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiBjYihudWxsLCBzZWxmLmluZGV4ZXNbdXNhYmxlUXVlcnlLZXlzWzBdXS5nZXRNYXRjaGluZyhxdWVyeVt1c2FibGVRdWVyeUtleXNbMF1dKSk7XG4gICAgfVxuXG4gICAgLy8gRm9yIGEgJGluIG1hdGNoXG4gICAgdXNhYmxlUXVlcnlLZXlzID0gW107XG4gICAgT2JqZWN0LmtleXMocXVlcnkpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICAgIGlmIChxdWVyeVtrXSAmJiBxdWVyeVtrXS5oYXNPd25Qcm9wZXJ0eSgnJGluJykpIHtcbiAgICAgICAgdXNhYmxlUXVlcnlLZXlzLnB1c2goayk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdXNhYmxlUXVlcnlLZXlzID0gXy5pbnRlcnNlY3Rpb24odXNhYmxlUXVlcnlLZXlzLCBpbmRleE5hbWVzKTtcbiAgICBpZiAodXNhYmxlUXVlcnlLZXlzLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiBjYihudWxsLCBzZWxmLmluZGV4ZXNbdXNhYmxlUXVlcnlLZXlzWzBdXS5nZXRNYXRjaGluZyhxdWVyeVt1c2FibGVRdWVyeUtleXNbMF1dLiRpbikpO1xuICAgIH1cblxuICAgIC8vIEZvciBhIGNvbXBhcmlzb24gbWF0Y2hcbiAgICB1c2FibGVRdWVyeUtleXMgPSBbXTtcbiAgICBPYmplY3Qua2V5cyhxdWVyeSkuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgICAgaWYgKHF1ZXJ5W2tdICYmIChxdWVyeVtrXS5oYXNPd25Qcm9wZXJ0eSgnJGx0JykgfHwgcXVlcnlba10uaGFzT3duUHJvcGVydHkoJyRsdGUnKSB8fCBxdWVyeVtrXS5oYXNPd25Qcm9wZXJ0eSgnJGd0JykgfHwgcXVlcnlba10uaGFzT3duUHJvcGVydHkoJyRndGUnKSkpIHtcbiAgICAgICAgdXNhYmxlUXVlcnlLZXlzLnB1c2goayk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdXNhYmxlUXVlcnlLZXlzID0gXy5pbnRlcnNlY3Rpb24odXNhYmxlUXVlcnlLZXlzLCBpbmRleE5hbWVzKTtcbiAgICBpZiAodXNhYmxlUXVlcnlLZXlzLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiBjYihudWxsLCBzZWxmLmluZGV4ZXNbdXNhYmxlUXVlcnlLZXlzWzBdXS5nZXRCZXR3ZWVuQm91bmRzKHF1ZXJ5W3VzYWJsZVF1ZXJ5S2V5c1swXV0pKTtcbiAgICB9XG5cbiAgICAvLyBCeSBkZWZhdWx0LCByZXR1cm4gYWxsIHRoZSBEQiBkYXRhXG4gICAgcmV0dXJuIGNiKG51bGwsIHNlbGYuZ2V0QWxsRGF0YSgpKTtcbiAgfVxuICAvLyBTVEVQIDI6IHJlbW92ZSBhbGwgZXhwaXJlZCBkb2N1bWVudHNcbiAgLCBmdW5jdGlvbiAoZG9jcykge1xuICAgIGlmIChkb250RXhwaXJlU3RhbGVEb2NzKSB7IHJldHVybiBjYWxsYmFjayhudWxsLCBkb2NzKTsgfVxuXG4gICAgdmFyIGV4cGlyZWREb2NzSWRzID0gW10sIHZhbGlkRG9jcyA9IFtdLCB0dGxJbmRleGVzRmllbGROYW1lcyA9IE9iamVjdC5rZXlzKHNlbGYudHRsSW5kZXhlcyk7XG5cbiAgICBkb2NzLmZvckVhY2goZnVuY3Rpb24gKGRvYykge1xuICAgICAgdmFyIHZhbGlkID0gdHJ1ZTtcbiAgICAgIHR0bEluZGV4ZXNGaWVsZE5hbWVzLmZvckVhY2goZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgaWYgKGRvY1tpXSAhPT0gdW5kZWZpbmVkICYmIHV0aWwuaXNEYXRlKGRvY1tpXSkgJiYgRGF0ZS5ub3coKSA+IGRvY1tpXS5nZXRUaW1lKCkgKyBzZWxmLnR0bEluZGV4ZXNbaV0gKiAxMDAwKcKge1xuICAgICAgICAgIHZhbGlkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKHZhbGlkKSB7IHZhbGlkRG9jcy5wdXNoKGRvYyk7IH0gZWxzZSB7IGV4cGlyZWREb2NzSWRzLnB1c2goZG9jLl9pZCk7IH1cbiAgICB9KTtcblxuICAgIGFzeW5jLmVhY2hTZXJpZXMoZXhwaXJlZERvY3NJZHMsIGZ1bmN0aW9uIChfaWQsIGNiKSB7XG4gICAgICBzZWxmLl9yZW1vdmUoeyBfaWQ6IF9pZCB9LCB7fSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICBpZiAoZXJyKSB7IHJldHVybiBjYWxsYmFjayhlcnIpOyB9XG4gICAgICAgIHJldHVybiBjYigpO1xuICAgICAgfSk7XG4gICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHZhbGlkRG9jcyk7XG4gICAgfSk7XG4gIH1dKTtcbn07XG5cblxuLyoqXG4gKiBJbnNlcnQgYSBuZXcgZG9jdW1lbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIE9wdGlvbmFsIGNhbGxiYWNrLCBzaWduYXR1cmU6IGVyciwgaW5zZXJ0ZWREb2NcbiAqXG4gKiBAYXBpIHByaXZhdGUgVXNlIERhdGFzdG9yZS5pbnNlcnQgd2hpY2ggaGFzIHRoZSBzYW1lIHNpZ25hdHVyZVxuICovXG5EYXRhc3RvcmUucHJvdG90eXBlLl9pbnNlcnQgPSBmdW5jdGlvbiAobmV3RG9jLCBjYikge1xuICB2YXIgY2FsbGJhY2sgPSBjYiB8fCBmdW5jdGlvbiAoKSB7fVxuICAgICwgcHJlcGFyZWREb2NcbiAgICA7XG5cbiAgdHJ5IHtcbiAgICBwcmVwYXJlZERvYyA9IHRoaXMucHJlcGFyZURvY3VtZW50Rm9ySW5zZXJ0aW9uKG5ld0RvYylcbiAgICB0aGlzLl9pbnNlcnRJbkNhY2hlKHByZXBhcmVkRG9jKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBjYWxsYmFjayhlKTtcbiAgfVxuXG4gIHRoaXMucGVyc2lzdGVuY2UucGVyc2lzdE5ld1N0YXRlKHV0aWwuaXNBcnJheShwcmVwYXJlZERvYykgPyBwcmVwYXJlZERvYyA6IFtwcmVwYXJlZERvY10sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAoZXJyKSB7IHJldHVybiBjYWxsYmFjayhlcnIpOyB9XG4gICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIG1vZGVsLmRlZXBDb3B5KHByZXBhcmVkRG9jKSk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgX2lkIHRoYXQncyBub3QgYWxyZWFkeSBpbiB1c2VcbiAqL1xuRGF0YXN0b3JlLnByb3RvdHlwZS5jcmVhdGVOZXdJZCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHRlbnRhdGl2ZUlkID0gY3VzdG9tVXRpbHMudWlkKDE2KTtcbiAgLy8gVHJ5IGFzIG1hbnkgdGltZXMgYXMgbmVlZGVkIHRvIGdldCBhbiB1bnVzZWQgX2lkLiBBcyBleHBsYWluZWQgaW4gY3VzdG9tVXRpbHMsIHRoZSBwcm9iYWJpbGl0eSBvZiB0aGlzIGV2ZXIgaGFwcGVuaW5nIGlzIGV4dHJlbWVseSBzbWFsbCwgc28gdGhpcyBpcyBPKDEpXG4gIGlmICh0aGlzLmluZGV4ZXMuX2lkLmdldE1hdGNoaW5nKHRlbnRhdGl2ZUlkKS5sZW5ndGggPiAwKSB7XG4gICAgdGVudGF0aXZlSWQgPSB0aGlzLmNyZWF0ZU5ld0lkKCk7XG4gIH1cbiAgcmV0dXJuIHRlbnRhdGl2ZUlkO1xufTtcblxuLyoqXG4gKiBQcmVwYXJlIGEgZG9jdW1lbnQgKG9yIGFycmF5IG9mIGRvY3VtZW50cykgdG8gYmUgaW5zZXJ0ZWQgaW4gYSBkYXRhYmFzZVxuICogTWVhbmluZyBhZGRzIF9pZCBhbmQgdGltZXN0YW1wcyBpZiBuZWNlc3Nhcnkgb24gYSBjb3B5IG9mIG5ld0RvYyB0byBhdm9pZCBhbnkgc2lkZSBlZmZlY3Qgb24gdXNlciBpbnB1dFxuICogQGFwaSBwcml2YXRlXG4gKi9cbkRhdGFzdG9yZS5wcm90b3R5cGUucHJlcGFyZURvY3VtZW50Rm9ySW5zZXJ0aW9uID0gZnVuY3Rpb24gKG5ld0RvYykge1xuICB2YXIgcHJlcGFyZWREb2MsIHNlbGYgPSB0aGlzO1xuXG4gIGlmICh1dGlsLmlzQXJyYXkobmV3RG9jKSkge1xuICAgIHByZXBhcmVkRG9jID0gW107XG4gICAgbmV3RG9jLmZvckVhY2goZnVuY3Rpb24gKGRvYykgeyBwcmVwYXJlZERvYy5wdXNoKHNlbGYucHJlcGFyZURvY3VtZW50Rm9ySW5zZXJ0aW9uKGRvYykpOyB9KTtcbiAgfSBlbHNlIHtcbiAgICBwcmVwYXJlZERvYyA9IG1vZGVsLmRlZXBDb3B5KG5ld0RvYyk7XG4gICAgaWYgKHByZXBhcmVkRG9jLl9pZCA9PT0gdW5kZWZpbmVkKSB7IHByZXBhcmVkRG9jLl9pZCA9IHRoaXMuY3JlYXRlTmV3SWQoKTsgfVxuICAgIHZhciBub3cgPSBuZXcgRGF0ZSgpO1xuICAgIGlmICh0aGlzLnRpbWVzdGFtcERhdGEgJiYgcHJlcGFyZWREb2MuY3JlYXRlZEF0ID09PSB1bmRlZmluZWQpIHsgcHJlcGFyZWREb2MuY3JlYXRlZEF0ID0gbm93OyB9XG4gICAgaWYgKHRoaXMudGltZXN0YW1wRGF0YSAmJiBwcmVwYXJlZERvYy51cGRhdGVkQXQgPT09IHVuZGVmaW5lZCkgeyBwcmVwYXJlZERvYy51cGRhdGVkQXQgPSBub3c7IH1cbiAgICBtb2RlbC5jaGVja09iamVjdChwcmVwYXJlZERvYyk7XG4gIH1cblxuICByZXR1cm4gcHJlcGFyZWREb2M7XG59O1xuXG4vKipcbiAqIElmIG5ld0RvYyBpcyBhbiBhcnJheSBvZiBkb2N1bWVudHMsIHRoaXMgd2lsbCBpbnNlcnQgYWxsIGRvY3VtZW50cyBpbiB0aGUgY2FjaGVcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5EYXRhc3RvcmUucHJvdG90eXBlLl9pbnNlcnRJbkNhY2hlID0gZnVuY3Rpb24gKHByZXBhcmVkRG9jKSB7XG4gIGlmICh1dGlsLmlzQXJyYXkocHJlcGFyZWREb2MpKSB7XG4gICAgdGhpcy5faW5zZXJ0TXVsdGlwbGVEb2NzSW5DYWNoZShwcmVwYXJlZERvYyk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5hZGRUb0luZGV4ZXMocHJlcGFyZWREb2MpO1xuICB9XG59O1xuXG4vKipcbiAqIElmIG9uZSBpbnNlcnRpb24gZmFpbHMgKGUuZy4gYmVjYXVzZSBvZiBhIHVuaXF1ZSBjb25zdHJhaW50KSwgcm9sbCBiYWNrIGFsbCBwcmV2aW91c1xuICogaW5zZXJ0cyBhbmQgdGhyb3dzIHRoZSBlcnJvclxuICogQGFwaSBwcml2YXRlXG4gKi9cbkRhdGFzdG9yZS5wcm90b3R5cGUuX2luc2VydE11bHRpcGxlRG9jc0luQ2FjaGUgPSBmdW5jdGlvbiAocHJlcGFyZWREb2NzKSB7XG4gIHZhciBpLCBmYWlsaW5nSSwgZXJyb3I7XG5cbiAgZm9yIChpID0gMDsgaSA8IHByZXBhcmVkRG9jcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLmFkZFRvSW5kZXhlcyhwcmVwYXJlZERvY3NbaV0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGVycm9yID0gZTtcbiAgICAgIGZhaWxpbmdJID0gaTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGlmIChlcnJvcikge1xuICAgIGZvciAoaSA9IDA7IGkgPCBmYWlsaW5nSTsgaSArPSAxKSB7XG4gICAgICB0aGlzLnJlbW92ZUZyb21JbmRleGVzKHByZXBhcmVkRG9jc1tpXSk7XG4gICAgfVxuXG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn07XG5cbkRhdGFzdG9yZS5wcm90b3R5cGUuaW5zZXJ0ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmV4ZWN1dG9yLnB1c2goeyB0aGlzOiB0aGlzLCBmbjogdGhpcy5faW5zZXJ0LCBhcmd1bWVudHM6IGFyZ3VtZW50cyB9KTtcbn07XG5cblxuLyoqXG4gKiBDb3VudCBhbGwgZG9jdW1lbnRzIG1hdGNoaW5nIHRoZSBxdWVyeVxuICogQHBhcmFtIHtPYmplY3R9IHF1ZXJ5IE1vbmdvREItc3R5bGUgcXVlcnlcbiAqL1xuRGF0YXN0b3JlLnByb3RvdHlwZS5jb3VudCA9IGZ1bmN0aW9uKHF1ZXJ5LCBjYWxsYmFjaykge1xuICB2YXIgY3Vyc29yID0gbmV3IEN1cnNvcih0aGlzLCBxdWVyeSwgZnVuY3Rpb24oZXJyLCBkb2NzLCBjYWxsYmFjaykge1xuICAgIGlmIChlcnIpIHsgcmV0dXJuIGNhbGxiYWNrKGVycik7IH1cbiAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgZG9jcy5sZW5ndGgpO1xuICB9KTtcblxuICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY3Vyc29yLmV4ZWMoY2FsbGJhY2spO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBjdXJzb3I7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBGaW5kIGFsbCBkb2N1bWVudHMgbWF0Y2hpbmcgdGhlIHF1ZXJ5XG4gKiBJZiBubyBjYWxsYmFjayBpcyBwYXNzZWQsIHdlIHJldHVybiB0aGUgY3Vyc29yIHNvIHRoYXQgdXNlciBjYW4gbGltaXQsIHNraXAgYW5kIGZpbmFsbHkgZXhlY1xuICogQHBhcmFtIHtPYmplY3R9IHF1ZXJ5IE1vbmdvREItc3R5bGUgcXVlcnlcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9qZWN0aW9uIE1vbmdvREItc3R5bGUgcHJvamVjdGlvblxuICovXG5EYXRhc3RvcmUucHJvdG90eXBlLmZpbmQgPSBmdW5jdGlvbiAocXVlcnksIHByb2plY3Rpb24sIGNhbGxiYWNrKSB7XG4gIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIGNhc2UgMTpcbiAgICAgIHByb2plY3Rpb24gPSB7fTtcbiAgICAgIC8vIGNhbGxiYWNrIGlzIHVuZGVmaW5lZCwgd2lsbCByZXR1cm4gYSBjdXJzb3JcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMjpcbiAgICAgIGlmICh0eXBlb2YgcHJvamVjdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjYWxsYmFjayA9IHByb2plY3Rpb247XG4gICAgICAgIHByb2plY3Rpb24gPSB7fTtcbiAgICAgIH0gICAvLyBJZiBub3QgYXNzdW1lIHByb2plY3Rpb24gaXMgYW4gb2JqZWN0IGFuZCBjYWxsYmFjayB1bmRlZmluZWRcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgdmFyIGN1cnNvciA9IG5ldyBDdXJzb3IodGhpcywgcXVlcnksIGZ1bmN0aW9uKGVyciwgZG9jcywgY2FsbGJhY2spIHtcbiAgICB2YXIgcmVzID0gW10sIGk7XG5cbiAgICBpZiAoZXJyKSB7IHJldHVybiBjYWxsYmFjayhlcnIpOyB9XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgZG9jcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgcmVzLnB1c2gobW9kZWwuZGVlcENvcHkoZG9jc1tpXSkpO1xuICAgIH1cbiAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgcmVzKTtcbiAgfSk7XG5cbiAgY3Vyc29yLnByb2plY3Rpb24ocHJvamVjdGlvbik7XG4gIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjdXJzb3IuZXhlYyhjYWxsYmFjayk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGN1cnNvcjtcbiAgfVxufTtcblxuXG4vKipcbiAqIEZpbmQgb25lIGRvY3VtZW50IG1hdGNoaW5nIHRoZSBxdWVyeVxuICogQHBhcmFtIHtPYmplY3R9IHF1ZXJ5IE1vbmdvREItc3R5bGUgcXVlcnlcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9qZWN0aW9uIE1vbmdvREItc3R5bGUgcHJvamVjdGlvblxuICovXG5EYXRhc3RvcmUucHJvdG90eXBlLmZpbmRPbmUgPSBmdW5jdGlvbiAocXVlcnksIHByb2plY3Rpb24sIGNhbGxiYWNrKSB7XG4gIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIGNhc2UgMTpcbiAgICAgIHByb2plY3Rpb24gPSB7fTtcbiAgICAgIC8vIGNhbGxiYWNrIGlzIHVuZGVmaW5lZCwgd2lsbCByZXR1cm4gYSBjdXJzb3JcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMjpcbiAgICAgIGlmICh0eXBlb2YgcHJvamVjdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjYWxsYmFjayA9IHByb2plY3Rpb247XG4gICAgICAgIHByb2plY3Rpb24gPSB7fTtcbiAgICAgIH0gICAvLyBJZiBub3QgYXNzdW1lIHByb2plY3Rpb24gaXMgYW4gb2JqZWN0IGFuZCBjYWxsYmFjayB1bmRlZmluZWRcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgdmFyIGN1cnNvciA9IG5ldyBDdXJzb3IodGhpcywgcXVlcnksIGZ1bmN0aW9uKGVyciwgZG9jcywgY2FsbGJhY2spIHtcbiAgICBpZiAoZXJyKSB7IHJldHVybiBjYWxsYmFjayhlcnIpOyB9XG4gICAgaWYgKGRvY3MubGVuZ3RoID09PSAxKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgbW9kZWwuZGVlcENvcHkoZG9jc1swXSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgbnVsbCk7XG4gICAgfVxuICB9KTtcblxuICBjdXJzb3IucHJvamVjdGlvbihwcm9qZWN0aW9uKS5saW1pdCgxKTtcbiAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGN1cnNvci5leGVjKGNhbGxiYWNrKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY3Vyc29yO1xuICB9XG59O1xuXG5cbi8qKlxuICogVXBkYXRlIGFsbCBkb2NzIG1hdGNoaW5nIHF1ZXJ5XG4gKiBAcGFyYW0ge09iamVjdH0gcXVlcnlcbiAqIEBwYXJhbSB7T2JqZWN0fSB1cGRhdGVRdWVyeVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgT3B0aW9uYWwgb3B0aW9uc1xuICogICAgICAgICAgICAgICAgIG9wdGlvbnMubXVsdGkgSWYgdHJ1ZSwgY2FuIHVwZGF0ZSBtdWx0aXBsZSBkb2N1bWVudHMgKGRlZmF1bHRzIHRvIGZhbHNlKVxuICogICAgICAgICAgICAgICAgIG9wdGlvbnMudXBzZXJ0IElmIHRydWUsIGRvY3VtZW50IGlzIGluc2VydGVkIGlmIHRoZSBxdWVyeSBkb2Vzbid0IG1hdGNoIGFueXRoaW5nXG4gKiAgICAgICAgICAgICAgICAgb3B0aW9ucy5yZXR1cm5VcGRhdGVkRG9jcyBEZWZhdWx0cyB0byBmYWxzZSwgaWYgdHJ1ZSByZXR1cm4gYXMgdGhpcmQgYXJndW1lbnQgdGhlIGFycmF5IG9mIHVwZGF0ZWQgbWF0Y2hlZCBkb2N1bWVudHMgKGV2ZW4gaWYgbm8gY2hhbmdlIGFjdHVhbGx5IHRvb2sgcGxhY2UpXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBPcHRpb25hbCBjYWxsYmFjaywgc2lnbmF0dXJlOiAoZXJyLCBudW1BZmZlY3RlZCwgYWZmZWN0ZWREb2N1bWVudHMsIHVwc2VydClcbiAqICAgICAgICAgICAgICAgICAgICAgIElmIHVwZGF0ZSB3YXMgYW4gdXBzZXJ0LCB1cHNlcnQgZmxhZyBpcyBzZXQgdG8gdHJ1ZVxuICogICAgICAgICAgICAgICAgICAgICAgYWZmZWN0ZWREb2N1bWVudHMgY2FuIGJlIG9uZSBvZiB0aGUgZm9sbG93aW5nOlxuICogICAgICAgICAgICAgICAgICAgICAgICAqIEZvciBhbiB1cHNlcnQsIHRoZSB1cHNlcnRlZCBkb2N1bWVudFxuICogICAgICAgICAgICAgICAgICAgICAgICAqIEZvciBhbiB1cGRhdGUgd2l0aCByZXR1cm5VcGRhdGVkRG9jcyBvcHRpb24gZmFsc2UsIG51bGxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgKiBGb3IgYW4gdXBkYXRlIHdpdGggcmV0dXJuVXBkYXRlZERvY3MgdHJ1ZSBhbmQgbXVsdGkgZmFsc2UsIHRoZSB1cGRhdGVkIGRvY3VtZW50XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICogRm9yIGFuIHVwZGF0ZSB3aXRoIHJldHVyblVwZGF0ZWREb2NzIHRydWUgYW5kIG11bHRpIHRydWUsIHRoZSBhcnJheSBvZiB1cGRhdGVkIGRvY3VtZW50c1xuICpcbiAqIFdBUk5JTkc6IFRoZSBBUEkgd2FzIGNoYW5nZWQgYmV0d2VlbiB2MS43LjQgYW5kIHYxLjgsIGZvciBjb25zaXN0ZW5jeSBhbmQgcmVhZGFiaWxpdHkgcmVhc29ucy4gUHJpb3IgYW5kIGluY2x1ZGluZyB0byB2MS43LjQsXG4gKiAgICAgICAgICB0aGUgY2FsbGJhY2sgc2lnbmF0dXJlIHdhcyAoZXJyLCBudW1BZmZlY3RlZCwgdXBkYXRlZCkgd2hlcmUgdXBkYXRlZCB3YXMgdGhlIHVwZGF0ZWQgZG9jdW1lbnQgaW4gY2FzZSBvZiBhbiB1cHNlcnRcbiAqICAgICAgICAgIG9yIHRoZSBhcnJheSBvZiB1cGRhdGVkIGRvY3VtZW50cyBmb3IgYW4gdXBkYXRlIGlmIHRoZSByZXR1cm5VcGRhdGVkRG9jcyBvcHRpb24gd2FzIHRydWUuIFRoYXQgbWVhbnQgdGhhdCB0aGUgdHlwZSBvZlxuICogICAgICAgICAgYWZmZWN0ZWREb2N1bWVudHMgaW4gYSBub24gbXVsdGkgdXBkYXRlIGRlcGVuZGVkIG9uIHdoZXRoZXIgdGhlcmUgd2FzIGFuIHVwc2VydCBvciBub3QsIGxlYXZpbmcgb25seSB0d28gd2F5cyBmb3IgdGhlXG4gKiAgICAgICAgICB1c2VyIHRvIGNoZWNrIHdoZXRoZXIgYW4gdXBzZXJ0IGhhZCBvY2N1cmVkOiBjaGVja2luZyB0aGUgdHlwZSBvZiBhZmZlY3RlZERvY3VtZW50cyBvciBydW5uaW5nIGFub3RoZXIgZmluZCBxdWVyeSBvblxuICogICAgICAgICAgdGhlIHdob2xlIGRhdGFzZXQgdG8gY2hlY2sgaXRzIHNpemUuIEJvdGggb3B0aW9ucyBiZWluZyB1Z2x5LCB0aGUgYnJlYWtpbmcgY2hhbmdlIHdhcyBuZWNlc3NhcnkuXG4gKlxuICogQGFwaSBwcml2YXRlIFVzZSBEYXRhc3RvcmUudXBkYXRlIHdoaWNoIGhhcyB0aGUgc2FtZSBzaWduYXR1cmVcbiAqL1xuRGF0YXN0b3JlLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKHF1ZXJ5LCB1cGRhdGVRdWVyeSwgb3B0aW9ucywgY2IpIHtcbiAgdmFyIGNhbGxiYWNrXG4gICAgLCBzZWxmID0gdGhpc1xuICAgICwgbnVtUmVwbGFjZWQgPSAwXG4gICAgLCBtdWx0aSwgdXBzZXJ0XG4gICAgLCBpXG4gICAgO1xuXG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykgeyBjYiA9IG9wdGlvbnM7IG9wdGlvbnMgPSB7fTsgfVxuICBjYWxsYmFjayA9IGNiIHx8IGZ1bmN0aW9uICgpIHt9O1xuICBtdWx0aSA9IG9wdGlvbnMubXVsdGkgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubXVsdGkgOiBmYWxzZTtcbiAgdXBzZXJ0ID0gb3B0aW9ucy51cHNlcnQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMudXBzZXJ0IDogZmFsc2U7XG5cbiAgYXN5bmMud2F0ZXJmYWxsKFtcbiAgZnVuY3Rpb24gKGNiKSB7ICAgLy8gSWYgdXBzZXJ0IG9wdGlvbiBpcyBzZXQsIGNoZWNrIHdoZXRoZXIgd2UgbmVlZCB0byBpbnNlcnQgdGhlIGRvY1xuICAgIGlmICghdXBzZXJ0KSB7IHJldHVybiBjYigpOyB9XG5cbiAgICAvLyBOZWVkIHRvIHVzZSBhbiBpbnRlcm5hbCBmdW5jdGlvbiBub3QgdGllZCB0byB0aGUgZXhlY3V0b3IgdG8gYXZvaWQgZGVhZGxvY2tcbiAgICB2YXIgY3Vyc29yID0gbmV3IEN1cnNvcihzZWxmLCBxdWVyeSk7XG4gICAgY3Vyc29yLmxpbWl0KDEpLl9leGVjKGZ1bmN0aW9uIChlcnIsIGRvY3MpIHtcbiAgICAgIGlmIChlcnIpIHsgcmV0dXJuIGNhbGxiYWNrKGVycik7IH1cbiAgICAgIGlmIChkb2NzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gY2IoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB0b0JlSW5zZXJ0ZWQ7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBtb2RlbC5jaGVja09iamVjdCh1cGRhdGVRdWVyeSk7XG4gICAgICAgICAgLy8gdXBkYXRlUXVlcnkgaXMgYSBzaW1wbGUgb2JqZWN0IHdpdGggbm8gbW9kaWZpZXIsIHVzZSBpdCBhcyB0aGUgZG9jdW1lbnQgdG8gaW5zZXJ0XG4gICAgICAgICAgdG9CZUluc2VydGVkID0gdXBkYXRlUXVlcnk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAvLyB1cGRhdGVRdWVyeSBjb250YWlucyBtb2RpZmllcnMsIHVzZSB0aGUgZmluZCBxdWVyeSBhcyB0aGUgYmFzZSxcbiAgICAgICAgICAvLyBzdHJpcCBpdCBmcm9tIGFsbCBvcGVyYXRvcnMgYW5kIHVwZGF0ZSBpdCBhY2NvcmRpbmcgdG8gdXBkYXRlUXVlcnlcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdG9CZUluc2VydGVkID0gbW9kZWwubW9kaWZ5KG1vZGVsLmRlZXBDb3B5KHF1ZXJ5LCB0cnVlKSwgdXBkYXRlUXVlcnkpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNlbGYuX2luc2VydCh0b0JlSW5zZXJ0ZWQsIGZ1bmN0aW9uIChlcnIsIG5ld0RvYykge1xuICAgICAgICAgIGlmIChlcnIpIHsgcmV0dXJuIGNhbGxiYWNrKGVycik7IH1cbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgMSwgbmV3RG9jLCB0cnVlKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgLCBmdW5jdGlvbiAoKSB7ICAgLy8gUGVyZm9ybSB0aGUgdXBkYXRlXG4gICAgdmFyIG1vZGlmaWVkRG9jICwgbW9kaWZpY2F0aW9ucyA9IFtdLCBjcmVhdGVkQXQ7XG5cbiAgICBzZWxmLmdldENhbmRpZGF0ZXMocXVlcnksIGZ1bmN0aW9uIChlcnIsIGNhbmRpZGF0ZXMpIHtcbiAgICAgIGlmIChlcnIpIHsgcmV0dXJuIGNhbGxiYWNrKGVycik7IH1cblxuICAgICAgLy8gUHJlcGFyaW5nIHVwZGF0ZSAoaWYgYW4gZXJyb3IgaXMgdGhyb3duIGhlcmUgbmVpdGhlciB0aGUgZGF0YWZpbGUgbm9yXG4gICAgICAvLyB0aGUgaW4tbWVtb3J5IGluZGV4ZXMgYXJlIGFmZmVjdGVkKVxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNhbmRpZGF0ZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICBpZiAobW9kZWwubWF0Y2goY2FuZGlkYXRlc1tpXSwgcXVlcnkpICYmIChtdWx0aSB8fCBudW1SZXBsYWNlZCA9PT0gMCkpIHtcbiAgICAgICAgICAgIG51bVJlcGxhY2VkICs9IDE7XG4gICAgICAgICAgICBpZiAoc2VsZi50aW1lc3RhbXBEYXRhKSB7IGNyZWF0ZWRBdCA9IGNhbmRpZGF0ZXNbaV0uY3JlYXRlZEF0OyB9XG4gICAgICAgICAgICBtb2RpZmllZERvYyA9IG1vZGVsLm1vZGlmeShjYW5kaWRhdGVzW2ldLCB1cGRhdGVRdWVyeSk7XG4gICAgICAgICAgICBpZiAoc2VsZi50aW1lc3RhbXBEYXRhKSB7XG4gICAgICAgICAgICAgIG1vZGlmaWVkRG9jLmNyZWF0ZWRBdCA9IGNyZWF0ZWRBdDtcbiAgICAgICAgICAgICAgbW9kaWZpZWREb2MudXBkYXRlZEF0ID0gbmV3IERhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1vZGlmaWNhdGlvbnMucHVzaCh7IG9sZERvYzogY2FuZGlkYXRlc1tpXSwgbmV3RG9jOiBtb2RpZmllZERvYyB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2hhbmdlIHRoZSBkb2NzIGluIG1lbW9yeVxuICAgICAgdHJ5IHtcbiAgICAgICAgc2VsZi51cGRhdGVJbmRleGVzKG1vZGlmaWNhdGlvbnMpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgfVxuXG4gICAgICAvLyBVcGRhdGUgdGhlIGRhdGFmaWxlXG4gICAgICB2YXIgdXBkYXRlZERvY3MgPSBfLnBsdWNrKG1vZGlmaWNhdGlvbnMsICduZXdEb2MnKTtcbiAgICAgIHNlbGYucGVyc2lzdGVuY2UucGVyc2lzdE5ld1N0YXRlKHVwZGF0ZWREb2NzLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIGlmIChlcnIpIHsgcmV0dXJuIGNhbGxiYWNrKGVycik7IH1cbiAgICAgICAgaWYgKCFvcHRpb25zLnJldHVyblVwZGF0ZWREb2NzKSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIG51bVJlcGxhY2VkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgdXBkYXRlZERvY3NEQyA9IFtdO1xuICAgICAgICAgIHVwZGF0ZWREb2NzLmZvckVhY2goZnVuY3Rpb24gKGRvYykgeyB1cGRhdGVkRG9jc0RDLnB1c2gobW9kZWwuZGVlcENvcHkoZG9jKSk7IH0pO1xuICAgICAgICAgIGlmICghIG11bHRpKSB7IHVwZGF0ZWREb2NzREMgPSB1cGRhdGVkRG9jc0RDWzBdOyB9XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIG51bVJlcGxhY2VkLCB1cGRhdGVkRG9jc0RDKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1dKTtcbn07XG5cbkRhdGFzdG9yZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmV4ZWN1dG9yLnB1c2goeyB0aGlzOiB0aGlzLCBmbjogdGhpcy5fdXBkYXRlLCBhcmd1bWVudHM6IGFyZ3VtZW50cyB9KTtcbn07XG5cblxuLyoqXG4gKiBSZW1vdmUgYWxsIGRvY3MgbWF0Y2hpbmcgdGhlIHF1ZXJ5XG4gKiBGb3Igbm93IHZlcnkgbmFpdmUgaW1wbGVtZW50YXRpb24gKHNpbWlsYXIgdG8gdXBkYXRlKVxuICogQHBhcmFtIHtPYmplY3R9IHF1ZXJ5XG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBPcHRpb25hbCBvcHRpb25zXG4gKiAgICAgICAgICAgICAgICAgb3B0aW9ucy5tdWx0aSBJZiB0cnVlLCBjYW4gdXBkYXRlIG11bHRpcGxlIGRvY3VtZW50cyAoZGVmYXVsdHMgdG8gZmFsc2UpXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBPcHRpb25hbCBjYWxsYmFjaywgc2lnbmF0dXJlOiBlcnIsIG51bVJlbW92ZWRcbiAqXG4gKiBAYXBpIHByaXZhdGUgVXNlIERhdGFzdG9yZS5yZW1vdmUgd2hpY2ggaGFzIHRoZSBzYW1lIHNpZ25hdHVyZVxuICovXG5EYXRhc3RvcmUucHJvdG90eXBlLl9yZW1vdmUgPSBmdW5jdGlvbiAocXVlcnksIG9wdGlvbnMsIGNiKSB7XG4gIHZhciBjYWxsYmFja1xuICAgICwgc2VsZiA9IHRoaXMsIG51bVJlbW92ZWQgPSAwLCByZW1vdmVkRG9jcyA9IFtdLCBtdWx0aVxuICAgIDtcblxuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHsgY2IgPSBvcHRpb25zOyBvcHRpb25zID0ge307IH1cbiAgY2FsbGJhY2sgPSBjYiB8fCBmdW5jdGlvbiAoKSB7fTtcbiAgbXVsdGkgPSBvcHRpb25zLm11bHRpICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm11bHRpIDogZmFsc2U7XG5cbiAgdGhpcy5nZXRDYW5kaWRhdGVzKHF1ZXJ5LCB0cnVlLCBmdW5jdGlvbiAoZXJyLCBjYW5kaWRhdGVzKSB7XG4gICAgaWYgKGVycikgeyByZXR1cm4gY2FsbGJhY2soZXJyKTsgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGNhbmRpZGF0ZXMuZm9yRWFjaChmdW5jdGlvbiAoZCkge1xuICAgICAgICBpZiAobW9kZWwubWF0Y2goZCwgcXVlcnkpICYmIChtdWx0aSB8fCBudW1SZW1vdmVkID09PSAwKSkge1xuICAgICAgICAgIG51bVJlbW92ZWQgKz0gMTtcbiAgICAgICAgICByZW1vdmVkRG9jcy5wdXNoKHsgJCRkZWxldGVkOiB0cnVlLCBfaWQ6IGQuX2lkIH0pO1xuICAgICAgICAgIHNlbGYucmVtb3ZlRnJvbUluZGV4ZXMoZCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycikgeyByZXR1cm4gY2FsbGJhY2soZXJyKTsgfVxuXG4gICAgc2VsZi5wZXJzaXN0ZW5jZS5wZXJzaXN0TmV3U3RhdGUocmVtb3ZlZERvY3MsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgIGlmIChlcnIpIHsgcmV0dXJuIGNhbGxiYWNrKGVycik7IH1cbiAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBudW1SZW1vdmVkKTtcbiAgICB9KTtcbiAgfSk7XG59O1xuXG5EYXRhc3RvcmUucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5leGVjdXRvci5wdXNoKHsgdGhpczogdGhpcywgZm46IHRoaXMuX3JlbW92ZSwgYXJndW1lbnRzOiBhcmd1bWVudHMgfSk7XG59O1xuXG5cblxubW9kdWxlLmV4cG9ydHMgPSBEYXRhc3RvcmU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9uZWRiL2xpYi9kYXRhc3RvcmUuanNcbi8vIG1vZHVsZSBpZCA9IDIzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///23\n");

/***/ }),
/* 24 */
/*!*************************!*\
  !*** external "crypto" ***!
  \*************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports) {

eval("module.exports = require(\"crypto\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJjcnlwdG9cIj9lZjQ5Il0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImNyeXB0b1wiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcImNyeXB0b1wiXG4vLyBtb2R1bGUgaWQgPSAyNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///24\n");

/***/ }),
/* 25 */
/*!*******************************************!*\
  !*** ./node_modules/nedb/lib/executor.js ***!
  \*******************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * Responsible for sequentially executing actions on the database\n */\n\nvar async = __webpack_require__(/*! async */ 6)\n  ;\n\nfunction Executor () {\n  this.buffer = [];\n  this.ready = false;\n\n  // This queue will execute all commands, one-by-one in order\n  this.queue = async.queue(function (task, cb) {\n    var newArguments = [];\n\n    // task.arguments is an array-like object on which adding a new field doesn't work, so we transform it into a real array\n    for (var i = 0; i < task.arguments.length; i += 1) { newArguments.push(task.arguments[i]); }\n    var lastArg = task.arguments[task.arguments.length - 1];\n\n    // Always tell the queue task is complete. Execute callback if any was given.\n    if (typeof lastArg === 'function') {\n      // Callback was supplied\n      newArguments[newArguments.length - 1] = function () {\n        if (typeof setImmediate === 'function') {\n           setImmediate(cb);\n        } else {\n          process.nextTick(cb);\n        }\n        lastArg.apply(null, arguments);\n      };\n    } else if (!lastArg && task.arguments.length !== 0) {\n      // false/undefined/null supplied as callbback\n      newArguments[newArguments.length - 1] = function () { cb(); };\n    } else {\n      // Nothing supplied as callback\n      newArguments.push(function () { cb(); });\n    }\n\n\n    task.fn.apply(task.this, newArguments);\n  }, 1);\n}\n\n\n/**\n * If executor is ready, queue task (and process it immediately if executor was idle)\n * If not, buffer task for later processing\n * @param {Object} task\n *                 task.this - Object to use as this\n *                 task.fn - Function to execute\n *                 task.arguments - Array of arguments, IMPORTANT: only the last argument may be a function (the callback)\n *                                                                 and the last argument cannot be false/undefined/null\n * @param {Boolean} forceQueuing Optional (defaults to false) force executor to queue task even if it is not ready\n */\nExecutor.prototype.push = function (task, forceQueuing) {\n  if (this.ready || forceQueuing) {\n    this.queue.push(task);\n  } else {\n    this.buffer.push(task);\n  }\n};\n\n\n/**\n * Queue all tasks in buffer (in the same order they came in)\n * Automatically sets executor as ready\n */\nExecutor.prototype.processBuffer = function () {\n  var i;\n  this.ready = true;\n  for (i = 0; i < this.buffer.length; i += 1) { this.queue.push(this.buffer[i]); }\n  this.buffer = [];\n};\n\n\n\n// Interface\nmodule.exports = Executor;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbmVkYi9saWIvZXhlY3V0b3IuanM/MjkwZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFJlc3BvbnNpYmxlIGZvciBzZXF1ZW50aWFsbHkgZXhlY3V0aW5nIGFjdGlvbnMgb24gdGhlIGRhdGFiYXNlXG4gKi9cblxudmFyIGFzeW5jID0gcmVxdWlyZSgnYXN5bmMnKVxuICA7XG5cbmZ1bmN0aW9uIEV4ZWN1dG9yICgpIHtcbiAgdGhpcy5idWZmZXIgPSBbXTtcbiAgdGhpcy5yZWFkeSA9IGZhbHNlO1xuXG4gIC8vIFRoaXMgcXVldWUgd2lsbCBleGVjdXRlIGFsbCBjb21tYW5kcywgb25lLWJ5LW9uZSBpbiBvcmRlclxuICB0aGlzLnF1ZXVlID0gYXN5bmMucXVldWUoZnVuY3Rpb24gKHRhc2ssIGNiKSB7XG4gICAgdmFyIG5ld0FyZ3VtZW50cyA9IFtdO1xuXG4gICAgLy8gdGFzay5hcmd1bWVudHMgaXMgYW4gYXJyYXktbGlrZSBvYmplY3Qgb24gd2hpY2ggYWRkaW5nIGEgbmV3IGZpZWxkIGRvZXNuJ3Qgd29yaywgc28gd2UgdHJhbnNmb3JtIGl0IGludG8gYSByZWFsIGFycmF5XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0YXNrLmFyZ3VtZW50cy5sZW5ndGg7IGkgKz0gMSkgeyBuZXdBcmd1bWVudHMucHVzaCh0YXNrLmFyZ3VtZW50c1tpXSk7IH1cbiAgICB2YXIgbGFzdEFyZyA9IHRhc2suYXJndW1lbnRzW3Rhc2suYXJndW1lbnRzLmxlbmd0aCAtIDFdO1xuXG4gICAgLy8gQWx3YXlzIHRlbGwgdGhlIHF1ZXVlIHRhc2sgaXMgY29tcGxldGUuIEV4ZWN1dGUgY2FsbGJhY2sgaWYgYW55IHdhcyBnaXZlbi5cbiAgICBpZiAodHlwZW9mIGxhc3RBcmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIENhbGxiYWNrIHdhcyBzdXBwbGllZFxuICAgICAgbmV3QXJndW1lbnRzW25ld0FyZ3VtZW50cy5sZW5ndGggLSAxXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRJbW1lZGlhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgc2V0SW1tZWRpYXRlKGNiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGNiKTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0QXJnLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoIWxhc3RBcmcgJiYgdGFzay5hcmd1bWVudHMubGVuZ3RoICE9PSAwKSB7XG4gICAgICAvLyBmYWxzZS91bmRlZmluZWQvbnVsbCBzdXBwbGllZCBhcyBjYWxsYmJhY2tcbiAgICAgIG5ld0FyZ3VtZW50c1tuZXdBcmd1bWVudHMubGVuZ3RoIC0gMV0gPSBmdW5jdGlvbiAoKSB7IGNiKCk7IH07XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE5vdGhpbmcgc3VwcGxpZWQgYXMgY2FsbGJhY2tcbiAgICAgIG5ld0FyZ3VtZW50cy5wdXNoKGZ1bmN0aW9uICgpIHsgY2IoKTsgfSk7XG4gICAgfVxuXG5cbiAgICB0YXNrLmZuLmFwcGx5KHRhc2sudGhpcywgbmV3QXJndW1lbnRzKTtcbiAgfSwgMSk7XG59XG5cblxuLyoqXG4gKiBJZiBleGVjdXRvciBpcyByZWFkeSwgcXVldWUgdGFzayAoYW5kIHByb2Nlc3MgaXQgaW1tZWRpYXRlbHkgaWYgZXhlY3V0b3Igd2FzIGlkbGUpXG4gKiBJZiBub3QsIGJ1ZmZlciB0YXNrIGZvciBsYXRlciBwcm9jZXNzaW5nXG4gKiBAcGFyYW0ge09iamVjdH0gdGFza1xuICogICAgICAgICAgICAgICAgIHRhc2sudGhpcyAtIE9iamVjdCB0byB1c2UgYXMgdGhpc1xuICogICAgICAgICAgICAgICAgIHRhc2suZm4gLSBGdW5jdGlvbiB0byBleGVjdXRlXG4gKiAgICAgICAgICAgICAgICAgdGFzay5hcmd1bWVudHMgLSBBcnJheSBvZiBhcmd1bWVudHMsIElNUE9SVEFOVDogb25seSB0aGUgbGFzdCBhcmd1bWVudCBtYXkgYmUgYSBmdW5jdGlvbiAodGhlIGNhbGxiYWNrKVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuZCB0aGUgbGFzdCBhcmd1bWVudCBjYW5ub3QgYmUgZmFsc2UvdW5kZWZpbmVkL251bGxcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gZm9yY2VRdWV1aW5nIE9wdGlvbmFsIChkZWZhdWx0cyB0byBmYWxzZSkgZm9yY2UgZXhlY3V0b3IgdG8gcXVldWUgdGFzayBldmVuIGlmIGl0IGlzIG5vdCByZWFkeVxuICovXG5FeGVjdXRvci5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uICh0YXNrLCBmb3JjZVF1ZXVpbmcpIHtcbiAgaWYgKHRoaXMucmVhZHkgfHwgZm9yY2VRdWV1aW5nKSB7XG4gICAgdGhpcy5xdWV1ZS5wdXNoKHRhc2spO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuYnVmZmVyLnB1c2godGFzayk7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBRdWV1ZSBhbGwgdGFza3MgaW4gYnVmZmVyIChpbiB0aGUgc2FtZSBvcmRlciB0aGV5IGNhbWUgaW4pXG4gKiBBdXRvbWF0aWNhbGx5IHNldHMgZXhlY3V0b3IgYXMgcmVhZHlcbiAqL1xuRXhlY3V0b3IucHJvdG90eXBlLnByb2Nlc3NCdWZmZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBpO1xuICB0aGlzLnJlYWR5ID0gdHJ1ZTtcbiAgZm9yIChpID0gMDsgaSA8IHRoaXMuYnVmZmVyLmxlbmd0aDsgaSArPSAxKSB7IHRoaXMucXVldWUucHVzaCh0aGlzLmJ1ZmZlcltpXSk7IH1cbiAgdGhpcy5idWZmZXIgPSBbXTtcbn07XG5cblxuXG4vLyBJbnRlcmZhY2Vcbm1vZHVsZS5leHBvcnRzID0gRXhlY3V0b3I7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9uZWRiL2xpYi9leGVjdXRvci5qc1xuLy8gbW9kdWxlIGlkID0gMjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///25\n");

/***/ }),
/* 26 */
/*!**************************************************!*\
  !*** ./node_modules/binary-search-tree/index.js ***!
  \**************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports.BinarySearchTree = __webpack_require__(/*! ./lib/bst */ 9);\nmodule.exports.AVLTree = __webpack_require__(/*! ./lib/avltree */ 27);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmluYXJ5LXNlYXJjaC10cmVlL2luZGV4LmpzPzg3ZTMiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMuQmluYXJ5U2VhcmNoVHJlZSA9IHJlcXVpcmUoJy4vbGliL2JzdCcpO1xubW9kdWxlLmV4cG9ydHMuQVZMVHJlZSA9IHJlcXVpcmUoJy4vbGliL2F2bHRyZWUnKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2JpbmFyeS1zZWFyY2gtdHJlZS9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///26\n");

/***/ }),
/* 27 */
/*!********************************************************!*\
  !*** ./node_modules/binary-search-tree/lib/avltree.js ***!
  \********************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * Self-balancing binary search tree using the AVL implementation\n */\nvar BinarySearchTree = __webpack_require__(/*! ./bst */ 9)\n  , customUtils = __webpack_require__(/*! ./customUtils */ 10)\n  , util = __webpack_require__(/*! util */ 5)\n  , _ = __webpack_require__(/*! underscore */ 1)\n  ;\n\n\n/**\n * Constructor\n * We can't use a direct pointer to the root node (as in the simple binary search tree)\n * as the root will change during tree rotations\n * @param {Boolean}  options.unique Whether to enforce a 'unique' constraint on the key or not\n * @param {Function} options.compareKeys Initialize this BST's compareKeys\n */\nfunction AVLTree (options) {\n  this.tree = new _AVLTree(options);\n}\n\n\n/**\n * Constructor of the internal AVLTree\n * @param {Object} options Optional\n * @param {Boolean}  options.unique Whether to enforce a 'unique' constraint on the key or not\n * @param {Key}      options.key Initialize this BST's key with key\n * @param {Value}    options.value Initialize this BST's data with [value]\n * @param {Function} options.compareKeys Initialize this BST's compareKeys\n */\nfunction _AVLTree (options) {\n  options = options || {};\n\n  this.left = null;\n  this.right = null;\n  this.parent = options.parent !== undefined ? options.parent : null;\n  if (options.hasOwnProperty('key')) { this.key = options.key; }\n  this.data = options.hasOwnProperty('value') ? [options.value] : [];\n  this.unique = options.unique || false;\n\n  this.compareKeys = options.compareKeys || customUtils.defaultCompareKeysFunction;\n  this.checkValueEquality = options.checkValueEquality || customUtils.defaultCheckValueEquality;\n}\n\n\n/**\n * Inherit basic functions from the basic binary search tree\n */\nutil.inherits(_AVLTree, BinarySearchTree);\n\n/**\n * Keep a pointer to the internal tree constructor for testing purposes\n */\nAVLTree._AVLTree = _AVLTree;\n\n\n/**\n * Check the recorded height is correct for every node\n * Throws if one height doesn't match\n */\n_AVLTree.prototype.checkHeightCorrect = function () {\n  var leftH, rightH;\n\n  if (!this.hasOwnProperty('key')) { return; }   // Empty tree\n\n  if (this.left && this.left.height === undefined) { throw new Error(\"Undefined height for node \" + this.left.key); }\n  if (this.right && this.right.height === undefined) { throw new Error(\"Undefined height for node \" + this.right.key); }\n  if (this.height === undefined) { throw new Error(\"Undefined height for node \" + this.key); }\n\n  leftH = this.left ? this.left.height : 0;\n  rightH = this.right ? this.right.height : 0;\n\n  if (this.height !== 1 + Math.max(leftH, rightH)) { throw new Error(\"Height constraint failed for node \" + this.key); }\n  if (this.left) { this.left.checkHeightCorrect(); }\n  if (this.right) { this.right.checkHeightCorrect(); }\n};\n\n\n/**\n * Return the balance factor\n */\n_AVLTree.prototype.balanceFactor = function () {\n  var leftH = this.left ? this.left.height : 0\n    , rightH = this.right ? this.right.height : 0\n    ;\n  return leftH - rightH;\n};\n\n\n/**\n * Check that the balance factors are all between -1 and 1\n */\n_AVLTree.prototype.checkBalanceFactors = function () {\n  if (Math.abs(this.balanceFactor()) > 1) { throw new Error('Tree is unbalanced at node ' + this.key); }\n\n  if (this.left) { this.left.checkBalanceFactors(); }\n  if (this.right) { this.right.checkBalanceFactors(); }\n};\n\n\n/**\n * When checking if the BST conditions are met, also check that the heights are correct\n * and the tree is balanced\n */\n_AVLTree.prototype.checkIsAVLT = function () {\n  _AVLTree.super_.prototype.checkIsBST.call(this);\n  this.checkHeightCorrect();\n  this.checkBalanceFactors();\n};\nAVLTree.prototype.checkIsAVLT = function () { this.tree.checkIsAVLT(); };\n\n\n/**\n * Perform a right rotation of the tree if possible\n * and return the root of the resulting tree\n * The resulting tree's nodes' heights are also updated\n */\n_AVLTree.prototype.rightRotation = function () {\n  var q = this\n    , p = this.left\n    , b\n    , ah, bh, ch;\n\n  if (!p) { return this; }   // No change\n\n  b = p.right;\n\n  // Alter tree structure\n  if (q.parent) {\n    p.parent = q.parent;\n    if (q.parent.left === q) { q.parent.left = p; } else { q.parent.right = p; }\n  } else {\n    p.parent = null;\n  }\n  p.right = q;\n  q.parent = p;\n  q.left = b;\n  if (b) { b.parent = q; }\n\n  // Update heights\n  ah = p.left ? p.left.height : 0;\n  bh = b ? b.height : 0;\n  ch = q.right ? q.right.height : 0;\n  q.height = Math.max(bh, ch) + 1;\n  p.height = Math.max(ah, q.height) + 1;\n\n  return p;\n};\n\n\n/**\n * Perform a left rotation of the tree if possible\n * and return the root of the resulting tree\n * The resulting tree's nodes' heights are also updated\n */\n_AVLTree.prototype.leftRotation = function () {\n  var p = this\n    , q = this.right\n    , b\n    , ah, bh, ch;\n\n  if (!q) { return this; }   // No change\n\n  b = q.left;\n\n  // Alter tree structure\n  if (p.parent) {\n    q.parent = p.parent;\n    if (p.parent.left === p) { p.parent.left = q; } else { p.parent.right = q; }\n  } else {\n    q.parent = null;\n  }\n  q.left = p;\n  p.parent = q;\n  p.right = b;\n  if (b) { b.parent = p; }\n\n  // Update heights\n  ah = p.left ? p.left.height : 0;\n  bh = b ? b.height : 0;\n  ch = q.right ? q.right.height : 0;\n  p.height = Math.max(ah, bh) + 1;\n  q.height = Math.max(ch, p.height) + 1;\n\n  return q;\n};\n\n\n/**\n * Modify the tree if its right subtree is too small compared to the left\n * Return the new root if any\n */\n_AVLTree.prototype.rightTooSmall = function () {\n  if (this.balanceFactor() <= 1) { return this; }   // Right is not too small, don't change\n\n  if (this.left.balanceFactor() < 0) {\n    this.left.leftRotation();\n  }\n\n  return this.rightRotation();\n};\n\n\n/**\n * Modify the tree if its left subtree is too small compared to the right\n * Return the new root if any\n */\n_AVLTree.prototype.leftTooSmall = function () {\n  if (this.balanceFactor() >= -1) { return this; }   // Left is not too small, don't change\n\n  if (this.right.balanceFactor() > 0) {\n    this.right.rightRotation();\n  }\n\n  return this.leftRotation();\n};\n\n\n/**\n * Rebalance the tree along the given path. The path is given reversed (as he was calculated\n * in the insert and delete functions).\n * Returns the new root of the tree\n * Of course, the first element of the path must be the root of the tree\n */\n_AVLTree.prototype.rebalanceAlongPath = function (path) {\n  var newRoot = this\n    , rotated\n    , i;\n\n  if (!this.hasOwnProperty('key')) { delete this.height; return this; }   // Empty tree\n\n  // Rebalance the tree and update all heights\n  for (i = path.length - 1; i >= 0; i -= 1) {\n    path[i].height = 1 + Math.max(path[i].left ? path[i].left.height : 0, path[i].right ? path[i].right.height : 0);\n\n    if (path[i].balanceFactor() > 1) {\n      rotated = path[i].rightTooSmall();\n      if (i === 0) { newRoot = rotated; }\n    }\n\n    if (path[i].balanceFactor() < -1) {\n      rotated = path[i].leftTooSmall();\n      if (i === 0) { newRoot = rotated; }\n    }\n  }\n\n  return newRoot;\n};\n\n\n/**\n * Insert a key, value pair in the tree while maintaining the AVL tree height constraint\n * Return a pointer to the root node, which may have changed\n */\n_AVLTree.prototype.insert = function (key, value) {\n  var insertPath = []\n    , currentNode = this\n    ;\n\n  // Empty tree, insert as root\n  if (!this.hasOwnProperty('key')) {\n    this.key = key;\n    this.data.push(value);\n    this.height = 1;\n    return this;\n  }\n\n  // Insert new leaf at the right place\n  while (true) {\n    // Same key: no change in the tree structure\n    if (currentNode.compareKeys(currentNode.key, key) === 0) {\n      if (currentNode.unique) {\n        var err = new Error(\"Can't insert key \" + key + \", it violates the unique constraint\");\n        err.key = key;\n        err.errorType = 'uniqueViolated';\n        throw err;\n      } else {\n        currentNode.data.push(value);\n      }\n      return this;\n    }\n\n    insertPath.push(currentNode);\n\n    if (currentNode.compareKeys(key, currentNode.key) < 0) {\n      if (!currentNode.left) {\n        insertPath.push(currentNode.createLeftChild({ key: key, value: value }));\n        break;\n      } else {\n        currentNode = currentNode.left;\n      }\n    } else {\n      if (!currentNode.right) {\n        insertPath.push(currentNode.createRightChild({ key: key, value: value }));\n        break;\n      } else {\n        currentNode = currentNode.right;\n      }\n    }\n  }\n\n  return this.rebalanceAlongPath(insertPath);\n};\n\n// Insert in the internal tree, update the pointer to the root if needed\nAVLTree.prototype.insert = function (key, value) {\n  var newTree = this.tree.insert(key, value);\n\n  // If newTree is undefined, that means its structure was not modified\n  if (newTree) { this.tree = newTree; }\n};\n\n\n/**\n * Delete a key or just a value and return the new root of the tree\n * @param {Key} key\n * @param {Value} value Optional. If not set, the whole key is deleted. If set, only this value is deleted\n */\n_AVLTree.prototype.delete = function (key, value) {\n  var newData = [], replaceWith\n    , self = this\n    , currentNode = this\n    , deletePath = []\n    ;\n\n  if (!this.hasOwnProperty('key')) { return this; }   // Empty tree\n\n  // Either no match is found and the function will return from within the loop\n  // Or a match is found and deletePath will contain the path from the root to the node to delete after the loop\n  while (true) {\n    if (currentNode.compareKeys(key, currentNode.key) === 0) { break; }\n\n    deletePath.push(currentNode);\n\n    if (currentNode.compareKeys(key, currentNode.key) < 0) {\n      if (currentNode.left) {\n        currentNode = currentNode.left;\n      } else {\n        return this;   // Key not found, no modification\n      }\n    } else {\n      // currentNode.compareKeys(key, currentNode.key) is > 0\n      if (currentNode.right) {\n        currentNode = currentNode.right;\n      } else {\n        return this;   // Key not found, no modification\n      }\n    }\n  }\n\n  // Delete only a value (no tree modification)\n  if (currentNode.data.length > 1 && value) {\n    currentNode.data.forEach(function (d) {\n      if (!currentNode.checkValueEquality(d, value)) { newData.push(d); }\n    });\n    currentNode.data = newData;\n    return this;\n  }\n\n  // Delete a whole node\n\n  // Leaf\n  if (!currentNode.left && !currentNode.right) {\n    if (currentNode === this) {   // This leaf is also the root\n      delete currentNode.key;\n      currentNode.data = [];\n      delete currentNode.height;\n      return this;\n    } else {\n      if (currentNode.parent.left === currentNode) {\n        currentNode.parent.left = null;\n      } else {\n        currentNode.parent.right = null;\n      }\n      return this.rebalanceAlongPath(deletePath);\n    }\n  }\n\n\n  // Node with only one child\n  if (!currentNode.left || !currentNode.right) {\n    replaceWith = currentNode.left ? currentNode.left : currentNode.right;\n\n    if (currentNode === this) {   // This node is also the root\n      replaceWith.parent = null;\n      return replaceWith;   // height of replaceWith is necessarily 1 because the tree was balanced before deletion\n    } else {\n      if (currentNode.parent.left === currentNode) {\n        currentNode.parent.left = replaceWith;\n        replaceWith.parent = currentNode.parent;\n      } else {\n        currentNode.parent.right = replaceWith;\n        replaceWith.parent = currentNode.parent;\n      }\n\n      return this.rebalanceAlongPath(deletePath);\n    }\n  }\n\n\n  // Node with two children\n  // Use the in-order predecessor (no need to randomize since we actively rebalance)\n  deletePath.push(currentNode);\n  replaceWith = currentNode.left;\n\n  // Special case: the in-order predecessor is right below the node to delete\n  if (!replaceWith.right) {\n    currentNode.key = replaceWith.key;\n    currentNode.data = replaceWith.data;\n    currentNode.left = replaceWith.left;\n    if (replaceWith.left) { replaceWith.left.parent = currentNode; }\n    return this.rebalanceAlongPath(deletePath);\n  }\n\n  // After this loop, replaceWith is the right-most leaf in the left subtree\n  // and deletePath the path from the root (inclusive) to replaceWith (exclusive)\n  while (true) {\n    if (replaceWith.right) {\n      deletePath.push(replaceWith);\n      replaceWith = replaceWith.right;\n    } else {\n      break;\n    }\n  }\n\n  currentNode.key = replaceWith.key;\n  currentNode.data = replaceWith.data;\n\n  replaceWith.parent.right = replaceWith.left;\n  if (replaceWith.left) { replaceWith.left.parent = replaceWith.parent; }\n\n  return this.rebalanceAlongPath(deletePath);\n};\n\n// Delete a value\nAVLTree.prototype.delete = function (key, value) {\n  var newTree = this.tree.delete(key, value);\n\n  // If newTree is undefined, that means its structure was not modified\n  if (newTree) { this.tree = newTree; }\n};\n\n\n/**\n * Other functions we want to use on an AVLTree as if it were the internal _AVLTree\n */\n['getNumberOfKeys', 'search', 'betweenBounds', 'prettyPrint', 'executeOnEveryNode'].forEach(function (fn) {\n  AVLTree.prototype[fn] = function () {\n    return this.tree[fn].apply(this.tree, arguments);\n  };\n});\n\n\n// Interface\nmodule.exports = AVLTree;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmluYXJ5LXNlYXJjaC10cmVlL2xpYi9hdmx0cmVlLmpzPzgzNWMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBTZWxmLWJhbGFuY2luZyBiaW5hcnkgc2VhcmNoIHRyZWUgdXNpbmcgdGhlIEFWTCBpbXBsZW1lbnRhdGlvblxuICovXG52YXIgQmluYXJ5U2VhcmNoVHJlZSA9IHJlcXVpcmUoJy4vYnN0JylcbiAgLCBjdXN0b21VdGlscyA9IHJlcXVpcmUoJy4vY3VzdG9tVXRpbHMnKVxuICAsIHV0aWwgPSByZXF1aXJlKCd1dGlsJylcbiAgLCBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpXG4gIDtcblxuXG4vKipcbiAqIENvbnN0cnVjdG9yXG4gKiBXZSBjYW4ndCB1c2UgYSBkaXJlY3QgcG9pbnRlciB0byB0aGUgcm9vdCBub2RlIChhcyBpbiB0aGUgc2ltcGxlIGJpbmFyeSBzZWFyY2ggdHJlZSlcbiAqIGFzIHRoZSByb290IHdpbGwgY2hhbmdlIGR1cmluZyB0cmVlIHJvdGF0aW9uc1xuICogQHBhcmFtIHtCb29sZWFufSAgb3B0aW9ucy51bmlxdWUgV2hldGhlciB0byBlbmZvcmNlIGEgJ3VuaXF1ZScgY29uc3RyYWludCBvbiB0aGUga2V5IG9yIG5vdFxuICogQHBhcmFtIHtGdW5jdGlvbn0gb3B0aW9ucy5jb21wYXJlS2V5cyBJbml0aWFsaXplIHRoaXMgQlNUJ3MgY29tcGFyZUtleXNcbiAqL1xuZnVuY3Rpb24gQVZMVHJlZSAob3B0aW9ucykge1xuICB0aGlzLnRyZWUgPSBuZXcgX0FWTFRyZWUob3B0aW9ucyk7XG59XG5cblxuLyoqXG4gKiBDb25zdHJ1Y3RvciBvZiB0aGUgaW50ZXJuYWwgQVZMVHJlZVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgT3B0aW9uYWxcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gIG9wdGlvbnMudW5pcXVlIFdoZXRoZXIgdG8gZW5mb3JjZSBhICd1bmlxdWUnIGNvbnN0cmFpbnQgb24gdGhlIGtleSBvciBub3RcbiAqIEBwYXJhbSB7S2V5fSAgICAgIG9wdGlvbnMua2V5IEluaXRpYWxpemUgdGhpcyBCU1QncyBrZXkgd2l0aCBrZXlcbiAqIEBwYXJhbSB7VmFsdWV9ICAgIG9wdGlvbnMudmFsdWUgSW5pdGlhbGl6ZSB0aGlzIEJTVCdzIGRhdGEgd2l0aCBbdmFsdWVdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcHRpb25zLmNvbXBhcmVLZXlzIEluaXRpYWxpemUgdGhpcyBCU1QncyBjb21wYXJlS2V5c1xuICovXG5mdW5jdGlvbiBfQVZMVHJlZSAob3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICB0aGlzLmxlZnQgPSBudWxsO1xuICB0aGlzLnJpZ2h0ID0gbnVsbDtcbiAgdGhpcy5wYXJlbnQgPSBvcHRpb25zLnBhcmVudCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5wYXJlbnQgOiBudWxsO1xuICBpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgna2V5JykpIHsgdGhpcy5rZXkgPSBvcHRpb25zLmtleTsgfVxuICB0aGlzLmRhdGEgPSBvcHRpb25zLmhhc093blByb3BlcnR5KCd2YWx1ZScpID8gW29wdGlvbnMudmFsdWVdIDogW107XG4gIHRoaXMudW5pcXVlID0gb3B0aW9ucy51bmlxdWUgfHwgZmFsc2U7XG5cbiAgdGhpcy5jb21wYXJlS2V5cyA9IG9wdGlvbnMuY29tcGFyZUtleXMgfHwgY3VzdG9tVXRpbHMuZGVmYXVsdENvbXBhcmVLZXlzRnVuY3Rpb247XG4gIHRoaXMuY2hlY2tWYWx1ZUVxdWFsaXR5ID0gb3B0aW9ucy5jaGVja1ZhbHVlRXF1YWxpdHkgfHwgY3VzdG9tVXRpbHMuZGVmYXVsdENoZWNrVmFsdWVFcXVhbGl0eTtcbn1cblxuXG4vKipcbiAqIEluaGVyaXQgYmFzaWMgZnVuY3Rpb25zIGZyb20gdGhlIGJhc2ljIGJpbmFyeSBzZWFyY2ggdHJlZVxuICovXG51dGlsLmluaGVyaXRzKF9BVkxUcmVlLCBCaW5hcnlTZWFyY2hUcmVlKTtcblxuLyoqXG4gKiBLZWVwIGEgcG9pbnRlciB0byB0aGUgaW50ZXJuYWwgdHJlZSBjb25zdHJ1Y3RvciBmb3IgdGVzdGluZyBwdXJwb3Nlc1xuICovXG5BVkxUcmVlLl9BVkxUcmVlID0gX0FWTFRyZWU7XG5cblxuLyoqXG4gKiBDaGVjayB0aGUgcmVjb3JkZWQgaGVpZ2h0IGlzIGNvcnJlY3QgZm9yIGV2ZXJ5IG5vZGVcbiAqIFRocm93cyBpZiBvbmUgaGVpZ2h0IGRvZXNuJ3QgbWF0Y2hcbiAqL1xuX0FWTFRyZWUucHJvdG90eXBlLmNoZWNrSGVpZ2h0Q29ycmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGxlZnRILCByaWdodEg7XG5cbiAgaWYgKCF0aGlzLmhhc093blByb3BlcnR5KCdrZXknKSkgeyByZXR1cm47IH0gICAvLyBFbXB0eSB0cmVlXG5cbiAgaWYgKHRoaXMubGVmdCAmJiB0aGlzLmxlZnQuaGVpZ2h0ID09PSB1bmRlZmluZWQpIHsgdGhyb3cgbmV3IEVycm9yKFwiVW5kZWZpbmVkIGhlaWdodCBmb3Igbm9kZSBcIiArIHRoaXMubGVmdC5rZXkpOyB9XG4gIGlmICh0aGlzLnJpZ2h0ICYmIHRoaXMucmlnaHQuaGVpZ2h0ID09PSB1bmRlZmluZWQpIHsgdGhyb3cgbmV3IEVycm9yKFwiVW5kZWZpbmVkIGhlaWdodCBmb3Igbm9kZSBcIiArIHRoaXMucmlnaHQua2V5KTsgfVxuICBpZiAodGhpcy5oZWlnaHQgPT09IHVuZGVmaW5lZCkgeyB0aHJvdyBuZXcgRXJyb3IoXCJVbmRlZmluZWQgaGVpZ2h0IGZvciBub2RlIFwiICsgdGhpcy5rZXkpOyB9XG5cbiAgbGVmdEggPSB0aGlzLmxlZnQgPyB0aGlzLmxlZnQuaGVpZ2h0IDogMDtcbiAgcmlnaHRIID0gdGhpcy5yaWdodCA/IHRoaXMucmlnaHQuaGVpZ2h0IDogMDtcblxuICBpZiAodGhpcy5oZWlnaHQgIT09IDEgKyBNYXRoLm1heChsZWZ0SCwgcmlnaHRIKSkgeyB0aHJvdyBuZXcgRXJyb3IoXCJIZWlnaHQgY29uc3RyYWludCBmYWlsZWQgZm9yIG5vZGUgXCIgKyB0aGlzLmtleSk7IH1cbiAgaWYgKHRoaXMubGVmdCkgeyB0aGlzLmxlZnQuY2hlY2tIZWlnaHRDb3JyZWN0KCk7IH1cbiAgaWYgKHRoaXMucmlnaHQpIHsgdGhpcy5yaWdodC5jaGVja0hlaWdodENvcnJlY3QoKTsgfVxufTtcblxuXG4vKipcbiAqIFJldHVybiB0aGUgYmFsYW5jZSBmYWN0b3JcbiAqL1xuX0FWTFRyZWUucHJvdG90eXBlLmJhbGFuY2VGYWN0b3IgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBsZWZ0SCA9IHRoaXMubGVmdCA/IHRoaXMubGVmdC5oZWlnaHQgOiAwXG4gICAgLCByaWdodEggPSB0aGlzLnJpZ2h0ID8gdGhpcy5yaWdodC5oZWlnaHQgOiAwXG4gICAgO1xuICByZXR1cm4gbGVmdEggLSByaWdodEg7XG59O1xuXG5cbi8qKlxuICogQ2hlY2sgdGhhdCB0aGUgYmFsYW5jZSBmYWN0b3JzIGFyZSBhbGwgYmV0d2VlbiAtMSBhbmQgMVxuICovXG5fQVZMVHJlZS5wcm90b3R5cGUuY2hlY2tCYWxhbmNlRmFjdG9ycyA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKE1hdGguYWJzKHRoaXMuYmFsYW5jZUZhY3RvcigpKSA+IDEpIHsgdGhyb3cgbmV3IEVycm9yKCdUcmVlIGlzIHVuYmFsYW5jZWQgYXQgbm9kZSAnICsgdGhpcy5rZXkpOyB9XG5cbiAgaWYgKHRoaXMubGVmdCkgeyB0aGlzLmxlZnQuY2hlY2tCYWxhbmNlRmFjdG9ycygpOyB9XG4gIGlmICh0aGlzLnJpZ2h0KSB7IHRoaXMucmlnaHQuY2hlY2tCYWxhbmNlRmFjdG9ycygpOyB9XG59O1xuXG5cbi8qKlxuICogV2hlbiBjaGVja2luZyBpZiB0aGUgQlNUIGNvbmRpdGlvbnMgYXJlIG1ldCwgYWxzbyBjaGVjayB0aGF0IHRoZSBoZWlnaHRzIGFyZSBjb3JyZWN0XG4gKiBhbmQgdGhlIHRyZWUgaXMgYmFsYW5jZWRcbiAqL1xuX0FWTFRyZWUucHJvdG90eXBlLmNoZWNrSXNBVkxUID0gZnVuY3Rpb24gKCkge1xuICBfQVZMVHJlZS5zdXBlcl8ucHJvdG90eXBlLmNoZWNrSXNCU1QuY2FsbCh0aGlzKTtcbiAgdGhpcy5jaGVja0hlaWdodENvcnJlY3QoKTtcbiAgdGhpcy5jaGVja0JhbGFuY2VGYWN0b3JzKCk7XG59O1xuQVZMVHJlZS5wcm90b3R5cGUuY2hlY2tJc0FWTFQgPSBmdW5jdGlvbiAoKSB7IHRoaXMudHJlZS5jaGVja0lzQVZMVCgpOyB9O1xuXG5cbi8qKlxuICogUGVyZm9ybSBhIHJpZ2h0IHJvdGF0aW9uIG9mIHRoZSB0cmVlIGlmIHBvc3NpYmxlXG4gKiBhbmQgcmV0dXJuIHRoZSByb290IG9mIHRoZSByZXN1bHRpbmcgdHJlZVxuICogVGhlIHJlc3VsdGluZyB0cmVlJ3Mgbm9kZXMnIGhlaWdodHMgYXJlIGFsc28gdXBkYXRlZFxuICovXG5fQVZMVHJlZS5wcm90b3R5cGUucmlnaHRSb3RhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHEgPSB0aGlzXG4gICAgLCBwID0gdGhpcy5sZWZ0XG4gICAgLCBiXG4gICAgLCBhaCwgYmgsIGNoO1xuXG4gIGlmICghcCkgeyByZXR1cm4gdGhpczsgfSAgIC8vIE5vIGNoYW5nZVxuXG4gIGIgPSBwLnJpZ2h0O1xuXG4gIC8vIEFsdGVyIHRyZWUgc3RydWN0dXJlXG4gIGlmIChxLnBhcmVudCkge1xuICAgIHAucGFyZW50ID0gcS5wYXJlbnQ7XG4gICAgaWYgKHEucGFyZW50LmxlZnQgPT09IHEpIHsgcS5wYXJlbnQubGVmdCA9IHA7IH0gZWxzZSB7IHEucGFyZW50LnJpZ2h0ID0gcDsgfVxuICB9IGVsc2Uge1xuICAgIHAucGFyZW50ID0gbnVsbDtcbiAgfVxuICBwLnJpZ2h0ID0gcTtcbiAgcS5wYXJlbnQgPSBwO1xuICBxLmxlZnQgPSBiO1xuICBpZiAoYikgeyBiLnBhcmVudCA9IHE7IH1cblxuICAvLyBVcGRhdGUgaGVpZ2h0c1xuICBhaCA9IHAubGVmdCA/IHAubGVmdC5oZWlnaHQgOiAwO1xuICBiaCA9IGIgPyBiLmhlaWdodCA6IDA7XG4gIGNoID0gcS5yaWdodCA/IHEucmlnaHQuaGVpZ2h0IDogMDtcbiAgcS5oZWlnaHQgPSBNYXRoLm1heChiaCwgY2gpICsgMTtcbiAgcC5oZWlnaHQgPSBNYXRoLm1heChhaCwgcS5oZWlnaHQpICsgMTtcblxuICByZXR1cm4gcDtcbn07XG5cblxuLyoqXG4gKiBQZXJmb3JtIGEgbGVmdCByb3RhdGlvbiBvZiB0aGUgdHJlZSBpZiBwb3NzaWJsZVxuICogYW5kIHJldHVybiB0aGUgcm9vdCBvZiB0aGUgcmVzdWx0aW5nIHRyZWVcbiAqIFRoZSByZXN1bHRpbmcgdHJlZSdzIG5vZGVzJyBoZWlnaHRzIGFyZSBhbHNvIHVwZGF0ZWRcbiAqL1xuX0FWTFRyZWUucHJvdG90eXBlLmxlZnRSb3RhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHAgPSB0aGlzXG4gICAgLCBxID0gdGhpcy5yaWdodFxuICAgICwgYlxuICAgICwgYWgsIGJoLCBjaDtcblxuICBpZiAoIXEpIHsgcmV0dXJuIHRoaXM7IH0gICAvLyBObyBjaGFuZ2VcblxuICBiID0gcS5sZWZ0O1xuXG4gIC8vIEFsdGVyIHRyZWUgc3RydWN0dXJlXG4gIGlmIChwLnBhcmVudCkge1xuICAgIHEucGFyZW50ID0gcC5wYXJlbnQ7XG4gICAgaWYgKHAucGFyZW50LmxlZnQgPT09IHApIHsgcC5wYXJlbnQubGVmdCA9IHE7IH0gZWxzZSB7IHAucGFyZW50LnJpZ2h0ID0gcTsgfVxuICB9IGVsc2Uge1xuICAgIHEucGFyZW50ID0gbnVsbDtcbiAgfVxuICBxLmxlZnQgPSBwO1xuICBwLnBhcmVudCA9IHE7XG4gIHAucmlnaHQgPSBiO1xuICBpZiAoYikgeyBiLnBhcmVudCA9IHA7IH1cblxuICAvLyBVcGRhdGUgaGVpZ2h0c1xuICBhaCA9IHAubGVmdCA/IHAubGVmdC5oZWlnaHQgOiAwO1xuICBiaCA9IGIgPyBiLmhlaWdodCA6IDA7XG4gIGNoID0gcS5yaWdodCA/IHEucmlnaHQuaGVpZ2h0IDogMDtcbiAgcC5oZWlnaHQgPSBNYXRoLm1heChhaCwgYmgpICsgMTtcbiAgcS5oZWlnaHQgPSBNYXRoLm1heChjaCwgcC5oZWlnaHQpICsgMTtcblxuICByZXR1cm4gcTtcbn07XG5cblxuLyoqXG4gKiBNb2RpZnkgdGhlIHRyZWUgaWYgaXRzIHJpZ2h0IHN1YnRyZWUgaXMgdG9vIHNtYWxsIGNvbXBhcmVkIHRvIHRoZSBsZWZ0XG4gKiBSZXR1cm4gdGhlIG5ldyByb290IGlmIGFueVxuICovXG5fQVZMVHJlZS5wcm90b3R5cGUucmlnaHRUb29TbWFsbCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuYmFsYW5jZUZhY3RvcigpIDw9IDEpIHsgcmV0dXJuIHRoaXM7IH0gICAvLyBSaWdodCBpcyBub3QgdG9vIHNtYWxsLCBkb24ndCBjaGFuZ2VcblxuICBpZiAodGhpcy5sZWZ0LmJhbGFuY2VGYWN0b3IoKSA8IDApIHtcbiAgICB0aGlzLmxlZnQubGVmdFJvdGF0aW9uKCk7XG4gIH1cblxuICByZXR1cm4gdGhpcy5yaWdodFJvdGF0aW9uKCk7XG59O1xuXG5cbi8qKlxuICogTW9kaWZ5IHRoZSB0cmVlIGlmIGl0cyBsZWZ0IHN1YnRyZWUgaXMgdG9vIHNtYWxsIGNvbXBhcmVkIHRvIHRoZSByaWdodFxuICogUmV0dXJuIHRoZSBuZXcgcm9vdCBpZiBhbnlcbiAqL1xuX0FWTFRyZWUucHJvdG90eXBlLmxlZnRUb29TbWFsbCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuYmFsYW5jZUZhY3RvcigpID49IC0xKSB7IHJldHVybiB0aGlzOyB9ICAgLy8gTGVmdCBpcyBub3QgdG9vIHNtYWxsLCBkb24ndCBjaGFuZ2VcblxuICBpZiAodGhpcy5yaWdodC5iYWxhbmNlRmFjdG9yKCkgPiAwKSB7XG4gICAgdGhpcy5yaWdodC5yaWdodFJvdGF0aW9uKCk7XG4gIH1cblxuICByZXR1cm4gdGhpcy5sZWZ0Um90YXRpb24oKTtcbn07XG5cblxuLyoqXG4gKiBSZWJhbGFuY2UgdGhlIHRyZWUgYWxvbmcgdGhlIGdpdmVuIHBhdGguIFRoZSBwYXRoIGlzIGdpdmVuIHJldmVyc2VkIChhcyBoZSB3YXMgY2FsY3VsYXRlZFxuICogaW4gdGhlIGluc2VydCBhbmQgZGVsZXRlIGZ1bmN0aW9ucykuXG4gKiBSZXR1cm5zIHRoZSBuZXcgcm9vdCBvZiB0aGUgdHJlZVxuICogT2YgY291cnNlLCB0aGUgZmlyc3QgZWxlbWVudCBvZiB0aGUgcGF0aCBtdXN0IGJlIHRoZSByb290IG9mIHRoZSB0cmVlXG4gKi9cbl9BVkxUcmVlLnByb3RvdHlwZS5yZWJhbGFuY2VBbG9uZ1BhdGggPSBmdW5jdGlvbiAocGF0aCkge1xuICB2YXIgbmV3Um9vdCA9IHRoaXNcbiAgICAsIHJvdGF0ZWRcbiAgICAsIGk7XG5cbiAgaWYgKCF0aGlzLmhhc093blByb3BlcnR5KCdrZXknKSkgeyBkZWxldGUgdGhpcy5oZWlnaHQ7IHJldHVybiB0aGlzOyB9ICAgLy8gRW1wdHkgdHJlZVxuXG4gIC8vIFJlYmFsYW5jZSB0aGUgdHJlZSBhbmQgdXBkYXRlIGFsbCBoZWlnaHRzXG4gIGZvciAoaSA9IHBhdGgubGVuZ3RoIC0gMTsgaSA+PSAwOyBpIC09IDEpIHtcbiAgICBwYXRoW2ldLmhlaWdodCA9IDEgKyBNYXRoLm1heChwYXRoW2ldLmxlZnQgPyBwYXRoW2ldLmxlZnQuaGVpZ2h0IDogMCwgcGF0aFtpXS5yaWdodCA/IHBhdGhbaV0ucmlnaHQuaGVpZ2h0IDogMCk7XG5cbiAgICBpZiAocGF0aFtpXS5iYWxhbmNlRmFjdG9yKCkgPiAxKSB7XG4gICAgICByb3RhdGVkID0gcGF0aFtpXS5yaWdodFRvb1NtYWxsKCk7XG4gICAgICBpZiAoaSA9PT0gMCkgeyBuZXdSb290ID0gcm90YXRlZDsgfVxuICAgIH1cblxuICAgIGlmIChwYXRoW2ldLmJhbGFuY2VGYWN0b3IoKSA8IC0xKSB7XG4gICAgICByb3RhdGVkID0gcGF0aFtpXS5sZWZ0VG9vU21hbGwoKTtcbiAgICAgIGlmIChpID09PSAwKSB7IG5ld1Jvb3QgPSByb3RhdGVkOyB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ld1Jvb3Q7XG59O1xuXG5cbi8qKlxuICogSW5zZXJ0IGEga2V5LCB2YWx1ZSBwYWlyIGluIHRoZSB0cmVlIHdoaWxlIG1haW50YWluaW5nIHRoZSBBVkwgdHJlZSBoZWlnaHQgY29uc3RyYWludFxuICogUmV0dXJuIGEgcG9pbnRlciB0byB0aGUgcm9vdCBub2RlLCB3aGljaCBtYXkgaGF2ZSBjaGFuZ2VkXG4gKi9cbl9BVkxUcmVlLnByb3RvdHlwZS5pbnNlcnQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICB2YXIgaW5zZXJ0UGF0aCA9IFtdXG4gICAgLCBjdXJyZW50Tm9kZSA9IHRoaXNcbiAgICA7XG5cbiAgLy8gRW1wdHkgdHJlZSwgaW5zZXJ0IGFzIHJvb3RcbiAgaWYgKCF0aGlzLmhhc093blByb3BlcnR5KCdrZXknKSkge1xuICAgIHRoaXMua2V5ID0ga2V5O1xuICAgIHRoaXMuZGF0YS5wdXNoKHZhbHVlKTtcbiAgICB0aGlzLmhlaWdodCA9IDE7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBJbnNlcnQgbmV3IGxlYWYgYXQgdGhlIHJpZ2h0IHBsYWNlXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgLy8gU2FtZSBrZXk6IG5vIGNoYW5nZSBpbiB0aGUgdHJlZSBzdHJ1Y3R1cmVcbiAgICBpZiAoY3VycmVudE5vZGUuY29tcGFyZUtleXMoY3VycmVudE5vZGUua2V5LCBrZXkpID09PSAwKSB7XG4gICAgICBpZiAoY3VycmVudE5vZGUudW5pcXVlKSB7XG4gICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoXCJDYW4ndCBpbnNlcnQga2V5IFwiICsga2V5ICsgXCIsIGl0IHZpb2xhdGVzIHRoZSB1bmlxdWUgY29uc3RyYWludFwiKTtcbiAgICAgICAgZXJyLmtleSA9IGtleTtcbiAgICAgICAgZXJyLmVycm9yVHlwZSA9ICd1bmlxdWVWaW9sYXRlZCc7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN1cnJlbnROb2RlLmRhdGEucHVzaCh2YWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBpbnNlcnRQYXRoLnB1c2goY3VycmVudE5vZGUpO1xuXG4gICAgaWYgKGN1cnJlbnROb2RlLmNvbXBhcmVLZXlzKGtleSwgY3VycmVudE5vZGUua2V5KSA8IDApIHtcbiAgICAgIGlmICghY3VycmVudE5vZGUubGVmdCkge1xuICAgICAgICBpbnNlcnRQYXRoLnB1c2goY3VycmVudE5vZGUuY3JlYXRlTGVmdENoaWxkKHsga2V5OiBrZXksIHZhbHVlOiB2YWx1ZSB9KSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3VycmVudE5vZGUgPSBjdXJyZW50Tm9kZS5sZWZ0O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIWN1cnJlbnROb2RlLnJpZ2h0KSB7XG4gICAgICAgIGluc2VydFBhdGgucHVzaChjdXJyZW50Tm9kZS5jcmVhdGVSaWdodENoaWxkKHsga2V5OiBrZXksIHZhbHVlOiB2YWx1ZSB9KSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3VycmVudE5vZGUgPSBjdXJyZW50Tm9kZS5yaWdodDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcy5yZWJhbGFuY2VBbG9uZ1BhdGgoaW5zZXJ0UGF0aCk7XG59O1xuXG4vLyBJbnNlcnQgaW4gdGhlIGludGVybmFsIHRyZWUsIHVwZGF0ZSB0aGUgcG9pbnRlciB0byB0aGUgcm9vdCBpZiBuZWVkZWRcbkFWTFRyZWUucHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gIHZhciBuZXdUcmVlID0gdGhpcy50cmVlLmluc2VydChrZXksIHZhbHVlKTtcblxuICAvLyBJZiBuZXdUcmVlIGlzIHVuZGVmaW5lZCwgdGhhdCBtZWFucyBpdHMgc3RydWN0dXJlIHdhcyBub3QgbW9kaWZpZWRcbiAgaWYgKG5ld1RyZWUpIHsgdGhpcy50cmVlID0gbmV3VHJlZTsgfVxufTtcblxuXG4vKipcbiAqIERlbGV0ZSBhIGtleSBvciBqdXN0IGEgdmFsdWUgYW5kIHJldHVybiB0aGUgbmV3IHJvb3Qgb2YgdGhlIHRyZWVcbiAqIEBwYXJhbSB7S2V5fSBrZXlcbiAqIEBwYXJhbSB7VmFsdWV9IHZhbHVlIE9wdGlvbmFsLiBJZiBub3Qgc2V0LCB0aGUgd2hvbGUga2V5IGlzIGRlbGV0ZWQuIElmIHNldCwgb25seSB0aGlzIHZhbHVlIGlzIGRlbGV0ZWRcbiAqL1xuX0FWTFRyZWUucHJvdG90eXBlLmRlbGV0ZSA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gIHZhciBuZXdEYXRhID0gW10sIHJlcGxhY2VXaXRoXG4gICAgLCBzZWxmID0gdGhpc1xuICAgICwgY3VycmVudE5vZGUgPSB0aGlzXG4gICAgLCBkZWxldGVQYXRoID0gW11cbiAgICA7XG5cbiAgaWYgKCF0aGlzLmhhc093blByb3BlcnR5KCdrZXknKSkgeyByZXR1cm4gdGhpczsgfSAgIC8vIEVtcHR5IHRyZWVcblxuICAvLyBFaXRoZXIgbm8gbWF0Y2ggaXMgZm91bmQgYW5kIHRoZSBmdW5jdGlvbiB3aWxsIHJldHVybiBmcm9tIHdpdGhpbiB0aGUgbG9vcFxuICAvLyBPciBhIG1hdGNoIGlzIGZvdW5kIGFuZCBkZWxldGVQYXRoIHdpbGwgY29udGFpbiB0aGUgcGF0aCBmcm9tIHRoZSByb290IHRvIHRoZSBub2RlIHRvIGRlbGV0ZSBhZnRlciB0aGUgbG9vcFxuICB3aGlsZSAodHJ1ZSkge1xuICAgIGlmIChjdXJyZW50Tm9kZS5jb21wYXJlS2V5cyhrZXksIGN1cnJlbnROb2RlLmtleSkgPT09IDApIHsgYnJlYWs7IH1cblxuICAgIGRlbGV0ZVBhdGgucHVzaChjdXJyZW50Tm9kZSk7XG5cbiAgICBpZiAoY3VycmVudE5vZGUuY29tcGFyZUtleXMoa2V5LCBjdXJyZW50Tm9kZS5rZXkpIDwgMCkge1xuICAgICAgaWYgKGN1cnJlbnROb2RlLmxlZnQpIHtcbiAgICAgICAgY3VycmVudE5vZGUgPSBjdXJyZW50Tm9kZS5sZWZ0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7ICAgLy8gS2V5IG5vdCBmb3VuZCwgbm8gbW9kaWZpY2F0aW9uXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGN1cnJlbnROb2RlLmNvbXBhcmVLZXlzKGtleSwgY3VycmVudE5vZGUua2V5KSBpcyA+IDBcbiAgICAgIGlmIChjdXJyZW50Tm9kZS5yaWdodCkge1xuICAgICAgICBjdXJyZW50Tm9kZSA9IGN1cnJlbnROb2RlLnJpZ2h0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7ICAgLy8gS2V5IG5vdCBmb3VuZCwgbm8gbW9kaWZpY2F0aW9uXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gRGVsZXRlIG9ubHkgYSB2YWx1ZSAobm8gdHJlZSBtb2RpZmljYXRpb24pXG4gIGlmIChjdXJyZW50Tm9kZS5kYXRhLmxlbmd0aCA+IDEgJiYgdmFsdWUpIHtcbiAgICBjdXJyZW50Tm9kZS5kYXRhLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgIGlmICghY3VycmVudE5vZGUuY2hlY2tWYWx1ZUVxdWFsaXR5KGQsIHZhbHVlKSkgeyBuZXdEYXRhLnB1c2goZCk7IH1cbiAgICB9KTtcbiAgICBjdXJyZW50Tm9kZS5kYXRhID0gbmV3RGF0YTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIERlbGV0ZSBhIHdob2xlIG5vZGVcblxuICAvLyBMZWFmXG4gIGlmICghY3VycmVudE5vZGUubGVmdCAmJiAhY3VycmVudE5vZGUucmlnaHQpIHtcbiAgICBpZiAoY3VycmVudE5vZGUgPT09IHRoaXMpIHsgICAvLyBUaGlzIGxlYWYgaXMgYWxzbyB0aGUgcm9vdFxuICAgICAgZGVsZXRlIGN1cnJlbnROb2RlLmtleTtcbiAgICAgIGN1cnJlbnROb2RlLmRhdGEgPSBbXTtcbiAgICAgIGRlbGV0ZSBjdXJyZW50Tm9kZS5oZWlnaHQ7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGN1cnJlbnROb2RlLnBhcmVudC5sZWZ0ID09PSBjdXJyZW50Tm9kZSkge1xuICAgICAgICBjdXJyZW50Tm9kZS5wYXJlbnQubGVmdCA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdXJyZW50Tm9kZS5wYXJlbnQucmlnaHQgPSBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMucmViYWxhbmNlQWxvbmdQYXRoKGRlbGV0ZVBhdGgpO1xuICAgIH1cbiAgfVxuXG5cbiAgLy8gTm9kZSB3aXRoIG9ubHkgb25lIGNoaWxkXG4gIGlmICghY3VycmVudE5vZGUubGVmdCB8fCAhY3VycmVudE5vZGUucmlnaHQpIHtcbiAgICByZXBsYWNlV2l0aCA9IGN1cnJlbnROb2RlLmxlZnQgPyBjdXJyZW50Tm9kZS5sZWZ0IDogY3VycmVudE5vZGUucmlnaHQ7XG5cbiAgICBpZiAoY3VycmVudE5vZGUgPT09IHRoaXMpIHsgICAvLyBUaGlzIG5vZGUgaXMgYWxzbyB0aGUgcm9vdFxuICAgICAgcmVwbGFjZVdpdGgucGFyZW50ID0gbnVsbDtcbiAgICAgIHJldHVybiByZXBsYWNlV2l0aDsgICAvLyBoZWlnaHQgb2YgcmVwbGFjZVdpdGggaXMgbmVjZXNzYXJpbHkgMSBiZWNhdXNlIHRoZSB0cmVlIHdhcyBiYWxhbmNlZCBiZWZvcmUgZGVsZXRpb25cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGN1cnJlbnROb2RlLnBhcmVudC5sZWZ0ID09PSBjdXJyZW50Tm9kZSkge1xuICAgICAgICBjdXJyZW50Tm9kZS5wYXJlbnQubGVmdCA9IHJlcGxhY2VXaXRoO1xuICAgICAgICByZXBsYWNlV2l0aC5wYXJlbnQgPSBjdXJyZW50Tm9kZS5wYXJlbnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdXJyZW50Tm9kZS5wYXJlbnQucmlnaHQgPSByZXBsYWNlV2l0aDtcbiAgICAgICAgcmVwbGFjZVdpdGgucGFyZW50ID0gY3VycmVudE5vZGUucGFyZW50O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5yZWJhbGFuY2VBbG9uZ1BhdGgoZGVsZXRlUGF0aCk7XG4gICAgfVxuICB9XG5cblxuICAvLyBOb2RlIHdpdGggdHdvIGNoaWxkcmVuXG4gIC8vIFVzZSB0aGUgaW4tb3JkZXIgcHJlZGVjZXNzb3IgKG5vIG5lZWQgdG8gcmFuZG9taXplIHNpbmNlIHdlIGFjdGl2ZWx5IHJlYmFsYW5jZSlcbiAgZGVsZXRlUGF0aC5wdXNoKGN1cnJlbnROb2RlKTtcbiAgcmVwbGFjZVdpdGggPSBjdXJyZW50Tm9kZS5sZWZ0O1xuXG4gIC8vIFNwZWNpYWwgY2FzZTogdGhlIGluLW9yZGVyIHByZWRlY2Vzc29yIGlzIHJpZ2h0IGJlbG93IHRoZSBub2RlIHRvIGRlbGV0ZVxuICBpZiAoIXJlcGxhY2VXaXRoLnJpZ2h0KSB7XG4gICAgY3VycmVudE5vZGUua2V5ID0gcmVwbGFjZVdpdGgua2V5O1xuICAgIGN1cnJlbnROb2RlLmRhdGEgPSByZXBsYWNlV2l0aC5kYXRhO1xuICAgIGN1cnJlbnROb2RlLmxlZnQgPSByZXBsYWNlV2l0aC5sZWZ0O1xuICAgIGlmIChyZXBsYWNlV2l0aC5sZWZ0KSB7IHJlcGxhY2VXaXRoLmxlZnQucGFyZW50ID0gY3VycmVudE5vZGU7IH1cbiAgICByZXR1cm4gdGhpcy5yZWJhbGFuY2VBbG9uZ1BhdGgoZGVsZXRlUGF0aCk7XG4gIH1cblxuICAvLyBBZnRlciB0aGlzIGxvb3AsIHJlcGxhY2VXaXRoIGlzIHRoZSByaWdodC1tb3N0IGxlYWYgaW4gdGhlIGxlZnQgc3VidHJlZVxuICAvLyBhbmQgZGVsZXRlUGF0aCB0aGUgcGF0aCBmcm9tIHRoZSByb290IChpbmNsdXNpdmUpIHRvIHJlcGxhY2VXaXRoIChleGNsdXNpdmUpXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgaWYgKHJlcGxhY2VXaXRoLnJpZ2h0KSB7XG4gICAgICBkZWxldGVQYXRoLnB1c2gocmVwbGFjZVdpdGgpO1xuICAgICAgcmVwbGFjZVdpdGggPSByZXBsYWNlV2l0aC5yaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgY3VycmVudE5vZGUua2V5ID0gcmVwbGFjZVdpdGgua2V5O1xuICBjdXJyZW50Tm9kZS5kYXRhID0gcmVwbGFjZVdpdGguZGF0YTtcblxuICByZXBsYWNlV2l0aC5wYXJlbnQucmlnaHQgPSByZXBsYWNlV2l0aC5sZWZ0O1xuICBpZiAocmVwbGFjZVdpdGgubGVmdCkgeyByZXBsYWNlV2l0aC5sZWZ0LnBhcmVudCA9IHJlcGxhY2VXaXRoLnBhcmVudDsgfVxuXG4gIHJldHVybiB0aGlzLnJlYmFsYW5jZUFsb25nUGF0aChkZWxldGVQYXRoKTtcbn07XG5cbi8vIERlbGV0ZSBhIHZhbHVlXG5BVkxUcmVlLnByb3RvdHlwZS5kZWxldGUgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICB2YXIgbmV3VHJlZSA9IHRoaXMudHJlZS5kZWxldGUoa2V5LCB2YWx1ZSk7XG5cbiAgLy8gSWYgbmV3VHJlZSBpcyB1bmRlZmluZWQsIHRoYXQgbWVhbnMgaXRzIHN0cnVjdHVyZSB3YXMgbm90IG1vZGlmaWVkXG4gIGlmIChuZXdUcmVlKSB7IHRoaXMudHJlZSA9IG5ld1RyZWU7IH1cbn07XG5cblxuLyoqXG4gKiBPdGhlciBmdW5jdGlvbnMgd2Ugd2FudCB0byB1c2Ugb24gYW4gQVZMVHJlZSBhcyBpZiBpdCB3ZXJlIHRoZSBpbnRlcm5hbCBfQVZMVHJlZVxuICovXG5bJ2dldE51bWJlck9mS2V5cycsICdzZWFyY2gnLCAnYmV0d2VlbkJvdW5kcycsICdwcmV0dHlQcmludCcsICdleGVjdXRlT25FdmVyeU5vZGUnXS5mb3JFYWNoKGZ1bmN0aW9uIChmbikge1xuICBBVkxUcmVlLnByb3RvdHlwZVtmbl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudHJlZVtmbl0uYXBwbHkodGhpcy50cmVlLCBhcmd1bWVudHMpO1xuICB9O1xufSk7XG5cblxuLy8gSW50ZXJmYWNlXG5tb2R1bGUuZXhwb3J0cyA9IEFWTFRyZWU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9iaW5hcnktc2VhcmNoLXRyZWUvbGliL2F2bHRyZWUuanNcbi8vIG1vZHVsZSBpZCA9IDI3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///27\n");

/***/ }),
/* 28 */
/*!**********************************************!*\
  !*** ./node_modules/nedb/lib/persistence.js ***!
  \**********************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * Handle every persistence-related task\n * The interface Datastore expects to be implemented is\n * * Persistence.loadDatabase(callback) and callback has signature err\n * * Persistence.persistNewState(newDocs, callback) where newDocs is an array of documents and callback has signature err\n */\n\nvar storage = __webpack_require__(/*! ./storage */ 29)\n  , path = __webpack_require__(/*! path */ 2)\n  , model = __webpack_require__(/*! ./model */ 4)\n  , async = __webpack_require__(/*! async */ 6)\n  , customUtils = __webpack_require__(/*! ./customUtils */ 7)\n  , Index = __webpack_require__(/*! ./indexes */ 8)\n  ;\n\n\n/**\n * Create a new Persistence object for database options.db\n * @param {Datastore} options.db\n * @param {Boolean} options.nodeWebkitAppName Optional, specify the name of your NW app if you want options.filename to be relative to the directory where\n *                                            Node Webkit stores application data such as cookies and local storage (the best place to store data in my opinion)\n */\nfunction Persistence (options) {\n  var i, j, randomString;\n\n  this.db = options.db;\n  this.inMemoryOnly = this.db.inMemoryOnly;\n  this.filename = this.db.filename;\n  this.corruptAlertThreshold = options.corruptAlertThreshold !== undefined ? options.corruptAlertThreshold : 0.1;\n\n  if (!this.inMemoryOnly && this.filename && this.filename.charAt(this.filename.length - 1) === '~') {\n    throw new Error(\"The datafile name can't end with a ~, which is reserved for crash safe backup files\");\n  }\n\n  // After serialization and before deserialization hooks with some basic sanity checks\n  if (options.afterSerialization && !options.beforeDeserialization) {\n    throw new Error(\"Serialization hook defined but deserialization hook undefined, cautiously refusing to start NeDB to prevent dataloss\");\n  }\n  if (!options.afterSerialization && options.beforeDeserialization) {\n    throw new Error(\"Serialization hook undefined but deserialization hook defined, cautiously refusing to start NeDB to prevent dataloss\");\n  }\n  this.afterSerialization = options.afterSerialization || function (s) { return s; };\n  this.beforeDeserialization = options.beforeDeserialization || function (s) { return s; };\n  for (i = 1; i < 30; i += 1) {\n    for (j = 0; j < 10; j += 1) {\n      randomString = customUtils.uid(i);\n      if (this.beforeDeserialization(this.afterSerialization(randomString)) !== randomString) {\n        throw new Error(\"beforeDeserialization is not the reverse of afterSerialization, cautiously refusing to start NeDB to prevent dataloss\");\n      }\n    }\n  }\n\n  // For NW apps, store data in the same directory where NW stores application data\n  if (this.filename && options.nodeWebkitAppName) {\n    console.log(\"==================================================================\");\n    console.log(\"WARNING: The nodeWebkitAppName option is deprecated\");\n    console.log(\"To get the path to the directory where Node Webkit stores the data\");\n    console.log(\"for your app, use the internal nw.gui module like this\");\n    console.log(\"require('nw.gui').App.dataPath\");\n    console.log(\"See https://github.com/rogerwang/node-webkit/issues/500\");\n    console.log(\"==================================================================\");\n    this.filename = Persistence.getNWAppFilename(options.nodeWebkitAppName, this.filename);\n  }\n};\n\n\n/**\n * Check if a directory exists and create it on the fly if it is not the case\n * cb is optional, signature: err\n */\nPersistence.ensureDirectoryExists = function (dir, cb) {\n  var callback = cb || function () {}\n    ;\n\n  storage.mkdirp(dir, function (err) { return callback(err); });\n};\n\n\n\n\n/**\n * Return the path the datafile if the given filename is relative to the directory where Node Webkit stores\n * data for this application. Probably the best place to store data\n */\nPersistence.getNWAppFilename = function (appName, relativeFilename) {\n  var home;\n\n  switch (process.platform) {\n    case 'win32':\n    case 'win64':\n      home = process.env.LOCALAPPDATA || process.env.APPDATA;\n      if (!home) { throw new Error(\"Couldn't find the base application data folder\"); }\n      home = path.join(home, appName);\n      break;\n    case 'darwin':\n      home = process.env.HOME;\n      if (!home) { throw new Error(\"Couldn't find the base application data directory\"); }\n      home = path.join(home, 'Library', 'Application Support', appName);\n      break;\n    case 'linux':\n      home = process.env.HOME;\n      if (!home) { throw new Error(\"Couldn't find the base application data directory\"); }\n      home = path.join(home, '.config', appName);\n      break;\n    default:\n      throw new Error(\"Can't use the Node Webkit relative path for platform \" + process.platform);\n      break;\n  }\n\n  return path.join(home, 'nedb-data', relativeFilename);\n}\n\n\n/**\n * Persist cached database\n * This serves as a compaction function since the cache always contains only the number of documents in the collection\n * while the data file is append-only so it may grow larger\n * @param {Function} cb Optional callback, signature: err\n */\nPersistence.prototype.persistCachedDatabase = function (cb) {\n  var callback = cb || function () {}\n    , toPersist = ''\n    , self = this\n    ;\n\n  if (this.inMemoryOnly) { return callback(null); }\n\n  this.db.getAllData().forEach(function (doc) {\n    toPersist += self.afterSerialization(model.serialize(doc)) + '\\n';\n  });\n  Object.keys(this.db.indexes).forEach(function (fieldName) {\n    if (fieldName != \"_id\") {   // The special _id index is managed by datastore.js, the others need to be persisted\n      toPersist += self.afterSerialization(model.serialize({ $$indexCreated: { fieldName: fieldName, unique: self.db.indexes[fieldName].unique, sparse: self.db.indexes[fieldName].sparse }})) + '\\n';\n    }\n  });\n\n  storage.crashSafeWriteFile(this.filename, toPersist, function (err) {\n    if (err) { return callback(err); }\n    self.db.emit('compaction.done');\n    return callback(null);\n  });\n};\n\n\n/**\n * Queue a rewrite of the datafile\n */\nPersistence.prototype.compactDatafile = function () {\n  this.db.executor.push({ this: this, fn: this.persistCachedDatabase, arguments: [] });\n};\n\n\n/**\n * Set automatic compaction every interval ms\n * @param {Number} interval in milliseconds, with an enforced minimum of 5 seconds\n */\nPersistence.prototype.setAutocompactionInterval = function (interval) {\n  var self = this\n    , minInterval = 5000\n    , realInterval = Math.max(interval || 0, minInterval)\n    ;\n\n  this.stopAutocompaction();\n\n  this.autocompactionIntervalId = setInterval(function () {\n    self.compactDatafile();\n  }, realInterval);\n};\n\n\n/**\n * Stop autocompaction (do nothing if autocompaction was not running)\n */\nPersistence.prototype.stopAutocompaction = function () {\n  if (this.autocompactionIntervalId) { clearInterval(this.autocompactionIntervalId); }\n};\n\n\n/**\n * Persist new state for the given newDocs (can be insertion, update or removal)\n * Use an append-only format\n * @param {Array} newDocs Can be empty if no doc was updated/removed\n * @param {Function} cb Optional, signature: err\n */\nPersistence.prototype.persistNewState = function (newDocs, cb) {\n  var self = this\n    , toPersist = ''\n    , callback = cb || function () {}\n    ;\n\n  // In-memory only datastore\n  if (self.inMemoryOnly) { return callback(null); }\n\n  newDocs.forEach(function (doc) {\n    toPersist += self.afterSerialization(model.serialize(doc)) + '\\n';\n  });\n\n  if (toPersist.length === 0) { return callback(null); }\n\n  storage.appendFile(self.filename, toPersist, 'utf8', function (err) {\n    return callback(err);\n  });\n};\n\n\n/**\n * From a database's raw data, return the corresponding\n * machine understandable collection\n */\nPersistence.prototype.treatRawData = function (rawData) {\n  var data = rawData.split('\\n')\n    , dataById = {}\n    , tdata = []\n    , i\n    , indexes = {}\n    , corruptItems = -1   // Last line of every data file is usually blank so not really corrupt\n    ;\n\n  for (i = 0; i < data.length; i += 1) {\n    var doc;\n\n    try {\n      doc = model.deserialize(this.beforeDeserialization(data[i]));\n      if (doc._id) {\n        if (doc.$$deleted === true) {\n          delete dataById[doc._id];\n        } else {\n          dataById[doc._id] = doc;\n        }\n      } else if (doc.$$indexCreated && doc.$$indexCreated.fieldName != undefined) {\n        indexes[doc.$$indexCreated.fieldName] = doc.$$indexCreated;\n      } else if (typeof doc.$$indexRemoved === \"string\") {\n        delete indexes[doc.$$indexRemoved];\n      }\n    } catch (e) {\n      corruptItems += 1;\n    }\n  }\n\n  // A bit lenient on corruption\n  if (data.length > 0 && corruptItems / data.length > this.corruptAlertThreshold) {\n    throw new Error(\"More than \" + Math.floor(100 * this.corruptAlertThreshold) + \"% of the data file is corrupt, the wrong beforeDeserialization hook may be used. Cautiously refusing to start NeDB to prevent dataloss\");\n  }\n\n  Object.keys(dataById).forEach(function (k) {\n    tdata.push(dataById[k]);\n  });\n\n  return { data: tdata, indexes: indexes };\n};\n\n\n/**\n * Load the database\n * 1) Create all indexes\n * 2) Insert all data\n * 3) Compact the database\n * This means pulling data out of the data file or creating it if it doesn't exist\n * Also, all data is persisted right away, which has the effect of compacting the database file\n * This operation is very quick at startup for a big collection (60ms for ~10k docs)\n * @param {Function} cb Optional callback, signature: err\n */\nPersistence.prototype.loadDatabase = function (cb) {\n  var callback = cb || function () {}\n    , self = this\n    ;\n\n  self.db.resetIndexes();\n\n  // In-memory only datastore\n  if (self.inMemoryOnly) { return callback(null); }\n\n  async.waterfall([\n    function (cb) {\n      Persistence.ensureDirectoryExists(path.dirname(self.filename), function (err) {\n        storage.ensureDatafileIntegrity(self.filename, function (err) {\n          storage.readFile(self.filename, 'utf8', function (err, rawData) {\n            if (err) { return cb(err); }\n\n            try {\n              var treatedData = self.treatRawData(rawData);\n            } catch (e) {\n              return cb(e);\n            }\n\n            // Recreate all indexes in the datafile\n            Object.keys(treatedData.indexes).forEach(function (key) {\n              self.db.indexes[key] = new Index(treatedData.indexes[key]);\n            });\n\n            // Fill cached database (i.e. all indexes) with data\n            try {\n              self.db.resetIndexes(treatedData.data);\n            } catch (e) {\n              self.db.resetIndexes();   // Rollback any index which didn't fail\n              return cb(e);\n            }\n\n            self.db.persistence.persistCachedDatabase(cb);\n          });\n        });\n      });\n    }\n  ], function (err) {\n       if (err) { return callback(err); }\n\n       self.db.executor.processBuffer();\n       return callback(null);\n     });\n};\n\n\n// Interface\nmodule.exports = Persistence;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjguanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbmVkYi9saWIvcGVyc2lzdGVuY2UuanM/ZThiYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEhhbmRsZSBldmVyeSBwZXJzaXN0ZW5jZS1yZWxhdGVkIHRhc2tcbiAqIFRoZSBpbnRlcmZhY2UgRGF0YXN0b3JlIGV4cGVjdHMgdG8gYmUgaW1wbGVtZW50ZWQgaXNcbiAqICogUGVyc2lzdGVuY2UubG9hZERhdGFiYXNlKGNhbGxiYWNrKSBhbmQgY2FsbGJhY2sgaGFzIHNpZ25hdHVyZSBlcnJcbiAqICogUGVyc2lzdGVuY2UucGVyc2lzdE5ld1N0YXRlKG5ld0RvY3MsIGNhbGxiYWNrKSB3aGVyZSBuZXdEb2NzIGlzIGFuIGFycmF5IG9mIGRvY3VtZW50cyBhbmQgY2FsbGJhY2sgaGFzIHNpZ25hdHVyZSBlcnJcbiAqL1xuXG52YXIgc3RvcmFnZSA9IHJlcXVpcmUoJy4vc3RvcmFnZScpXG4gICwgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKVxuICAsIG1vZGVsID0gcmVxdWlyZSgnLi9tb2RlbCcpXG4gICwgYXN5bmMgPSByZXF1aXJlKCdhc3luYycpXG4gICwgY3VzdG9tVXRpbHMgPSByZXF1aXJlKCcuL2N1c3RvbVV0aWxzJylcbiAgLCBJbmRleCA9IHJlcXVpcmUoJy4vaW5kZXhlcycpXG4gIDtcblxuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBQZXJzaXN0ZW5jZSBvYmplY3QgZm9yIGRhdGFiYXNlIG9wdGlvbnMuZGJcbiAqIEBwYXJhbSB7RGF0YXN0b3JlfSBvcHRpb25zLmRiXG4gKiBAcGFyYW0ge0Jvb2xlYW59IG9wdGlvbnMubm9kZVdlYmtpdEFwcE5hbWUgT3B0aW9uYWwsIHNwZWNpZnkgdGhlIG5hbWUgb2YgeW91ciBOVyBhcHAgaWYgeW91IHdhbnQgb3B0aW9ucy5maWxlbmFtZSB0byBiZSByZWxhdGl2ZSB0byB0aGUgZGlyZWN0b3J5IHdoZXJlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTm9kZSBXZWJraXQgc3RvcmVzIGFwcGxpY2F0aW9uIGRhdGEgc3VjaCBhcyBjb29raWVzIGFuZCBsb2NhbCBzdG9yYWdlICh0aGUgYmVzdCBwbGFjZSB0byBzdG9yZSBkYXRhIGluIG15IG9waW5pb24pXG4gKi9cbmZ1bmN0aW9uIFBlcnNpc3RlbmNlIChvcHRpb25zKSB7XG4gIHZhciBpLCBqLCByYW5kb21TdHJpbmc7XG5cbiAgdGhpcy5kYiA9IG9wdGlvbnMuZGI7XG4gIHRoaXMuaW5NZW1vcnlPbmx5ID0gdGhpcy5kYi5pbk1lbW9yeU9ubHk7XG4gIHRoaXMuZmlsZW5hbWUgPSB0aGlzLmRiLmZpbGVuYW1lO1xuICB0aGlzLmNvcnJ1cHRBbGVydFRocmVzaG9sZCA9IG9wdGlvbnMuY29ycnVwdEFsZXJ0VGhyZXNob2xkICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmNvcnJ1cHRBbGVydFRocmVzaG9sZCA6IDAuMTtcblxuICBpZiAoIXRoaXMuaW5NZW1vcnlPbmx5ICYmIHRoaXMuZmlsZW5hbWUgJiYgdGhpcy5maWxlbmFtZS5jaGFyQXQodGhpcy5maWxlbmFtZS5sZW5ndGggLSAxKSA9PT0gJ34nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGRhdGFmaWxlIG5hbWUgY2FuJ3QgZW5kIHdpdGggYSB+LCB3aGljaCBpcyByZXNlcnZlZCBmb3IgY3Jhc2ggc2FmZSBiYWNrdXAgZmlsZXNcIik7XG4gIH1cblxuICAvLyBBZnRlciBzZXJpYWxpemF0aW9uIGFuZCBiZWZvcmUgZGVzZXJpYWxpemF0aW9uIGhvb2tzIHdpdGggc29tZSBiYXNpYyBzYW5pdHkgY2hlY2tzXG4gIGlmIChvcHRpb25zLmFmdGVyU2VyaWFsaXphdGlvbiAmJiAhb3B0aW9ucy5iZWZvcmVEZXNlcmlhbGl6YXRpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJTZXJpYWxpemF0aW9uIGhvb2sgZGVmaW5lZCBidXQgZGVzZXJpYWxpemF0aW9uIGhvb2sgdW5kZWZpbmVkLCBjYXV0aW91c2x5IHJlZnVzaW5nIHRvIHN0YXJ0IE5lREIgdG8gcHJldmVudCBkYXRhbG9zc1wiKTtcbiAgfVxuICBpZiAoIW9wdGlvbnMuYWZ0ZXJTZXJpYWxpemF0aW9uICYmIG9wdGlvbnMuYmVmb3JlRGVzZXJpYWxpemF0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiU2VyaWFsaXphdGlvbiBob29rIHVuZGVmaW5lZCBidXQgZGVzZXJpYWxpemF0aW9uIGhvb2sgZGVmaW5lZCwgY2F1dGlvdXNseSByZWZ1c2luZyB0byBzdGFydCBOZURCIHRvIHByZXZlbnQgZGF0YWxvc3NcIik7XG4gIH1cbiAgdGhpcy5hZnRlclNlcmlhbGl6YXRpb24gPSBvcHRpb25zLmFmdGVyU2VyaWFsaXphdGlvbiB8fCBmdW5jdGlvbiAocykgeyByZXR1cm4gczsgfTtcbiAgdGhpcy5iZWZvcmVEZXNlcmlhbGl6YXRpb24gPSBvcHRpb25zLmJlZm9yZURlc2VyaWFsaXphdGlvbiB8fCBmdW5jdGlvbiAocykgeyByZXR1cm4gczsgfTtcbiAgZm9yIChpID0gMTsgaSA8IDMwOyBpICs9IDEpIHtcbiAgICBmb3IgKGogPSAwOyBqIDwgMTA7IGogKz0gMSkge1xuICAgICAgcmFuZG9tU3RyaW5nID0gY3VzdG9tVXRpbHMudWlkKGkpO1xuICAgICAgaWYgKHRoaXMuYmVmb3JlRGVzZXJpYWxpemF0aW9uKHRoaXMuYWZ0ZXJTZXJpYWxpemF0aW9uKHJhbmRvbVN0cmluZykpICE9PSByYW5kb21TdHJpbmcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYmVmb3JlRGVzZXJpYWxpemF0aW9uIGlzIG5vdCB0aGUgcmV2ZXJzZSBvZiBhZnRlclNlcmlhbGl6YXRpb24sIGNhdXRpb3VzbHkgcmVmdXNpbmcgdG8gc3RhcnQgTmVEQiB0byBwcmV2ZW50IGRhdGFsb3NzXCIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIEZvciBOVyBhcHBzLCBzdG9yZSBkYXRhIGluIHRoZSBzYW1lIGRpcmVjdG9yeSB3aGVyZSBOVyBzdG9yZXMgYXBwbGljYXRpb24gZGF0YVxuICBpZiAodGhpcy5maWxlbmFtZSAmJiBvcHRpb25zLm5vZGVXZWJraXRBcHBOYW1lKSB7XG4gICAgY29uc29sZS5sb2coXCI9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cIik7XG4gICAgY29uc29sZS5sb2coXCJXQVJOSU5HOiBUaGUgbm9kZVdlYmtpdEFwcE5hbWUgb3B0aW9uIGlzIGRlcHJlY2F0ZWRcIik7XG4gICAgY29uc29sZS5sb2coXCJUbyBnZXQgdGhlIHBhdGggdG8gdGhlIGRpcmVjdG9yeSB3aGVyZSBOb2RlIFdlYmtpdCBzdG9yZXMgdGhlIGRhdGFcIik7XG4gICAgY29uc29sZS5sb2coXCJmb3IgeW91ciBhcHAsIHVzZSB0aGUgaW50ZXJuYWwgbncuZ3VpIG1vZHVsZSBsaWtlIHRoaXNcIik7XG4gICAgY29uc29sZS5sb2coXCJyZXF1aXJlKCdudy5ndWknKS5BcHAuZGF0YVBhdGhcIik7XG4gICAgY29uc29sZS5sb2coXCJTZWUgaHR0cHM6Ly9naXRodWIuY29tL3JvZ2Vyd2FuZy9ub2RlLXdlYmtpdC9pc3N1ZXMvNTAwXCIpO1xuICAgIGNvbnNvbGUubG9nKFwiPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XCIpO1xuICAgIHRoaXMuZmlsZW5hbWUgPSBQZXJzaXN0ZW5jZS5nZXROV0FwcEZpbGVuYW1lKG9wdGlvbnMubm9kZVdlYmtpdEFwcE5hbWUsIHRoaXMuZmlsZW5hbWUpO1xuICB9XG59O1xuXG5cbi8qKlxuICogQ2hlY2sgaWYgYSBkaXJlY3RvcnkgZXhpc3RzIGFuZCBjcmVhdGUgaXQgb24gdGhlIGZseSBpZiBpdCBpcyBub3QgdGhlIGNhc2VcbiAqIGNiIGlzIG9wdGlvbmFsLCBzaWduYXR1cmU6IGVyclxuICovXG5QZXJzaXN0ZW5jZS5lbnN1cmVEaXJlY3RvcnlFeGlzdHMgPSBmdW5jdGlvbiAoZGlyLCBjYikge1xuICB2YXIgY2FsbGJhY2sgPSBjYiB8fCBmdW5jdGlvbiAoKSB7fVxuICAgIDtcblxuICBzdG9yYWdlLm1rZGlycChkaXIsIGZ1bmN0aW9uIChlcnIpIHsgcmV0dXJuIGNhbGxiYWNrKGVycik7IH0pO1xufTtcblxuXG5cblxuLyoqXG4gKiBSZXR1cm4gdGhlIHBhdGggdGhlIGRhdGFmaWxlIGlmIHRoZSBnaXZlbiBmaWxlbmFtZSBpcyByZWxhdGl2ZSB0byB0aGUgZGlyZWN0b3J5IHdoZXJlIE5vZGUgV2Via2l0IHN0b3Jlc1xuICogZGF0YSBmb3IgdGhpcyBhcHBsaWNhdGlvbi4gUHJvYmFibHkgdGhlIGJlc3QgcGxhY2UgdG8gc3RvcmUgZGF0YVxuICovXG5QZXJzaXN0ZW5jZS5nZXROV0FwcEZpbGVuYW1lID0gZnVuY3Rpb24gKGFwcE5hbWUsIHJlbGF0aXZlRmlsZW5hbWUpIHtcbiAgdmFyIGhvbWU7XG5cbiAgc3dpdGNoIChwcm9jZXNzLnBsYXRmb3JtKSB7XG4gICAgY2FzZSAnd2luMzInOlxuICAgIGNhc2UgJ3dpbjY0JzpcbiAgICAgIGhvbWUgPSBwcm9jZXNzLmVudi5MT0NBTEFQUERBVEEgfHwgcHJvY2Vzcy5lbnYuQVBQREFUQTtcbiAgICAgIGlmICghaG9tZSkgeyB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZG4ndCBmaW5kIHRoZSBiYXNlIGFwcGxpY2F0aW9uIGRhdGEgZm9sZGVyXCIpOyB9XG4gICAgICBob21lID0gcGF0aC5qb2luKGhvbWUsIGFwcE5hbWUpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnZGFyd2luJzpcbiAgICAgIGhvbWUgPSBwcm9jZXNzLmVudi5IT01FO1xuICAgICAgaWYgKCFob21lKSB7IHRocm93IG5ldyBFcnJvcihcIkNvdWxkbid0IGZpbmQgdGhlIGJhc2UgYXBwbGljYXRpb24gZGF0YSBkaXJlY3RvcnlcIik7IH1cbiAgICAgIGhvbWUgPSBwYXRoLmpvaW4oaG9tZSwgJ0xpYnJhcnknLCAnQXBwbGljYXRpb24gU3VwcG9ydCcsIGFwcE5hbWUpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnbGludXgnOlxuICAgICAgaG9tZSA9IHByb2Nlc3MuZW52LkhPTUU7XG4gICAgICBpZiAoIWhvbWUpIHsgdGhyb3cgbmV3IEVycm9yKFwiQ291bGRuJ3QgZmluZCB0aGUgYmFzZSBhcHBsaWNhdGlvbiBkYXRhIGRpcmVjdG9yeVwiKTsgfVxuICAgICAgaG9tZSA9IHBhdGguam9pbihob21lLCAnLmNvbmZpZycsIGFwcE5hbWUpO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IHVzZSB0aGUgTm9kZSBXZWJraXQgcmVsYXRpdmUgcGF0aCBmb3IgcGxhdGZvcm0gXCIgKyBwcm9jZXNzLnBsYXRmb3JtKTtcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgcmV0dXJuIHBhdGguam9pbihob21lLCAnbmVkYi1kYXRhJywgcmVsYXRpdmVGaWxlbmFtZSk7XG59XG5cblxuLyoqXG4gKiBQZXJzaXN0IGNhY2hlZCBkYXRhYmFzZVxuICogVGhpcyBzZXJ2ZXMgYXMgYSBjb21wYWN0aW9uIGZ1bmN0aW9uIHNpbmNlIHRoZSBjYWNoZSBhbHdheXMgY29udGFpbnMgb25seSB0aGUgbnVtYmVyIG9mIGRvY3VtZW50cyBpbiB0aGUgY29sbGVjdGlvblxuICogd2hpbGUgdGhlIGRhdGEgZmlsZSBpcyBhcHBlbmQtb25seSBzbyBpdCBtYXkgZ3JvdyBsYXJnZXJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIE9wdGlvbmFsIGNhbGxiYWNrLCBzaWduYXR1cmU6IGVyclxuICovXG5QZXJzaXN0ZW5jZS5wcm90b3R5cGUucGVyc2lzdENhY2hlZERhdGFiYXNlID0gZnVuY3Rpb24gKGNiKSB7XG4gIHZhciBjYWxsYmFjayA9IGNiIHx8IGZ1bmN0aW9uICgpIHt9XG4gICAgLCB0b1BlcnNpc3QgPSAnJ1xuICAgICwgc2VsZiA9IHRoaXNcbiAgICA7XG5cbiAgaWYgKHRoaXMuaW5NZW1vcnlPbmx5KSB7IHJldHVybiBjYWxsYmFjayhudWxsKTsgfVxuXG4gIHRoaXMuZGIuZ2V0QWxsRGF0YSgpLmZvckVhY2goZnVuY3Rpb24gKGRvYykge1xuICAgIHRvUGVyc2lzdCArPSBzZWxmLmFmdGVyU2VyaWFsaXphdGlvbihtb2RlbC5zZXJpYWxpemUoZG9jKSkgKyAnXFxuJztcbiAgfSk7XG4gIE9iamVjdC5rZXlzKHRoaXMuZGIuaW5kZXhlcykuZm9yRWFjaChmdW5jdGlvbiAoZmllbGROYW1lKSB7XG4gICAgaWYgKGZpZWxkTmFtZSAhPSBcIl9pZFwiKSB7ICAgLy8gVGhlIHNwZWNpYWwgX2lkIGluZGV4IGlzIG1hbmFnZWQgYnkgZGF0YXN0b3JlLmpzLCB0aGUgb3RoZXJzIG5lZWQgdG8gYmUgcGVyc2lzdGVkXG4gICAgICB0b1BlcnNpc3QgKz0gc2VsZi5hZnRlclNlcmlhbGl6YXRpb24obW9kZWwuc2VyaWFsaXplKHsgJCRpbmRleENyZWF0ZWQ6IHsgZmllbGROYW1lOiBmaWVsZE5hbWUsIHVuaXF1ZTogc2VsZi5kYi5pbmRleGVzW2ZpZWxkTmFtZV0udW5pcXVlLCBzcGFyc2U6IHNlbGYuZGIuaW5kZXhlc1tmaWVsZE5hbWVdLnNwYXJzZSB9fSkpICsgJ1xcbic7XG4gICAgfVxuICB9KTtcblxuICBzdG9yYWdlLmNyYXNoU2FmZVdyaXRlRmlsZSh0aGlzLmZpbGVuYW1lLCB0b1BlcnNpc3QsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAoZXJyKSB7IHJldHVybiBjYWxsYmFjayhlcnIpOyB9XG4gICAgc2VsZi5kYi5lbWl0KCdjb21wYWN0aW9uLmRvbmUnKTtcbiAgICByZXR1cm4gY2FsbGJhY2sobnVsbCk7XG4gIH0pO1xufTtcblxuXG4vKipcbiAqIFF1ZXVlIGEgcmV3cml0ZSBvZiB0aGUgZGF0YWZpbGVcbiAqL1xuUGVyc2lzdGVuY2UucHJvdG90eXBlLmNvbXBhY3REYXRhZmlsZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5kYi5leGVjdXRvci5wdXNoKHsgdGhpczogdGhpcywgZm46IHRoaXMucGVyc2lzdENhY2hlZERhdGFiYXNlLCBhcmd1bWVudHM6IFtdIH0pO1xufTtcblxuXG4vKipcbiAqIFNldCBhdXRvbWF0aWMgY29tcGFjdGlvbiBldmVyeSBpbnRlcnZhbCBtc1xuICogQHBhcmFtIHtOdW1iZXJ9IGludGVydmFsIGluIG1pbGxpc2Vjb25kcywgd2l0aCBhbiBlbmZvcmNlZCBtaW5pbXVtIG9mIDUgc2Vjb25kc1xuICovXG5QZXJzaXN0ZW5jZS5wcm90b3R5cGUuc2V0QXV0b2NvbXBhY3Rpb25JbnRlcnZhbCA9IGZ1bmN0aW9uIChpbnRlcnZhbCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgICAsIG1pbkludGVydmFsID0gNTAwMFxuICAgICwgcmVhbEludGVydmFsID0gTWF0aC5tYXgoaW50ZXJ2YWwgfHwgMCwgbWluSW50ZXJ2YWwpXG4gICAgO1xuXG4gIHRoaXMuc3RvcEF1dG9jb21wYWN0aW9uKCk7XG5cbiAgdGhpcy5hdXRvY29tcGFjdGlvbkludGVydmFsSWQgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5jb21wYWN0RGF0YWZpbGUoKTtcbiAgfSwgcmVhbEludGVydmFsKTtcbn07XG5cblxuLyoqXG4gKiBTdG9wIGF1dG9jb21wYWN0aW9uIChkbyBub3RoaW5nIGlmIGF1dG9jb21wYWN0aW9uIHdhcyBub3QgcnVubmluZylcbiAqL1xuUGVyc2lzdGVuY2UucHJvdG90eXBlLnN0b3BBdXRvY29tcGFjdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuYXV0b2NvbXBhY3Rpb25JbnRlcnZhbElkKSB7IGNsZWFySW50ZXJ2YWwodGhpcy5hdXRvY29tcGFjdGlvbkludGVydmFsSWQpOyB9XG59O1xuXG5cbi8qKlxuICogUGVyc2lzdCBuZXcgc3RhdGUgZm9yIHRoZSBnaXZlbiBuZXdEb2NzIChjYW4gYmUgaW5zZXJ0aW9uLCB1cGRhdGUgb3IgcmVtb3ZhbClcbiAqIFVzZSBhbiBhcHBlbmQtb25seSBmb3JtYXRcbiAqIEBwYXJhbSB7QXJyYXl9IG5ld0RvY3MgQ2FuIGJlIGVtcHR5IGlmIG5vIGRvYyB3YXMgdXBkYXRlZC9yZW1vdmVkXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBPcHRpb25hbCwgc2lnbmF0dXJlOiBlcnJcbiAqL1xuUGVyc2lzdGVuY2UucHJvdG90eXBlLnBlcnNpc3ROZXdTdGF0ZSA9IGZ1bmN0aW9uIChuZXdEb2NzLCBjYikge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgICAsIHRvUGVyc2lzdCA9ICcnXG4gICAgLCBjYWxsYmFjayA9IGNiIHx8IGZ1bmN0aW9uICgpIHt9XG4gICAgO1xuXG4gIC8vIEluLW1lbW9yeSBvbmx5IGRhdGFzdG9yZVxuICBpZiAoc2VsZi5pbk1lbW9yeU9ubHkpIHsgcmV0dXJuIGNhbGxiYWNrKG51bGwpOyB9XG5cbiAgbmV3RG9jcy5mb3JFYWNoKGZ1bmN0aW9uIChkb2MpIHtcbiAgICB0b1BlcnNpc3QgKz0gc2VsZi5hZnRlclNlcmlhbGl6YXRpb24obW9kZWwuc2VyaWFsaXplKGRvYykpICsgJ1xcbic7XG4gIH0pO1xuXG4gIGlmICh0b1BlcnNpc3QubGVuZ3RoID09PSAwKSB7IHJldHVybiBjYWxsYmFjayhudWxsKTsgfVxuXG4gIHN0b3JhZ2UuYXBwZW5kRmlsZShzZWxmLmZpbGVuYW1lLCB0b1BlcnNpc3QsICd1dGY4JywgZnVuY3Rpb24gKGVycikge1xuICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICB9KTtcbn07XG5cblxuLyoqXG4gKiBGcm9tIGEgZGF0YWJhc2UncyByYXcgZGF0YSwgcmV0dXJuIHRoZSBjb3JyZXNwb25kaW5nXG4gKiBtYWNoaW5lIHVuZGVyc3RhbmRhYmxlIGNvbGxlY3Rpb25cbiAqL1xuUGVyc2lzdGVuY2UucHJvdG90eXBlLnRyZWF0UmF3RGF0YSA9IGZ1bmN0aW9uIChyYXdEYXRhKSB7XG4gIHZhciBkYXRhID0gcmF3RGF0YS5zcGxpdCgnXFxuJylcbiAgICAsIGRhdGFCeUlkID0ge31cbiAgICAsIHRkYXRhID0gW11cbiAgICAsIGlcbiAgICAsIGluZGV4ZXMgPSB7fVxuICAgICwgY29ycnVwdEl0ZW1zID0gLTEgICAvLyBMYXN0IGxpbmUgb2YgZXZlcnkgZGF0YSBmaWxlIGlzIHVzdWFsbHkgYmxhbmsgc28gbm90IHJlYWxseSBjb3JydXB0XG4gICAgO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgdmFyIGRvYztcblxuICAgIHRyeSB7XG4gICAgICBkb2MgPSBtb2RlbC5kZXNlcmlhbGl6ZSh0aGlzLmJlZm9yZURlc2VyaWFsaXphdGlvbihkYXRhW2ldKSk7XG4gICAgICBpZiAoZG9jLl9pZCkge1xuICAgICAgICBpZiAoZG9jLiQkZGVsZXRlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGRlbGV0ZSBkYXRhQnlJZFtkb2MuX2lkXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkYXRhQnlJZFtkb2MuX2lkXSA9IGRvYztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChkb2MuJCRpbmRleENyZWF0ZWQgJiYgZG9jLiQkaW5kZXhDcmVhdGVkLmZpZWxkTmFtZSAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgaW5kZXhlc1tkb2MuJCRpbmRleENyZWF0ZWQuZmllbGROYW1lXSA9IGRvYy4kJGluZGV4Q3JlYXRlZDtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGRvYy4kJGluZGV4UmVtb3ZlZCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBkZWxldGUgaW5kZXhlc1tkb2MuJCRpbmRleFJlbW92ZWRdO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvcnJ1cHRJdGVtcyArPSAxO1xuICAgIH1cbiAgfVxuXG4gIC8vIEEgYml0IGxlbmllbnQgb24gY29ycnVwdGlvblxuICBpZiAoZGF0YS5sZW5ndGggPiAwICYmIGNvcnJ1cHRJdGVtcyAvIGRhdGEubGVuZ3RoID4gdGhpcy5jb3JydXB0QWxlcnRUaHJlc2hvbGQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJNb3JlIHRoYW4gXCIgKyBNYXRoLmZsb29yKDEwMCAqIHRoaXMuY29ycnVwdEFsZXJ0VGhyZXNob2xkKSArIFwiJSBvZiB0aGUgZGF0YSBmaWxlIGlzIGNvcnJ1cHQsIHRoZSB3cm9uZyBiZWZvcmVEZXNlcmlhbGl6YXRpb24gaG9vayBtYXkgYmUgdXNlZC4gQ2F1dGlvdXNseSByZWZ1c2luZyB0byBzdGFydCBOZURCIHRvIHByZXZlbnQgZGF0YWxvc3NcIik7XG4gIH1cblxuICBPYmplY3Qua2V5cyhkYXRhQnlJZCkuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgIHRkYXRhLnB1c2goZGF0YUJ5SWRba10pO1xuICB9KTtcblxuICByZXR1cm4geyBkYXRhOiB0ZGF0YSwgaW5kZXhlczogaW5kZXhlcyB9O1xufTtcblxuXG4vKipcbiAqIExvYWQgdGhlIGRhdGFiYXNlXG4gKiAxKSBDcmVhdGUgYWxsIGluZGV4ZXNcbiAqIDIpIEluc2VydCBhbGwgZGF0YVxuICogMykgQ29tcGFjdCB0aGUgZGF0YWJhc2VcbiAqIFRoaXMgbWVhbnMgcHVsbGluZyBkYXRhIG91dCBvZiB0aGUgZGF0YSBmaWxlIG9yIGNyZWF0aW5nIGl0IGlmIGl0IGRvZXNuJ3QgZXhpc3RcbiAqIEFsc28sIGFsbCBkYXRhIGlzIHBlcnNpc3RlZCByaWdodCBhd2F5LCB3aGljaCBoYXMgdGhlIGVmZmVjdCBvZiBjb21wYWN0aW5nIHRoZSBkYXRhYmFzZSBmaWxlXG4gKiBUaGlzIG9wZXJhdGlvbiBpcyB2ZXJ5IHF1aWNrIGF0IHN0YXJ0dXAgZm9yIGEgYmlnIGNvbGxlY3Rpb24gKDYwbXMgZm9yIH4xMGsgZG9jcylcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIE9wdGlvbmFsIGNhbGxiYWNrLCBzaWduYXR1cmU6IGVyclxuICovXG5QZXJzaXN0ZW5jZS5wcm90b3R5cGUubG9hZERhdGFiYXNlID0gZnVuY3Rpb24gKGNiKSB7XG4gIHZhciBjYWxsYmFjayA9IGNiIHx8IGZ1bmN0aW9uICgpIHt9XG4gICAgLCBzZWxmID0gdGhpc1xuICAgIDtcblxuICBzZWxmLmRiLnJlc2V0SW5kZXhlcygpO1xuXG4gIC8vIEluLW1lbW9yeSBvbmx5IGRhdGFzdG9yZVxuICBpZiAoc2VsZi5pbk1lbW9yeU9ubHkpIHsgcmV0dXJuIGNhbGxiYWNrKG51bGwpOyB9XG5cbiAgYXN5bmMud2F0ZXJmYWxsKFtcbiAgICBmdW5jdGlvbiAoY2IpIHtcbiAgICAgIFBlcnNpc3RlbmNlLmVuc3VyZURpcmVjdG9yeUV4aXN0cyhwYXRoLmRpcm5hbWUoc2VsZi5maWxlbmFtZSksIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgc3RvcmFnZS5lbnN1cmVEYXRhZmlsZUludGVncml0eShzZWxmLmZpbGVuYW1lLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgc3RvcmFnZS5yZWFkRmlsZShzZWxmLmZpbGVuYW1lLCAndXRmOCcsIGZ1bmN0aW9uIChlcnIsIHJhd0RhdGEpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIHsgcmV0dXJuIGNiKGVycik7IH1cblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgdmFyIHRyZWF0ZWREYXRhID0gc2VsZi50cmVhdFJhd0RhdGEocmF3RGF0YSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjYihlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUmVjcmVhdGUgYWxsIGluZGV4ZXMgaW4gdGhlIGRhdGFmaWxlXG4gICAgICAgICAgICBPYmplY3Qua2V5cyh0cmVhdGVkRGF0YS5pbmRleGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgc2VsZi5kYi5pbmRleGVzW2tleV0gPSBuZXcgSW5kZXgodHJlYXRlZERhdGEuaW5kZXhlc1trZXldKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBGaWxsIGNhY2hlZCBkYXRhYmFzZSAoaS5lLiBhbGwgaW5kZXhlcykgd2l0aCBkYXRhXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBzZWxmLmRiLnJlc2V0SW5kZXhlcyh0cmVhdGVkRGF0YS5kYXRhKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgc2VsZi5kYi5yZXNldEluZGV4ZXMoKTsgICAvLyBSb2xsYmFjayBhbnkgaW5kZXggd2hpY2ggZGlkbid0IGZhaWxcbiAgICAgICAgICAgICAgcmV0dXJuIGNiKGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzZWxmLmRiLnBlcnNpc3RlbmNlLnBlcnNpc3RDYWNoZWREYXRhYmFzZShjYik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICBdLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgaWYgKGVycikgeyByZXR1cm4gY2FsbGJhY2soZXJyKTsgfVxuXG4gICAgICAgc2VsZi5kYi5leGVjdXRvci5wcm9jZXNzQnVmZmVyKCk7XG4gICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwpO1xuICAgICB9KTtcbn07XG5cblxuLy8gSW50ZXJmYWNlXG5tb2R1bGUuZXhwb3J0cyA9IFBlcnNpc3RlbmNlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbmVkYi9saWIvcGVyc2lzdGVuY2UuanNcbi8vIG1vZHVsZSBpZCA9IDI4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///28\n");

/***/ }),
/* 29 */
/*!******************************************!*\
  !*** ./node_modules/nedb/lib/storage.js ***!
  \******************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * Way data is stored for this database\n * For a Node.js/Node Webkit database it's the file system\n * For a browser-side database it's localforage which chooses the best option depending on user browser (IndexedDB then WebSQL then localStorage)\n *\n * This version is the Node.js/Node Webkit version\n * It's essentially fs, mkdirp and crash safe write and read functions\n */\n\nvar fs = __webpack_require__(/*! fs */ 11)\n  , mkdirp = __webpack_require__(/*! mkdirp */ 30)\n  , async = __webpack_require__(/*! async */ 6)\n  , path = __webpack_require__(/*! path */ 2)\n  , storage = {}\n  ;\n\nstorage.exists = fs.exists;\nstorage.rename = fs.rename;\nstorage.writeFile = fs.writeFile;\nstorage.unlink = fs.unlink;\nstorage.appendFile = fs.appendFile;\nstorage.readFile = fs.readFile;\nstorage.mkdirp = mkdirp;\n\n\n/**\n * Explicit name ...\n */\nstorage.ensureFileDoesntExist = function (file, callback) {\n  storage.exists(file, function (exists) {\n    if (!exists) { return callback(null); }\n\n    storage.unlink(file, function (err) { return callback(err); });\n  });\n};\n\n\n/**\n * Flush data in OS buffer to storage if corresponding option is set\n * @param {String} options.filename\n * @param {Boolean} options.isDir Optional, defaults to false\n * If options is a string, it is assumed that the flush of the file (not dir) called options was requested\n */\nstorage.flushToStorage = function (options, callback) {\n  var filename, flags;\n  if (typeof options === 'string') {\n    filename = options;\n    flags = 'r+';\n  } else {\n    filename = options.filename;\n    flags = options.isDir ? 'r' : 'r+';\n  }\n\n  // Windows can't fsync (FlushFileBuffers) directories. We can live with this as it cannot cause 100% dataloss\n  // except in the very rare event of the first time database is loaded and a crash happens\n  if (flags === 'r' && (process.platform === 'win32' || process.platform === 'win64')) { return callback(null); }\n\n  fs.open(filename, flags, function (err, fd) {\n    if (err) { return callback(err); }\n    fs.fsync(fd, function (errFS) {\n      fs.close(fd, function (errC) {\n        if (errFS || errC) {\n          var e = new Error('Failed to flush to storage');\n          e.errorOnFsync = errFS;\n          e.errorOnClose = errC;\n          return callback(e);\n        } else {\n          return callback(null);\n        }\n      });\n    });\n  });\n};\n\n\n/**\n * Fully write or rewrite the datafile, immune to crashes during the write operation (data will not be lost)\n * @param {String} filename\n * @param {String} data\n * @param {Function} cb Optional callback, signature: err\n */\nstorage.crashSafeWriteFile = function (filename, data, cb) {\n  var callback = cb || function () {}\n    , tempFilename = filename + '~';\n\n  async.waterfall([\n    async.apply(storage.flushToStorage, { filename: path.dirname(filename), isDir: true })\n  , function (cb) {\n      storage.exists(filename, function (exists) {\n        if (exists) {\n          storage.flushToStorage(filename, function (err) { return cb(err); });\n        } else {\n          return cb();\n        }\n      });\n    }\n  , function (cb) {\n      storage.writeFile(tempFilename, data, function (err) { return cb(err); });\n    }\n  , async.apply(storage.flushToStorage, tempFilename)\n  , function (cb) {\n      storage.rename(tempFilename, filename, function (err) { return cb(err); });\n    }\n  , async.apply(storage.flushToStorage, { filename: path.dirname(filename), isDir: true })\n  ], function (err) { return callback(err); })\n};\n\n\n/**\n * Ensure the datafile contains all the data, even if there was a crash during a full file write\n * @param {String} filename\n * @param {Function} callback signature: err\n */\nstorage.ensureDatafileIntegrity = function (filename, callback) {\n  var tempFilename = filename + '~';\n\n  storage.exists(filename, function (filenameExists) {\n    // Write was successful\n    if (filenameExists) { return callback(null); }\n\n    storage.exists(tempFilename, function (oldFilenameExists) {\n      // New database\n      if (!oldFilenameExists) {\n        return storage.writeFile(filename, '', 'utf8', function (err) { callback(err); });\n      }\n\n      // Write failed, use old version\n      storage.rename(tempFilename, filename, function (err) { return callback(err); });\n    });\n  });\n};\n\n\n\n// Interface\nmodule.exports = storage;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjkuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbmVkYi9saWIvc3RvcmFnZS5qcz9jMjM4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogV2F5IGRhdGEgaXMgc3RvcmVkIGZvciB0aGlzIGRhdGFiYXNlXG4gKiBGb3IgYSBOb2RlLmpzL05vZGUgV2Via2l0IGRhdGFiYXNlIGl0J3MgdGhlIGZpbGUgc3lzdGVtXG4gKiBGb3IgYSBicm93c2VyLXNpZGUgZGF0YWJhc2UgaXQncyBsb2NhbGZvcmFnZSB3aGljaCBjaG9vc2VzIHRoZSBiZXN0IG9wdGlvbiBkZXBlbmRpbmcgb24gdXNlciBicm93c2VyIChJbmRleGVkREIgdGhlbiBXZWJTUUwgdGhlbiBsb2NhbFN0b3JhZ2UpXG4gKlxuICogVGhpcyB2ZXJzaW9uIGlzIHRoZSBOb2RlLmpzL05vZGUgV2Via2l0IHZlcnNpb25cbiAqIEl0J3MgZXNzZW50aWFsbHkgZnMsIG1rZGlycCBhbmQgY3Jhc2ggc2FmZSB3cml0ZSBhbmQgcmVhZCBmdW5jdGlvbnNcbiAqL1xuXG52YXIgZnMgPSByZXF1aXJlKCdmcycpXG4gICwgbWtkaXJwID0gcmVxdWlyZSgnbWtkaXJwJylcbiAgLCBhc3luYyA9IHJlcXVpcmUoJ2FzeW5jJylcbiAgLCBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG4gICwgc3RvcmFnZSA9IHt9XG4gIDtcblxuc3RvcmFnZS5leGlzdHMgPSBmcy5leGlzdHM7XG5zdG9yYWdlLnJlbmFtZSA9IGZzLnJlbmFtZTtcbnN0b3JhZ2Uud3JpdGVGaWxlID0gZnMud3JpdGVGaWxlO1xuc3RvcmFnZS51bmxpbmsgPSBmcy51bmxpbms7XG5zdG9yYWdlLmFwcGVuZEZpbGUgPSBmcy5hcHBlbmRGaWxlO1xuc3RvcmFnZS5yZWFkRmlsZSA9IGZzLnJlYWRGaWxlO1xuc3RvcmFnZS5ta2RpcnAgPSBta2RpcnA7XG5cblxuLyoqXG4gKiBFeHBsaWNpdCBuYW1lIC4uLlxuICovXG5zdG9yYWdlLmVuc3VyZUZpbGVEb2VzbnRFeGlzdCA9IGZ1bmN0aW9uIChmaWxlLCBjYWxsYmFjaykge1xuICBzdG9yYWdlLmV4aXN0cyhmaWxlLCBmdW5jdGlvbiAoZXhpc3RzKSB7XG4gICAgaWYgKCFleGlzdHMpIHsgcmV0dXJuIGNhbGxiYWNrKG51bGwpOyB9XG5cbiAgICBzdG9yYWdlLnVubGluayhmaWxlLCBmdW5jdGlvbiAoZXJyKSB7IHJldHVybiBjYWxsYmFjayhlcnIpOyB9KTtcbiAgfSk7XG59O1xuXG5cbi8qKlxuICogRmx1c2ggZGF0YSBpbiBPUyBidWZmZXIgdG8gc3RvcmFnZSBpZiBjb3JyZXNwb25kaW5nIG9wdGlvbiBpcyBzZXRcbiAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLmZpbGVuYW1lXG4gKiBAcGFyYW0ge0Jvb2xlYW59IG9wdGlvbnMuaXNEaXIgT3B0aW9uYWwsIGRlZmF1bHRzIHRvIGZhbHNlXG4gKiBJZiBvcHRpb25zIGlzIGEgc3RyaW5nLCBpdCBpcyBhc3N1bWVkIHRoYXQgdGhlIGZsdXNoIG9mIHRoZSBmaWxlIChub3QgZGlyKSBjYWxsZWQgb3B0aW9ucyB3YXMgcmVxdWVzdGVkXG4gKi9cbnN0b3JhZ2UuZmx1c2hUb1N0b3JhZ2UgPSBmdW5jdGlvbiAob3B0aW9ucywgY2FsbGJhY2spIHtcbiAgdmFyIGZpbGVuYW1lLCBmbGFncztcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJykge1xuICAgIGZpbGVuYW1lID0gb3B0aW9ucztcbiAgICBmbGFncyA9ICdyKyc7XG4gIH0gZWxzZSB7XG4gICAgZmlsZW5hbWUgPSBvcHRpb25zLmZpbGVuYW1lO1xuICAgIGZsYWdzID0gb3B0aW9ucy5pc0RpciA/ICdyJyA6ICdyKyc7XG4gIH1cblxuICAvLyBXaW5kb3dzIGNhbid0IGZzeW5jIChGbHVzaEZpbGVCdWZmZXJzKSBkaXJlY3Rvcmllcy4gV2UgY2FuIGxpdmUgd2l0aCB0aGlzIGFzIGl0IGNhbm5vdCBjYXVzZSAxMDAlIGRhdGFsb3NzXG4gIC8vIGV4Y2VwdCBpbiB0aGUgdmVyeSByYXJlIGV2ZW50IG9mIHRoZSBmaXJzdCB0aW1lIGRhdGFiYXNlIGlzIGxvYWRlZCBhbmQgYSBjcmFzaCBoYXBwZW5zXG4gIGlmIChmbGFncyA9PT0gJ3InICYmIChwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInIHx8IHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW42NCcpKSB7IHJldHVybiBjYWxsYmFjayhudWxsKTsgfVxuXG4gIGZzLm9wZW4oZmlsZW5hbWUsIGZsYWdzLCBmdW5jdGlvbiAoZXJyLCBmZCkge1xuICAgIGlmIChlcnIpIHsgcmV0dXJuIGNhbGxiYWNrKGVycik7IH1cbiAgICBmcy5mc3luYyhmZCwgZnVuY3Rpb24gKGVyckZTKSB7XG4gICAgICBmcy5jbG9zZShmZCwgZnVuY3Rpb24gKGVyckMpIHtcbiAgICAgICAgaWYgKGVyckZTIHx8IGVyckMpIHtcbiAgICAgICAgICB2YXIgZSA9IG5ldyBFcnJvcignRmFpbGVkIHRvIGZsdXNoIHRvIHN0b3JhZ2UnKTtcbiAgICAgICAgICBlLmVycm9yT25Gc3luYyA9IGVyckZTO1xuICAgICAgICAgIGUuZXJyb3JPbkNsb3NlID0gZXJyQztcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG59O1xuXG5cbi8qKlxuICogRnVsbHkgd3JpdGUgb3IgcmV3cml0ZSB0aGUgZGF0YWZpbGUsIGltbXVuZSB0byBjcmFzaGVzIGR1cmluZyB0aGUgd3JpdGUgb3BlcmF0aW9uIChkYXRhIHdpbGwgbm90IGJlIGxvc3QpXG4gKiBAcGFyYW0ge1N0cmluZ30gZmlsZW5hbWVcbiAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBPcHRpb25hbCBjYWxsYmFjaywgc2lnbmF0dXJlOiBlcnJcbiAqL1xuc3RvcmFnZS5jcmFzaFNhZmVXcml0ZUZpbGUgPSBmdW5jdGlvbiAoZmlsZW5hbWUsIGRhdGEsIGNiKSB7XG4gIHZhciBjYWxsYmFjayA9IGNiIHx8IGZ1bmN0aW9uICgpIHt9XG4gICAgLCB0ZW1wRmlsZW5hbWUgPSBmaWxlbmFtZSArICd+JztcblxuICBhc3luYy53YXRlcmZhbGwoW1xuICAgIGFzeW5jLmFwcGx5KHN0b3JhZ2UuZmx1c2hUb1N0b3JhZ2UsIHsgZmlsZW5hbWU6IHBhdGguZGlybmFtZShmaWxlbmFtZSksIGlzRGlyOiB0cnVlIH0pXG4gICwgZnVuY3Rpb24gKGNiKSB7XG4gICAgICBzdG9yYWdlLmV4aXN0cyhmaWxlbmFtZSwgZnVuY3Rpb24gKGV4aXN0cykge1xuICAgICAgICBpZiAoZXhpc3RzKSB7XG4gICAgICAgICAgc3RvcmFnZS5mbHVzaFRvU3RvcmFnZShmaWxlbmFtZSwgZnVuY3Rpb24gKGVycikgeyByZXR1cm4gY2IoZXJyKTsgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGNiKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgLCBmdW5jdGlvbiAoY2IpIHtcbiAgICAgIHN0b3JhZ2Uud3JpdGVGaWxlKHRlbXBGaWxlbmFtZSwgZGF0YSwgZnVuY3Rpb24gKGVycikgeyByZXR1cm4gY2IoZXJyKTsgfSk7XG4gICAgfVxuICAsIGFzeW5jLmFwcGx5KHN0b3JhZ2UuZmx1c2hUb1N0b3JhZ2UsIHRlbXBGaWxlbmFtZSlcbiAgLCBmdW5jdGlvbiAoY2IpIHtcbiAgICAgIHN0b3JhZ2UucmVuYW1lKHRlbXBGaWxlbmFtZSwgZmlsZW5hbWUsIGZ1bmN0aW9uIChlcnIpIHsgcmV0dXJuIGNiKGVycik7IH0pO1xuICAgIH1cbiAgLCBhc3luYy5hcHBseShzdG9yYWdlLmZsdXNoVG9TdG9yYWdlLCB7IGZpbGVuYW1lOiBwYXRoLmRpcm5hbWUoZmlsZW5hbWUpLCBpc0RpcjogdHJ1ZSB9KVxuICBdLCBmdW5jdGlvbiAoZXJyKSB7IHJldHVybiBjYWxsYmFjayhlcnIpOyB9KVxufTtcblxuXG4vKipcbiAqIEVuc3VyZSB0aGUgZGF0YWZpbGUgY29udGFpbnMgYWxsIHRoZSBkYXRhLCBldmVuIGlmIHRoZXJlIHdhcyBhIGNyYXNoIGR1cmluZyBhIGZ1bGwgZmlsZSB3cml0ZVxuICogQHBhcmFtIHtTdHJpbmd9IGZpbGVuYW1lXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBzaWduYXR1cmU6IGVyclxuICovXG5zdG9yYWdlLmVuc3VyZURhdGFmaWxlSW50ZWdyaXR5ID0gZnVuY3Rpb24gKGZpbGVuYW1lLCBjYWxsYmFjaykge1xuICB2YXIgdGVtcEZpbGVuYW1lID0gZmlsZW5hbWUgKyAnfic7XG5cbiAgc3RvcmFnZS5leGlzdHMoZmlsZW5hbWUsIGZ1bmN0aW9uIChmaWxlbmFtZUV4aXN0cykge1xuICAgIC8vIFdyaXRlIHdhcyBzdWNjZXNzZnVsXG4gICAgaWYgKGZpbGVuYW1lRXhpc3RzKSB7IHJldHVybiBjYWxsYmFjayhudWxsKTsgfVxuXG4gICAgc3RvcmFnZS5leGlzdHModGVtcEZpbGVuYW1lLCBmdW5jdGlvbiAob2xkRmlsZW5hbWVFeGlzdHMpIHtcbiAgICAgIC8vIE5ldyBkYXRhYmFzZVxuICAgICAgaWYgKCFvbGRGaWxlbmFtZUV4aXN0cykge1xuICAgICAgICByZXR1cm4gc3RvcmFnZS53cml0ZUZpbGUoZmlsZW5hbWUsICcnLCAndXRmOCcsIGZ1bmN0aW9uIChlcnIpIHsgY2FsbGJhY2soZXJyKTsgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFdyaXRlIGZhaWxlZCwgdXNlIG9sZCB2ZXJzaW9uXG4gICAgICBzdG9yYWdlLnJlbmFtZSh0ZW1wRmlsZW5hbWUsIGZpbGVuYW1lLCBmdW5jdGlvbiAoZXJyKSB7IHJldHVybiBjYWxsYmFjayhlcnIpOyB9KTtcbiAgICB9KTtcbiAgfSk7XG59O1xuXG5cblxuLy8gSW50ZXJmYWNlXG5tb2R1bGUuZXhwb3J0cyA9IHN0b3JhZ2U7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9uZWRiL2xpYi9zdG9yYWdlLmpzXG4vLyBtb2R1bGUgaWQgPSAyOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///29\n");

/***/ }),
/* 30 */
/*!**************************************!*\
  !*** ./node_modules/mkdirp/index.js ***!
  \**************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

eval("var path = __webpack_require__(/*! path */ 2);\nvar fs = __webpack_require__(/*! fs */ 11);\nvar _0777 = parseInt('0777', 8);\n\nmodule.exports = mkdirP.mkdirp = mkdirP.mkdirP = mkdirP;\n\nfunction mkdirP (p, opts, f, made) {\n    if (typeof opts === 'function') {\n        f = opts;\n        opts = {};\n    }\n    else if (!opts || typeof opts !== 'object') {\n        opts = { mode: opts };\n    }\n    \n    var mode = opts.mode;\n    var xfs = opts.fs || fs;\n    \n    if (mode === undefined) {\n        mode = _0777 & (~process.umask());\n    }\n    if (!made) made = null;\n    \n    var cb = f || function () {};\n    p = path.resolve(p);\n    \n    xfs.mkdir(p, mode, function (er) {\n        if (!er) {\n            made = made || p;\n            return cb(null, made);\n        }\n        switch (er.code) {\n            case 'ENOENT':\n                mkdirP(path.dirname(p), opts, function (er, made) {\n                    if (er) cb(er, made);\n                    else mkdirP(p, opts, cb, made);\n                });\n                break;\n\n            // In the case of any other error, just see if there's a dir\n            // there already.  If so, then hooray!  If not, then something\n            // is borked.\n            default:\n                xfs.stat(p, function (er2, stat) {\n                    // if the stat fails, then that's super weird.\n                    // let the original error be the failure reason.\n                    if (er2 || !stat.isDirectory()) cb(er, made)\n                    else cb(null, made);\n                });\n                break;\n        }\n    });\n}\n\nmkdirP.sync = function sync (p, opts, made) {\n    if (!opts || typeof opts !== 'object') {\n        opts = { mode: opts };\n    }\n    \n    var mode = opts.mode;\n    var xfs = opts.fs || fs;\n    \n    if (mode === undefined) {\n        mode = _0777 & (~process.umask());\n    }\n    if (!made) made = null;\n\n    p = path.resolve(p);\n\n    try {\n        xfs.mkdirSync(p, mode);\n        made = made || p;\n    }\n    catch (err0) {\n        switch (err0.code) {\n            case 'ENOENT' :\n                made = sync(path.dirname(p), opts, made);\n                sync(p, opts, made);\n                break;\n\n            // In the case of any other error, just see if there's a dir\n            // there already.  If so, then hooray!  If not, then something\n            // is borked.\n            default:\n                var stat;\n                try {\n                    stat = xfs.statSync(p);\n                }\n                catch (err1) {\n                    throw err0;\n                }\n                if (!stat.isDirectory()) throw err0;\n                break;\n        }\n    }\n\n    return made;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWtkaXJwL2luZGV4LmpzPzU0MzMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG52YXIgZnMgPSByZXF1aXJlKCdmcycpO1xudmFyIF8wNzc3ID0gcGFyc2VJbnQoJzA3NzcnLCA4KTtcblxubW9kdWxlLmV4cG9ydHMgPSBta2RpclAubWtkaXJwID0gbWtkaXJQLm1rZGlyUCA9IG1rZGlyUDtcblxuZnVuY3Rpb24gbWtkaXJQIChwLCBvcHRzLCBmLCBtYWRlKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGYgPSBvcHRzO1xuICAgICAgICBvcHRzID0ge307XG4gICAgfVxuICAgIGVsc2UgaWYgKCFvcHRzIHx8IHR5cGVvZiBvcHRzICE9PSAnb2JqZWN0Jykge1xuICAgICAgICBvcHRzID0geyBtb2RlOiBvcHRzIH07XG4gICAgfVxuICAgIFxuICAgIHZhciBtb2RlID0gb3B0cy5tb2RlO1xuICAgIHZhciB4ZnMgPSBvcHRzLmZzIHx8IGZzO1xuICAgIFxuICAgIGlmIChtb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbW9kZSA9IF8wNzc3ICYgKH5wcm9jZXNzLnVtYXNrKCkpO1xuICAgIH1cbiAgICBpZiAoIW1hZGUpIG1hZGUgPSBudWxsO1xuICAgIFxuICAgIHZhciBjYiA9IGYgfHwgZnVuY3Rpb24gKCkge307XG4gICAgcCA9IHBhdGgucmVzb2x2ZShwKTtcbiAgICBcbiAgICB4ZnMubWtkaXIocCwgbW9kZSwgZnVuY3Rpb24gKGVyKSB7XG4gICAgICAgIGlmICghZXIpIHtcbiAgICAgICAgICAgIG1hZGUgPSBtYWRlIHx8IHA7XG4gICAgICAgICAgICByZXR1cm4gY2IobnVsbCwgbWFkZSk7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChlci5jb2RlKSB7XG4gICAgICAgICAgICBjYXNlICdFTk9FTlQnOlxuICAgICAgICAgICAgICAgIG1rZGlyUChwYXRoLmRpcm5hbWUocCksIG9wdHMsIGZ1bmN0aW9uIChlciwgbWFkZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXIpIGNiKGVyLCBtYWRlKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBta2RpclAocCwgb3B0cywgY2IsIG1hZGUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAvLyBJbiB0aGUgY2FzZSBvZiBhbnkgb3RoZXIgZXJyb3IsIGp1c3Qgc2VlIGlmIHRoZXJlJ3MgYSBkaXJcbiAgICAgICAgICAgIC8vIHRoZXJlIGFscmVhZHkuICBJZiBzbywgdGhlbiBob29yYXkhICBJZiBub3QsIHRoZW4gc29tZXRoaW5nXG4gICAgICAgICAgICAvLyBpcyBib3JrZWQuXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHhmcy5zdGF0KHAsIGZ1bmN0aW9uIChlcjIsIHN0YXQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIHN0YXQgZmFpbHMsIHRoZW4gdGhhdCdzIHN1cGVyIHdlaXJkLlxuICAgICAgICAgICAgICAgICAgICAvLyBsZXQgdGhlIG9yaWdpbmFsIGVycm9yIGJlIHRoZSBmYWlsdXJlIHJlYXNvbi5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGVyMiB8fCAhc3RhdC5pc0RpcmVjdG9yeSgpKSBjYihlciwgbWFkZSlcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBjYihudWxsLCBtYWRlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG5ta2RpclAuc3luYyA9IGZ1bmN0aW9uIHN5bmMgKHAsIG9wdHMsIG1hZGUpIHtcbiAgICBpZiAoIW9wdHMgfHwgdHlwZW9mIG9wdHMgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIG9wdHMgPSB7IG1vZGU6IG9wdHMgfTtcbiAgICB9XG4gICAgXG4gICAgdmFyIG1vZGUgPSBvcHRzLm1vZGU7XG4gICAgdmFyIHhmcyA9IG9wdHMuZnMgfHwgZnM7XG4gICAgXG4gICAgaWYgKG1vZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBtb2RlID0gXzA3NzcgJiAofnByb2Nlc3MudW1hc2soKSk7XG4gICAgfVxuICAgIGlmICghbWFkZSkgbWFkZSA9IG51bGw7XG5cbiAgICBwID0gcGF0aC5yZXNvbHZlKHApO1xuXG4gICAgdHJ5IHtcbiAgICAgICAgeGZzLm1rZGlyU3luYyhwLCBtb2RlKTtcbiAgICAgICAgbWFkZSA9IG1hZGUgfHwgcDtcbiAgICB9XG4gICAgY2F0Y2ggKGVycjApIHtcbiAgICAgICAgc3dpdGNoIChlcnIwLmNvZGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ0VOT0VOVCcgOlxuICAgICAgICAgICAgICAgIG1hZGUgPSBzeW5jKHBhdGguZGlybmFtZShwKSwgb3B0cywgbWFkZSk7XG4gICAgICAgICAgICAgICAgc3luYyhwLCBvcHRzLCBtYWRlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgLy8gSW4gdGhlIGNhc2Ugb2YgYW55IG90aGVyIGVycm9yLCBqdXN0IHNlZSBpZiB0aGVyZSdzIGEgZGlyXG4gICAgICAgICAgICAvLyB0aGVyZSBhbHJlYWR5LiAgSWYgc28sIHRoZW4gaG9vcmF5ISAgSWYgbm90LCB0aGVuIHNvbWV0aGluZ1xuICAgICAgICAgICAgLy8gaXMgYm9ya2VkLlxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB2YXIgc3RhdDtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ID0geGZzLnN0YXRTeW5jKHApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyMSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnIwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXN0YXQuaXNEaXJlY3RvcnkoKSkgdGhyb3cgZXJyMDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtYWRlO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21rZGlycC9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///30\n");

/***/ }),
/* 31 */
/*!*****************************************!*\
  !*** ./node_modules/nedb/lib/cursor.js ***!
  \*****************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * Manage access to data, be it to find, update or remove it\n */\nvar model = __webpack_require__(/*! ./model */ 4)\n  , _ = __webpack_require__(/*! underscore */ 1)\n  ;\n\n\n\n/**\n * Create a new cursor for this collection\n * @param {Datastore} db - The datastore this cursor is bound to\n * @param {Query} query - The query this cursor will operate on\n * @param {Function} execFn - Handler to be executed after cursor has found the results and before the callback passed to find/findOne/update/remove\n */\nfunction Cursor (db, query, execFn) {\n  this.db = db;\n  this.query = query || {};\n  if (execFn) { this.execFn = execFn; }\n}\n\n\n/**\n * Set a limit to the number of results\n */\nCursor.prototype.limit = function(limit) {\n  this._limit = limit;\n  return this;\n};\n\n\n/**\n * Skip a the number of results\n */\nCursor.prototype.skip = function(skip) {\n  this._skip = skip;\n  return this;\n};\n\n\n/**\n * Sort results of the query\n * @param {SortQuery} sortQuery - SortQuery is { field: order }, field can use the dot-notation, order is 1 for ascending and -1 for descending\n */\nCursor.prototype.sort = function(sortQuery) {\n  this._sort = sortQuery;\n  return this;\n};\n\n\n/**\n * Add the use of a projection\n * @param {Object} projection - MongoDB-style projection. {} means take all fields. Then it's { key1: 1, key2: 1 } to take only key1 and key2\n *                              { key1: 0, key2: 0 } to omit only key1 and key2. Except _id, you can't mix takes and omits\n */\nCursor.prototype.projection = function(projection) {\n  this._projection = projection;\n  return this;\n};\n\n\n/**\n * Apply the projection\n */\nCursor.prototype.project = function (candidates) {\n  var res = [], self = this\n    , keepId, action, keys\n    ;\n\n  if (this._projection === undefined || Object.keys(this._projection).length === 0) {\n    return candidates;\n  }\n\n  keepId = this._projection._id === 0 ? false : true;\n  this._projection = _.omit(this._projection, '_id');\n\n  // Check for consistency\n  keys = Object.keys(this._projection);\n  keys.forEach(function (k) {\n    if (action !== undefined && self._projection[k] !== action) { throw new Error(\"Can't both keep and omit fields except for _id\"); }\n    action = self._projection[k];\n  });\n\n  // Do the actual projection\n  candidates.forEach(function (candidate) {\n    var toPush;\n    if (action === 1) {   // pick-type projection\n      toPush = { $set: {} };\n      keys.forEach(function (k) {\n        toPush.$set[k] = model.getDotValue(candidate, k);\n        if (toPush.$set[k] === undefined) { delete toPush.$set[k]; }\n      });\n      toPush = model.modify({}, toPush);\n    } else {   // omit-type projection\n      toPush = { $unset: {} };\n      keys.forEach(function (k) { toPush.$unset[k] = true });\n      toPush = model.modify(candidate, toPush);\n    }\n    if (keepId) {\n      toPush._id = candidate._id;\n    } else {\n      delete toPush._id;\n    }\n    res.push(toPush);\n  });\n\n  return res;\n};\n\n\n/**\n * Get all matching elements\n * Will return pointers to matched elements (shallow copies), returning full copies is the role of find or findOne\n * This is an internal function, use exec which uses the executor\n *\n * @param {Function} callback - Signature: err, results\n */\nCursor.prototype._exec = function(_callback) {\n  var res = [], added = 0, skipped = 0, self = this\n    , error = null\n    , i, keys, key\n    ;\n\n  function callback (error, res) {\n    if (self.execFn) {\n      return self.execFn(error, res, _callback);\n    } else {\n      return _callback(error, res);\n    }\n  }\n\n  this.db.getCandidates(this.query, function (err, candidates) {\n    if (err) { return callback(err); }\n\n    try {\n      for (i = 0; i < candidates.length; i += 1) {\n        if (model.match(candidates[i], self.query)) {\n          // If a sort is defined, wait for the results to be sorted before applying limit and skip\n          if (!self._sort) {\n            if (self._skip && self._skip > skipped) {\n              skipped += 1;\n            } else {\n              res.push(candidates[i]);\n              added += 1;\n              if (self._limit && self._limit <= added) { break; }\n            }\n          } else {\n            res.push(candidates[i]);\n          }\n        }\n      }\n    } catch (err) {\n      return callback(err);\n    }\n\n    // Apply all sorts\n    if (self._sort) {\n      keys = Object.keys(self._sort);\n\n      // Sorting\n      var criteria = [];\n      for (i = 0; i < keys.length; i++) {\n        key = keys[i];\n        criteria.push({ key: key, direction: self._sort[key] });\n      }\n      res.sort(function(a, b) {\n        var criterion, compare, i;\n        for (i = 0; i < criteria.length; i++) {\n          criterion = criteria[i];\n          compare = criterion.direction * model.compareThings(model.getDotValue(a, criterion.key), model.getDotValue(b, criterion.key), self.db.compareStrings);\n          if (compare !== 0) {\n            return compare;\n          }\n        }\n        return 0;\n      });\n\n      // Applying limit and skip\n      var limit = self._limit || res.length\n        , skip = self._skip || 0;\n\n      res = res.slice(skip, skip + limit);\n    }\n\n    // Apply projection\n    try {\n      res = self.project(res);\n    } catch (e) {\n      error = e;\n      res = undefined;\n    }\n\n    return callback(error, res);\n  });\n};\n\nCursor.prototype.exec = function () {\n  this.db.executor.push({ this: this, fn: this._exec, arguments: arguments });\n};\n\n\n\n// Interface\nmodule.exports = Cursor;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbmVkYi9saWIvY3Vyc29yLmpzPzUzZWMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBNYW5hZ2UgYWNjZXNzIHRvIGRhdGEsIGJlIGl0IHRvIGZpbmQsIHVwZGF0ZSBvciByZW1vdmUgaXRcbiAqL1xudmFyIG1vZGVsID0gcmVxdWlyZSgnLi9tb2RlbCcpXG4gICwgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKVxuICA7XG5cblxuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBjdXJzb3IgZm9yIHRoaXMgY29sbGVjdGlvblxuICogQHBhcmFtIHtEYXRhc3RvcmV9IGRiIC0gVGhlIGRhdGFzdG9yZSB0aGlzIGN1cnNvciBpcyBib3VuZCB0b1xuICogQHBhcmFtIHtRdWVyeX0gcXVlcnkgLSBUaGUgcXVlcnkgdGhpcyBjdXJzb3Igd2lsbCBvcGVyYXRlIG9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBleGVjRm4gLSBIYW5kbGVyIHRvIGJlIGV4ZWN1dGVkIGFmdGVyIGN1cnNvciBoYXMgZm91bmQgdGhlIHJlc3VsdHMgYW5kIGJlZm9yZSB0aGUgY2FsbGJhY2sgcGFzc2VkIHRvIGZpbmQvZmluZE9uZS91cGRhdGUvcmVtb3ZlXG4gKi9cbmZ1bmN0aW9uIEN1cnNvciAoZGIsIHF1ZXJ5LCBleGVjRm4pIHtcbiAgdGhpcy5kYiA9IGRiO1xuICB0aGlzLnF1ZXJ5ID0gcXVlcnkgfHwge307XG4gIGlmIChleGVjRm4pIHsgdGhpcy5leGVjRm4gPSBleGVjRm47IH1cbn1cblxuXG4vKipcbiAqIFNldCBhIGxpbWl0IHRvIHRoZSBudW1iZXIgb2YgcmVzdWx0c1xuICovXG5DdXJzb3IucHJvdG90eXBlLmxpbWl0ID0gZnVuY3Rpb24obGltaXQpIHtcbiAgdGhpcy5fbGltaXQgPSBsaW1pdDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5cbi8qKlxuICogU2tpcCBhIHRoZSBudW1iZXIgb2YgcmVzdWx0c1xuICovXG5DdXJzb3IucHJvdG90eXBlLnNraXAgPSBmdW5jdGlvbihza2lwKSB7XG4gIHRoaXMuX3NraXAgPSBza2lwO1xuICByZXR1cm4gdGhpcztcbn07XG5cblxuLyoqXG4gKiBTb3J0IHJlc3VsdHMgb2YgdGhlIHF1ZXJ5XG4gKiBAcGFyYW0ge1NvcnRRdWVyeX0gc29ydFF1ZXJ5IC0gU29ydFF1ZXJ5IGlzIHsgZmllbGQ6IG9yZGVyIH0sIGZpZWxkIGNhbiB1c2UgdGhlIGRvdC1ub3RhdGlvbiwgb3JkZXIgaXMgMSBmb3IgYXNjZW5kaW5nIGFuZCAtMSBmb3IgZGVzY2VuZGluZ1xuICovXG5DdXJzb3IucHJvdG90eXBlLnNvcnQgPSBmdW5jdGlvbihzb3J0UXVlcnkpIHtcbiAgdGhpcy5fc29ydCA9IHNvcnRRdWVyeTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5cbi8qKlxuICogQWRkIHRoZSB1c2Ugb2YgYSBwcm9qZWN0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvamVjdGlvbiAtIE1vbmdvREItc3R5bGUgcHJvamVjdGlvbi4ge30gbWVhbnMgdGFrZSBhbGwgZmllbGRzLiBUaGVuIGl0J3MgeyBrZXkxOiAxLCBrZXkyOiAxIH0gdG8gdGFrZSBvbmx5IGtleTEgYW5kIGtleTJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBrZXkxOiAwLCBrZXkyOiAwIH0gdG8gb21pdCBvbmx5IGtleTEgYW5kIGtleTIuIEV4Y2VwdCBfaWQsIHlvdSBjYW4ndCBtaXggdGFrZXMgYW5kIG9taXRzXG4gKi9cbkN1cnNvci5wcm90b3R5cGUucHJvamVjdGlvbiA9IGZ1bmN0aW9uKHByb2plY3Rpb24pIHtcbiAgdGhpcy5fcHJvamVjdGlvbiA9IHByb2plY3Rpb247XG4gIHJldHVybiB0aGlzO1xufTtcblxuXG4vKipcbiAqIEFwcGx5IHRoZSBwcm9qZWN0aW9uXG4gKi9cbkN1cnNvci5wcm90b3R5cGUucHJvamVjdCA9IGZ1bmN0aW9uIChjYW5kaWRhdGVzKSB7XG4gIHZhciByZXMgPSBbXSwgc2VsZiA9IHRoaXNcbiAgICAsIGtlZXBJZCwgYWN0aW9uLCBrZXlzXG4gICAgO1xuXG4gIGlmICh0aGlzLl9wcm9qZWN0aW9uID09PSB1bmRlZmluZWQgfHwgT2JqZWN0LmtleXModGhpcy5fcHJvamVjdGlvbikubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGNhbmRpZGF0ZXM7XG4gIH1cblxuICBrZWVwSWQgPSB0aGlzLl9wcm9qZWN0aW9uLl9pZCA9PT0gMCA/IGZhbHNlIDogdHJ1ZTtcbiAgdGhpcy5fcHJvamVjdGlvbiA9IF8ub21pdCh0aGlzLl9wcm9qZWN0aW9uLCAnX2lkJyk7XG5cbiAgLy8gQ2hlY2sgZm9yIGNvbnNpc3RlbmN5XG4gIGtleXMgPSBPYmplY3Qua2V5cyh0aGlzLl9wcm9qZWN0aW9uKTtcbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgaWYgKGFjdGlvbiAhPT0gdW5kZWZpbmVkICYmIHNlbGYuX3Byb2plY3Rpb25ba10gIT09IGFjdGlvbikgeyB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBib3RoIGtlZXAgYW5kIG9taXQgZmllbGRzIGV4Y2VwdCBmb3IgX2lkXCIpOyB9XG4gICAgYWN0aW9uID0gc2VsZi5fcHJvamVjdGlvbltrXTtcbiAgfSk7XG5cbiAgLy8gRG8gdGhlIGFjdHVhbCBwcm9qZWN0aW9uXG4gIGNhbmRpZGF0ZXMuZm9yRWFjaChmdW5jdGlvbiAoY2FuZGlkYXRlKSB7XG4gICAgdmFyIHRvUHVzaDtcbiAgICBpZiAoYWN0aW9uID09PSAxKSB7ICAgLy8gcGljay10eXBlIHByb2plY3Rpb25cbiAgICAgIHRvUHVzaCA9IHsgJHNldDoge30gfTtcbiAgICAgIGtleXMuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgICAgICB0b1B1c2guJHNldFtrXSA9IG1vZGVsLmdldERvdFZhbHVlKGNhbmRpZGF0ZSwgayk7XG4gICAgICAgIGlmICh0b1B1c2guJHNldFtrXSA9PT0gdW5kZWZpbmVkKSB7IGRlbGV0ZSB0b1B1c2guJHNldFtrXTsgfVxuICAgICAgfSk7XG4gICAgICB0b1B1c2ggPSBtb2RlbC5tb2RpZnkoe30sIHRvUHVzaCk7XG4gICAgfSBlbHNlIHsgICAvLyBvbWl0LXR5cGUgcHJvamVjdGlvblxuICAgICAgdG9QdXNoID0geyAkdW5zZXQ6IHt9IH07XG4gICAgICBrZXlzLmZvckVhY2goZnVuY3Rpb24gKGspIHsgdG9QdXNoLiR1bnNldFtrXSA9IHRydWUgfSk7XG4gICAgICB0b1B1c2ggPSBtb2RlbC5tb2RpZnkoY2FuZGlkYXRlLCB0b1B1c2gpO1xuICAgIH1cbiAgICBpZiAoa2VlcElkKSB7XG4gICAgICB0b1B1c2guX2lkID0gY2FuZGlkYXRlLl9pZDtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHRvUHVzaC5faWQ7XG4gICAgfVxuICAgIHJlcy5wdXNoKHRvUHVzaCk7XG4gIH0pO1xuXG4gIHJldHVybiByZXM7XG59O1xuXG5cbi8qKlxuICogR2V0IGFsbCBtYXRjaGluZyBlbGVtZW50c1xuICogV2lsbCByZXR1cm4gcG9pbnRlcnMgdG8gbWF0Y2hlZCBlbGVtZW50cyAoc2hhbGxvdyBjb3BpZXMpLCByZXR1cm5pbmcgZnVsbCBjb3BpZXMgaXMgdGhlIHJvbGUgb2YgZmluZCBvciBmaW5kT25lXG4gKiBUaGlzIGlzIGFuIGludGVybmFsIGZ1bmN0aW9uLCB1c2UgZXhlYyB3aGljaCB1c2VzIHRoZSBleGVjdXRvclxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gU2lnbmF0dXJlOiBlcnIsIHJlc3VsdHNcbiAqL1xuQ3Vyc29yLnByb3RvdHlwZS5fZXhlYyA9IGZ1bmN0aW9uKF9jYWxsYmFjaykge1xuICB2YXIgcmVzID0gW10sIGFkZGVkID0gMCwgc2tpcHBlZCA9IDAsIHNlbGYgPSB0aGlzXG4gICAgLCBlcnJvciA9IG51bGxcbiAgICAsIGksIGtleXMsIGtleVxuICAgIDtcblxuICBmdW5jdGlvbiBjYWxsYmFjayAoZXJyb3IsIHJlcykge1xuICAgIGlmIChzZWxmLmV4ZWNGbikge1xuICAgICAgcmV0dXJuIHNlbGYuZXhlY0ZuKGVycm9yLCByZXMsIF9jYWxsYmFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBfY2FsbGJhY2soZXJyb3IsIHJlcyk7XG4gICAgfVxuICB9XG5cbiAgdGhpcy5kYi5nZXRDYW5kaWRhdGVzKHRoaXMucXVlcnksIGZ1bmN0aW9uIChlcnIsIGNhbmRpZGF0ZXMpIHtcbiAgICBpZiAoZXJyKSB7IHJldHVybiBjYWxsYmFjayhlcnIpOyB9XG5cbiAgICB0cnkge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGNhbmRpZGF0ZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKG1vZGVsLm1hdGNoKGNhbmRpZGF0ZXNbaV0sIHNlbGYucXVlcnkpKSB7XG4gICAgICAgICAgLy8gSWYgYSBzb3J0IGlzIGRlZmluZWQsIHdhaXQgZm9yIHRoZSByZXN1bHRzIHRvIGJlIHNvcnRlZCBiZWZvcmUgYXBwbHlpbmcgbGltaXQgYW5kIHNraXBcbiAgICAgICAgICBpZiAoIXNlbGYuX3NvcnQpIHtcbiAgICAgICAgICAgIGlmIChzZWxmLl9za2lwICYmIHNlbGYuX3NraXAgPiBza2lwcGVkKSB7XG4gICAgICAgICAgICAgIHNraXBwZWQgKz0gMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlcy5wdXNoKGNhbmRpZGF0ZXNbaV0pO1xuICAgICAgICAgICAgICBhZGRlZCArPSAxO1xuICAgICAgICAgICAgICBpZiAoc2VsZi5fbGltaXQgJiYgc2VsZi5fbGltaXQgPD0gYWRkZWQpIHsgYnJlYWs7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzLnB1c2goY2FuZGlkYXRlc1tpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICB9XG5cbiAgICAvLyBBcHBseSBhbGwgc29ydHNcbiAgICBpZiAoc2VsZi5fc29ydCkge1xuICAgICAga2V5cyA9IE9iamVjdC5rZXlzKHNlbGYuX3NvcnQpO1xuXG4gICAgICAvLyBTb3J0aW5nXG4gICAgICB2YXIgY3JpdGVyaWEgPSBbXTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICAgIGNyaXRlcmlhLnB1c2goeyBrZXk6IGtleSwgZGlyZWN0aW9uOiBzZWxmLl9zb3J0W2tleV0gfSk7XG4gICAgICB9XG4gICAgICByZXMuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgIHZhciBjcml0ZXJpb24sIGNvbXBhcmUsIGk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjcml0ZXJpYS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNyaXRlcmlvbiA9IGNyaXRlcmlhW2ldO1xuICAgICAgICAgIGNvbXBhcmUgPSBjcml0ZXJpb24uZGlyZWN0aW9uICogbW9kZWwuY29tcGFyZVRoaW5ncyhtb2RlbC5nZXREb3RWYWx1ZShhLCBjcml0ZXJpb24ua2V5KSwgbW9kZWwuZ2V0RG90VmFsdWUoYiwgY3JpdGVyaW9uLmtleSksIHNlbGYuZGIuY29tcGFyZVN0cmluZ3MpO1xuICAgICAgICAgIGlmIChjb21wYXJlICE9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gY29tcGFyZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9KTtcblxuICAgICAgLy8gQXBwbHlpbmcgbGltaXQgYW5kIHNraXBcbiAgICAgIHZhciBsaW1pdCA9IHNlbGYuX2xpbWl0IHx8IHJlcy5sZW5ndGhcbiAgICAgICAgLCBza2lwID0gc2VsZi5fc2tpcCB8fCAwO1xuXG4gICAgICByZXMgPSByZXMuc2xpY2Uoc2tpcCwgc2tpcCArIGxpbWl0KTtcbiAgICB9XG5cbiAgICAvLyBBcHBseSBwcm9qZWN0aW9uXG4gICAgdHJ5IHtcbiAgICAgIHJlcyA9IHNlbGYucHJvamVjdChyZXMpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGVycm9yID0gZTtcbiAgICAgIHJlcyA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICByZXR1cm4gY2FsbGJhY2soZXJyb3IsIHJlcyk7XG4gIH0pO1xufTtcblxuQ3Vyc29yLnByb3RvdHlwZS5leGVjID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmRiLmV4ZWN1dG9yLnB1c2goeyB0aGlzOiB0aGlzLCBmbjogdGhpcy5fZXhlYywgYXJndW1lbnRzOiBhcmd1bWVudHMgfSk7XG59O1xuXG5cblxuLy8gSW50ZXJmYWNlXG5tb2R1bGUuZXhwb3J0cyA9IEN1cnNvcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL25lZGIvbGliL2N1cnNvci5qc1xuLy8gbW9kdWxlIGlkID0gMzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///31\n");

/***/ }),
/* 32 */
/*!*************************!*\
  !*** external "events" ***!
  \*************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports) {

eval("module.exports = require(\"events\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJldmVudHNcIj9jNjhmIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImV2ZW50c1wiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcImV2ZW50c1wiXG4vLyBtb2R1bGUgaWQgPSAzMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///32\n");

/***/ }),
/* 33 */
/*!*************************!*\
  !*** external "lokijs" ***!
  \*************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports) {

eval("module.exports = require(\"lokijs\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJsb2tpanNcIj9hMzdhIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImxva2lqc1wiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcImxva2lqc1wiXG4vLyBtb2R1bGUgaWQgPSAzM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///33\n");

/***/ }),
/* 34 */
/*!********************************************************!*\
  !*** external "lokijs/src/loki-fs-structured-adapter" ***!
  \********************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports) {

eval("module.exports = require(\"lokijs/src/loki-fs-structured-adapter\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJsb2tpanMvc3JjL2xva2ktZnMtc3RydWN0dXJlZC1hZGFwdGVyXCI/YTNlOCJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJsb2tpanMvc3JjL2xva2ktZnMtc3RydWN0dXJlZC1hZGFwdGVyXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwibG9raWpzL3NyYy9sb2tpLWZzLXN0cnVjdHVyZWQtYWRhcHRlclwiXG4vLyBtb2R1bGUgaWQgPSAzNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///34\n");

/***/ })
/******/ ]);